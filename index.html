<!DOCTYPE html>
<html>
  <head>
    <title>
      검증가능한 크리덴셜 데이터 모델 Verifiable Credentials Data Model v2.0
    </title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
    ></script>
    <script src="./common.js" class="remove"></script>
    <script
      class="remove"
      src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@2.0.1/dist/main.js"
    ></script>
    <script
      class="removeOnSave"
      src="https://unpkg.com/reqlist/lib/reqlist.js"
    ></script>
    <link
      class="removeOnSave"
      rel="stylesheet"
      type="text/css"
      href="https://unpkg.com/reqlist/lib/reqlist.css"
    />

    <script class="remove">
      var respecConfig = {
        group: 'vc',

        // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: 'CRD',

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: 'vc-data-model-2.0',

        // subtitle for the spec
        //subtitle: "Expressing information with verifiable provenance",

        // if you wish the publication date to be other than today, set this
        //publishDate: "2024-01-23",
        crEnd: '2024-03-23',
        //prEnd: "2019-10-01",
        implementationReportURI:
          'https://w3c.github.io/vc-data-model-2.0-test-suite/',
        //errata: "https://w3c.github.io/vc-data-model/errata.html",
        previousMaturity: 'REC',
        previousPublishDate: '2022-03-03',

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: vcwg.localBiblio,
        doJsonLd: true,

        // Uncomment these to use the respec extension that generates a list of
        //   normative statements:
        preProcess: [
          /*prepare_reqlist*/
        ],
        postProcess: [
          restrictRefs,
          window.respecVc.createVcExamples,
          /*add_reqlist_button*/
        ],

        github: 'https://github.com/w3c/vc-data-model/',
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: 'https://w3c.github.io/vc-data-model/',

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          {
            name: 'Manu Sporny',
            url: 'https://www.linkedin.com/in/manusporny/',
            company: 'Digital Bazaar',
            companyURL: 'https://digitalbazaar.com/',
            note: 'v1.0, v1.1, v2.0',
            w3cid: 41758,
          },
          {
            name: 'Ted Thibodeau Jr',
            url: 'https://github.com/TallTed',
            company: 'OpenLink Software',
            companyURL: 'https://www.openlinksw.com/',
            note: 'v2.0',
            w3cid: 42501,
          },
          {
            name: 'Ivan Herman',
            url: 'https://www.w3.org/People/Ivan/',
            company: 'W3C',
            companyURL: 'https://www.w3.org',
            note: 'v2.0',
            w3cid: 7382,
            orcid: '0000-0003-0782-2704',
          },
          {
            name: 'Michael B. Jones',
            url: 'https://self-issued.info/',
            company: 'Invited Expert',
            note: 'v2.0',
            w3cid: 38745,
          },
          {
            name: 'Gabe Cohen',
            url: 'https://github.com/decentralgabe',
            company: 'Block',
            companyURL: 'https://block.xyz/',
            note: 'v2.0',
            w3cid: 116851,
          },
        ],
        formerEditors: [
          {
            name: 'Grant Noble',
            url: 'https://www.linkedin.com/in/grant-noble-8253994a/',
            company: 'ConsenSys',
            companyURL: 'https://consensys.net/',
            note: 'v1.0',
            w3cid: 110600,
          },
          {
            name: 'Dave Longley',
            url: 'https://github.com/dlongley',
            company: 'Digital Bazaar',
            companyURL: 'https://digitalbazaar.com/',
            note: 'v1.0',
            w3cid: 48025,
          },
          {
            name: 'Daniel C. Burnett',
            url: 'https://www.linkedin.com/in/daburnett/',
            company: 'ConsenSys',
            companyURL: 'https://consensys.net/',
            note: 'v1.0',
            w3cid: 37473,
          },
          {
            name: 'Brent Zundel',
            url: 'https://www.linkedin.com/in/bzundel/',
            company: 'Evernym',
            companyURL: 'https://www.evernym.com/',
            note: 'v1.0',
            w3cid: 102128,
          },
          {
            name: 'Kyle Den Hartog',
            url: 'https://www.linkedin.com/in/kyledenhartog/',
            company: 'MATTR',
            companyURL: 'https://mattr.global/',
            note: 'v1.1',
            w3cid: 103517,
          },
          {
            name: 'Orie Steele',
            url: 'https://github.com/OR13',
            company: 'Transmute',
            companyURL: 'https://transmute.industries/',
            note: 'v2.0',
            w3cid: 109171,
          },
          {
            name: 'Oliver Terbu',
            url: 'https://github.com/awoie',
            company: 'Spruce Systems',
            companyURL: 'https://spruceid.com/',
            note: 'v2.0',
            w3cid: 110059,
          },
        ],
        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors: [
          {
            name: 'Manu Sporny',
            url: 'https://digitalbazaar.com/',
            company: 'Digital Bazaar',
            companyURL: 'https://digitalbazaar.com/',
            w3cid: 41758,
          },
          {
            name: 'Dave Longley',
            url: 'https://digitalbazaar.com/',
            company: 'Digital Bazaar',
            companyURL: 'https://digitalbazaar.com/',
            w3cid: 48025,
          },
          {
            name: 'David Chadwick',
            url: 'https://www.linkedin.com/in/davidwchadwick/',
            company: 'Crossword Cybersecurity PLC',
            companyURL: 'https://www.crosswordcybersecurity.com/',
            w3cid: 46156,
          },
          {
            name: 'Orie Steele',
            url: 'https://github.com/OR13',
            company: 'Transmute',
            companyURL: 'https://www.transmute.industries/',
            note: 'v2.0',
            w3cid: 109171,
          },
        ],
        xref: ['URL', 'I18N-GLOSSARY', 'INFRA'],
        lint: { 'informative-dfn': false },
        maxTocLevel: 3,
        inlineCSS: true,
      };
    </script>
    <style>
      code {
        color: rgb(199, 73, 0);
        font-weight: bold;
      }
      pre {
        overflow-x: auto;
        white-space: pre-wrap;
      }
      pre .highlight {
        font-weight: bold;
        color: Green;
      }
      pre .subject {
        font-weight: bold;
        color: RoyalBlue;
      }
      pre .property {
        font-weight: bold;
        color: DarkGoldenrod;
      }
      pre .comment {
        font-weight: bold;
        color: SteelBlue;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      ol.algorithm {
        counter-reset: numsection;
        list-style-type: none;
      }
      ol.algorithm li {
        margin: 0.5em 0;
      }
      ol.algorithm li:before {
        font-weight: bold;
        counter-increment: numsection;
        content: counters(numsection, '.') ') ';
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        [=크리덴셜=]은 우리 일상생활의 한 부분이다. 운전면허증은 우리가 자동차를
        운전할 수 있는 능력이 있음을 주장하는 데 사용되고, 대학 학위는 우리의
        교육 수준을 주장하는 데 사용될 수 있으며, 정부에서 발급한 여권은 우리가
        국가 간에 여행할 수 있게 해준다. 이 규격은 이러한 종류의 [=크리덴셜=]을
        암호학적으로 안전하고, 프라이버시를 존중하며, 기계적으로 검증 가능한
        방식으로 웹에서 표현할 수 있는 메커니즘을 제공한다.
      </p>
    </section>

    <section id="sotd">
      <p>
        The Working Group is actively seeking implementation feedback for this
        specification. In order to exit the Candidate Recommendation phase, the
        Working Group has set the requirement of at least two independent
        implementations for each mandatory feature in the specification. Please
        see the
        <a href="https://w3c.github.io/vc-data-model-2.0-test-suite/">
          implementation report</a
        >
        for more details.
      </p>

      <p>
        Comments regarding this specification are welcome at any time. Please
        file issues directly on
        <a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>, or,
        if that is not possible, send them to
        <a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
        (<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe"
          >subscribe</a
        >,
        <a href="https://lists.w3.org/Archives/Public/public-vc-comments/"
          >archives</a
        >).
      </p>
    </section>

    <section class="informative">
      <h2>서론</h2>

      <p>
        [=크리덴셜=]은 우리 일상생활의 한 부분이다. 운전면허증은 우리가 자동차를
        운전할 수 있는 능력이 있음을 주장하는 데 사용되고, 대학 학위는 우리의
        교육 수준을 주장하는 데 사용될 수 있으며, 정부에서 발급한 여권은 우리가
        국가 간에 여행할 수 있게 해준다. 이러한 [=크리덴셜=]은 물리적 세계에서
        사용될 때 우리에게 이점을 제공하지만, 웹에서의 사용은 여전히 난해한
        상태이다.
      </p>

      <p>
        현재 웹에서 교육 자격, 의료 데이터, 금융 계좌 세부 정보 및 기타 종류의
        제3자 [=검증=]된 기계 판독 가능한 개인 정보를 표현하는 것은 어렵다.
        웹에서 디지털 [=크리덴셜=]을 표현하는 것이 어렵기 때문에 물리적
        [=크리덴셜=]이 물리적 세계에서 우리에게 제공하는 것과 동일한 이점을 웹을
        통해 받는 것이 어려워진다.
      </p>

      <p>
        이 규격은 [=크리덴셜=]을 암호학적으로 안전하고, 프라이버시를 존중하며,
        기계적으로 검증 가능한 방식으로 웹에서 표현할 수 있는 표준 방법을
        제공한다.
      </p>

      <p>
        [=검증가능한 크리덴셜=]과 관련된 개념에 익숙하지 않은 사람들을 위해 다음
        섹션에서는 다음에 대한 개요를 제공한다.
      </p>

      <ul>
        <li>[=검증가능한 크리덴셜=]을 구성하는 컴포넌트</li>
        <li>[=검증가능한 프레젠테이션=]을 구성하는 컴포넌트</li>
        <li>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]이 유용할 것으로
          예상되는 생태계
        </li>
      </ul>
      <p>
        이 규격에 영향을 준 사용 사례와 요구사항은 [[[VC-USE-CASES]]]
        [[?VC-USE-CASES]]에서 확인할 수 있다.
      </p>

      <section class="informative">
        <h3>검증가능한 크리덴셜이란 무엇인가?</h3>

        <p>물리적 세계에서 [=크리덴셜=]은 다음으로 구성될 수 있다.</p>

        <ul>
          <li>
            [=크리덴셜=]의 [=주체=]를 식별하는 것과 관련된 정보 (예: 사진, 이름
            또는 식별 번호)
          </li>
          <li>
            발급 기관과 관련된 정보 (예: 시 정부, 국가 기관 또는 인증 기관)
          </li>
          <li>
            이것이 어떤 유형의 [=크리덴셜=]인지에 대한 정보 (예: 네덜란드 여권,
            미국 운전면허증 또는 건강보험증)
          </li>
          <li>
            발급 기관이 [=주체=]에 대해 주장하는 특정 속성이나 속성에 관련된
            정보 (예: 국적, 운전 가능한 차량 등급 또는 생년월일)
          </li>
          <li>[=크리덴셜=]이 어떻게 파생되었는지에 대한 증거</li>
          <li>
            크리덴셜에 대한 제약 조건에 관련된 정보 (예: 유효 기간 또는 사용
            약관).
          </li>
        </ul>

        <p>
          [=검증가능한 크리덴셜=]은 물리적 [=크리덴셜=]이 나타내는 모든 정보를
          표현할 수 있다. 디지털 서명과 같은 기술의 추가로 인해 [=검증가능한
          크리덴셜=]은 물리적인 크리덴셜보다 변조가 더 어렵고 신뢰할 수 있게
          된다.
        </p>

        <p>
          [=검증가능한 크리덴셜=]의 [=보유자=]는 [=검증가능한 프레젠테이션=]을
          생성한 다음 이러한 [=검증가능한 프레젠테이션=]을 [=검증자=]와 공유하여
          특정 특성을 가진 [=검증가능한 크리덴셜=]을 소유하고 있음을 증명할 수
          있다.
        </p>
        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=] 모두 빠르게
          전송될 수 있어, 원격으로 신뢰를 구축하려고 할 때 물리적인 크리덴셜보다
          더 편리하다.
        </p>

        <p>
          이 규격은 디지털 [=크리덴셜=]을 쉽게 표현할 수 있도록 하는 동시에, 이
          목표를 다수의 프라이버시 보호 목표와 균형을 맞추려고 시도한다. 디지털
          정보의 지속성과 이질적인 디지털 데이터 출처를 쉽게 수집하고 연관시킬
          수 있다는 점은 [=검증 가능=]하고 쉽게 기계 판독이 가능한
          [=크리덴셜=]의 사용으로 인해 악화될 수 있는 프라이버시 문제이다. 이
          문서는
          <a href="#privacy-considerations"></a> 섹션에서 이러한 문제들을
          설명하고 해결하려고 시도한다. 영지식 증명과 같은 프라이버시 강화
          기술을 사용하여 이 데이터 모델을 사용하는 방법의 예시도 이 문서 전반에
          걸쳐 제공된다.
        </p>

        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]에서
          "검증가능한"이라는 단어는 이 문서에서 정의한 대로 [=검증자=]에 의해
          [=검증=]될 수 있는 [=크리덴셜=] 또는 [=프레젠테이션=]의 특성을 말한다.
          크리덴셜의 검증가능성은 크리덴셜에 인코딩된 [=클레임=]의 진실성을
          의미하지는 않는다. 오히려 [=검증가능한 크리덴셜=] 또는 [=검증가능한
          프레젠테이션=]의 진위성과 통용성이 확립되면, [=검증자=]는 포함된
          클레임을 자신의 비즈니스 규칙을 사용하여 검증한 후에 이를 신뢰한다.
          이러한 신뢰는 하나 이상의 검증자 정책에 따라 발급자, 증명, 주체 및
          클레임을 평가한 후에만 발생한다.
        </p>
      </section>

      <section class="informative">
        <h3 id="ecosystem-overview">생태계 개요</h3>

        <p>
          이 섹션에서는 [=검증가능한 크리덴셜=]이 유용할 것으로 예상되는
          생태계에서 핵심 참여자의 역할과 그들 간의 관계에 대해 설명한다. 역할은
          다양한 방식으로 구현될 수 있는 추상적인 개념이다. 역할의 분리는
          표준화를 위한 인터페이스와 프로토콜을 제안한다. 이 규격에서는 다음과
          같은 역할을 소개한다.
        </p>

        <dl>
          <dt>[=보유자=]</dt>
          <dd>
            하나 이상의 [=검증가능한 크리덴셜=]을 소유하고 이로부터 [=검증가능한
            프레젠테이션=]을 생성함으로써 [=엔티티=]가 수행할 수 있는 역할.
            보유자의 예로는 학생, 직원 및 고객이 있다.
          </dd>
          <dt>[=발급자=]</dt>
          <dd>
            하나 이상의 [=주체=]에 대한 [=클레임=]을 주장하고, 이러한
            [=클레임=]으로부터 [=검증가능한 크리덴셜=]을 만들고, [=검증가능한
            크리덴셜=]을 [=보유자=]에게 전송함으로써 [=엔티티=]가 수행하는 역할.
            발급자의 예로는 기업, 비영리 단체, 무역 협회, 정부 및 개인이 있다.
          </dd>
          <dt>[=주체=]</dt>
          <dd>
            [=클레임=]이 만들어지는 대상인 [=엔티티=]. 주체의 예로는 인간, 동물
            및 사물이 있다. 대부분의 경우 [=검증가능한 크리덴셜=]의 [=보유자=]가
            주체이지만, 특정 경우에는 그렇지 않다. 예를 들어, 부모([=보유자=])가
            자녀([=주체=])의 [=검증가능한 크리덴셜=]을 보유하거나, 애완동물
            주인([=보유자=])이 애완동물([=주체=])의 [=검증가능한 크리덴셜=]을
            보유할 수 있다. 이러한 특수한 경우에 대한 자세한 내용은 검증가능한
            크리덴셜 구현 가이드[[VC-IMP-GUIDE]]의
            <a
              href="https://www.w3.org/TR/vc-imp-guide/#subject-holder-relationships"
              >주체-보유자 관계</a
            >
            섹션을 참조하라.
          </dd>
          <dt>[=검증자=]</dt>
          <dd>
            처리를 위해 하나 이상의 [=검증가능한 크리덴셜=]을 선택적으로
            [=검증가능한 프레젠테이션=] 내에서 수신함으로써 [=엔티티=]가
            수행하는 역할. 검증자의 예로는 고용주, 보안 담당자 및 웹사이트 등이
            있다.
          </dd>
          <dt>[=검증가능한 데이터 레지스트리=]</dt>
          <dd>
            [=검증가능한 크리덴셜=] 사용에 필요할 수 있는 식별자, 키 및 기타
            관련 데이터(예: [=검증가능한 크리덴셜=] 스키마, 폐기 레지스트리,
            발급자 공개 키 등)의 생성 및 [=검증=]을 중재함으로써 시스템이 수행할
            수 있는 역할. 일부 구성에서는 [=주체=]에 대한 상관관계가 있는
            식별자가 필요할 수 있다. 검증가능한 데이터 레지스트리의 예로는
            신뢰할 수 있는 데이터베이스, 탈중앙화된 데이터베이스, 정부 ID
            데이터베이스 및 분산 원장 등이 있다. 종종 생태계에서는 두 가지
            이상의 유형의 검증가능한 데이터 레지스트리가 활용된다.
          </dd>
        </dl>

        <figure id="roles">
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/ecosystem.svg"
            alt="diagram showing how
               credentials flow from issuer to holder and
               presentations flow from holder to verifier where all
               three parties can use information from a logical
               verifiable data registry"
          />
          <figcaption style="text-align: center">
            The roles and information flows forming the basis for this
            specification.
          </figcaption>
        </figure>

        <p class="note">
          <a href="#roles"></a> above provides an example ecosystem in which to
          ground the rest of the concepts in this specification. Other
          ecosystems exist, such as protected environments or proprietary
          systems, where [=verifiable credentials=] also provide benefit.
        </p>
      </section>

      <section id="conformance" class="normative">
        <p>
          A
          <dfn data-lt="conforming document|적합한 문서"
            >conforming document</dfn
          >
          is a
          <a data-cite="JSON-LD11-API#compaction-algorithms">compacted</a>
          JSON-LD document that complies with all of the relevant "MUST"
          statements in this specification. Specifically, the relevant normative
          "MUST" statements in Sections <a href="#basic-concepts"></a>,
          <a href="#advanced-concepts"></a>, and <a href="#syntaxes"></a> of
          this document MUST be enforced. A conforming document is either a
          [=verifiable credential=] that MUST be serialized using the
          `application/vc+ld+json` media type or a [=verifiable presentation=]
          that MUST be serialized using the `application/vp+ld+json` media type.
          A conforming document MUST be secured by at least one securing
          mechanism as described in Section <a href="#securing-mechanisms"></a>.
        </p>

        <p>
          A
          <dfn class="lint-ignore">conforming issuer implementation</dfn>
          produces [=conforming documents=], MUST include all required
          properties in the [=conforming documents=] that it produces, and MUST
          secure the [=conforming documents=] it produces using a securing
          mechanism as described in Section <a href="#securing-mechanisms"></a>.
        </p>

        <p>
          A
          <dfn
            class="lint-ignore"
            data-lt="conforming verifier implementation|적합한 검증자 구현"
            >conforming verifier implementation</dfn
          >
          consumes [=conforming documents=], MUST perform [=verification=] on a
          [=conforming document=] as described in Section
          <a href="#securing-mechanisms"></a>, MUST check that each required
          property satisfies the normative requirements for that property, and
          MUST produce errors when non-[=conforming documents=] are detected.
        </p>

        <p>
          This specification includes both required and optional properties.
          Optional properties MAY be ignored by [=conforming issuer
          implementations=] and/or [=conforming verifier implementations=].
        </p>

        <p>
          This document also contains examples that contain characters that are
          invalid JSON, such as inline comments (`//`) and the use of ellipsis
          (`...`) to denote information that adds little value to the example.
          Implementers are cautioned to remove this content if they desire to
          use the information as a valid document.
        </p>

        <p
          class="note"
          title="Human-readable texts in English are illustrative"
        >
          Examples provided throughout this document include descriptive fields,
          such as `name` and `description`, with values in English to simplify
          the concepts in each example of the specification. These examples do
          not necessarily reflect the data structures needed for international
          use, which is described in more detail in Section
          [[[#internationalization-considerations]]].
        </p>
      </section>
    </section>

    <section class="normative">
      <h2>Terminology</h2>

      <p>본 명세서의 개념을 설명하기 위해 다음 용어가 사용된다.</p>

      <dl class="termlist">
        <dt><dfn data-lt="claims|클레임">클레임(claim)</dfn></dt>
        <dd><a>주체</a>에 대해 이루어진 주장이다.</dd>
        <dt>
          <dfn data-lt="credential|credentials|크리덴셜"
            >크리덴셜(credential)</dfn
          >
        </dt>
        <dd>
          <a>발급자</a>에 의해 만들어진 하나 이상의 <a>클레임</a> 집합이다.
          크리덴셜의 <a>클레임</a>은 서로 다른 <a>주체</a>에 관한 것일 수 있다.
          <p>
            우리의 크리덴셜 정의는
            <a href="https://csrc.nist.gov/glossary/term/credential"
              >NIST의 크리덴셜 정의</a
            >와 다르다.
          </p>
        </dd>
        <dt>
          <dfn data-lt="데이터 최소화">데이터 최소화(data minimization)</dfn>
        </dt>
        <dd>
          어떤 작업이나 목표를 성공적으로 달성하는 데 필요한 최소한의 데이터로
          공유 데이터의 양을 엄격히 제한하는 행위이다.
        </dd>
        <dt>
          <dfn data-lt="decentralized identifiers|DID|DIDs|탈중앙 식별자"
            >탈중앙 식별자(decentralized identifier)</dfn
          >
        </dt>
        <dd>
          <strong><em>DID</em></strong
          >라고도 불리는 포터블 URL 기반 식별자로, <a>엔티티</a>와 연관된다.
          이러한 식별자는 주로 <a>검증가능한 크리덴셜</a>에서 사용되며
          <a>주체</a>와 연관되어 있어서, <a>검증가능한 크리덴셜</a> 자체를
          <a>크리덴셜</a>을 재발급할 필요 없이 한 <a>리포지토리</a>에서 다른
          곳으로 쉽게 이동할 수 있다. DID의 예로는 `did:example:123456abcdef`가
          있다.
        </dd>
        <dt>
          <dfn
            class="lint-ignore"
            data-lt="decentralized identifier documents|DID document|DID documents|탈중앙 식별자
          문서"
            >탈중앙 식별자 문서(decentralized identifier document)</dfn
          >
        </dt>
        <dd>
          <strong><em>DID 문서</em></strong
          >라고도 하며, <a>검증가능한 데이터 레지스트리</a>를 사용하여 접근할 수
          있는 문서로, 관련 <a>리포지토리</a> 및 공개키 정보와 같은 특정
          <a>탈중앙 식별자</a>와 관련된 정보를 포함한다.
        </dd>
        <dt>
          <dfn data-lt="default graph|기본 그래프"
            >기본 그래프(default graph)</dfn
          >
        </dt>
        <dd>
          <a>명명된 그래프</a>의 일부가 아닌 모든 <a>클레임</a>을 포함하는
          <a>그래프</a>이다.
        </dd>
        <dt>
          <dfn
            class="lint-ignore"
            data-lt="predicates|derived predicates|파생술어"
            >파생술어(derived predicate)</dfn
          >
        </dt>
        <dd>
          <a>검증가능한 크리덴셜</a>의 다른 속성값에 대한 검증가능한 boolean
          주장이다. 정보 공개를 제한할 수 있기 때문에 영지식증명 스타일의
          <a>검증가능한 프레젠테이션</a>에서 유용하다. 예를 들어,
          <a>검증가능한 크리덴셜</a>이 센티미터 단위의 특정 키를 나타내는 속성을
          포함하는 경우, 파생술어는 <a>검증가능한 크리덴셜</a>의 키 속성을
          참조하여 <a>발급자</a>가 최소 키 요구사항을 충족하는 키 값을
          증명하지만, 실제 키 값은 공개하지 않을 수 있다. 예를 들어,
          <a>주체</a>의 키가 150cm보다 크다는 것이다.
        </dd>
        <dt>
          <dfn class="lint-ignore" data-lt="디지털서명"
            >디지털서명(digital signature)</dfn
          >
        </dt>
        <dd>디지털 메시지의 신뢰성을 입증하기 위한 수학적 기법이다.</dd>
        <dt><dfn data-lt="entities|entity's|엔티티">엔티티(entity)</dfn></dt>
        <dd>
          명제에서 추상 명사나 구체 명사로 참조될 수 있는 모든 것이다.
          엔티티에는 사람, 조직, 물건, 문서, 추상 개념, 가상 캐릭터, 임의의
          텍스트 등을 포함하며 이에 국한되지 않는다. 모든 엔티티는 능력이 있다면
          생태계에서 역할을 수행할 수 있다. 예를 들어 "abc" 문자열은 크리덴셜을
          발급하는 등의 엔티티는 근본적으로 작용을 취할 수 없다.
        </dd>
        <dt><dfn data-lt="graphs|그래프">그래프(graph)</dfn></dt>
        <dd>
          <a>주체</a>와 다른 <a>주체</a> 또는 데이터와의 관계로 구성된 정보
          네트워크를 형성하는 클레임의 집합이다. 각 <a>클레임</a>은 그래프의
          일부이며, <a>명명된 그래프</a>의 경우 명시적이고
          <a>기본 그래프</a>에는 암시적이다.
        </dd>
        <dt>
          <dfn data-lt="holders|holder's|holders'|보유자">보유자(holder)</dfn>
        </dt>
        <dd>
          하나 이상의 <a>검증가능한 크리덴셜</a>을 소유하고 이로부터
          <a>검증가능한 프레젠테이션</a>을 생성하는 <a>엔티티</a>가 수행할 수
          있는 역할이다. 보유자는 종종 자신이 보유한
          <a>검증가능한 크리덴셜</a>의 <a>주체</a>이지만 항상 그런 것은 아니다.
          보유자는 <a>크리덴셜 리포지토리</a>에 자신의 <a>크리덴셜</a>을
          저장한다.
        </dd>
        <dt>
          <dfn class="lint-ignore" data-lt="identities|identity's|신원"
            >신원(identity)</dfn
          >
        </dt>
        <dd>
          다양한 맥락에서 <a>엔티티</a>를 추적하는 수단이다. 디지털 ID는
          일반적으로 식별자와 속성을 사용하여 디지털 맥락에서
          <a>엔티티</a> 상호작용을 추적하고 맞춤 설정할 수 있게 한다. ID 정보를
          의도하지 않게 배포하거나 사용하면 프라이버시가 침해될 수 있다. 그러한
          정보의 수집과 사용은 <a>데이터 최소화</a> 원칙을 따라야 한다.
        </dd>
        <dt>
          <dfn data-lt="identity providers|idp|신원 제공자"
            >신원 제공자(identity provider)</dfn
          >
        </dt>
        <dd>
          ID 제공자(Identity Provider), 줄여서 <em>IdP</em>라고도 한다. 연합
          또는 분산 네트워크 내에서 <a>검증자</a> 애플리케이션에 인증 서비스를
          제공하면서 <a>보유자</a>를 위한 ID 정보를 생성, 유지 관리 및 관리하는
          시스템이다. 이 경우 <a>보유자</a>는 항상 <a>주체</a>이다.
          <a>검증가능한 크리덴셜</a>이 무기명 <a>크리덴셜</a>인 경우에도
          <a>검증가능한 크리덴셜</a>은 <a>주체</a>와 함께 유지되며, 그렇지 않은
          경우 공격자에 의해 도난당한 것으로 간주한다. 이 규격에서는 이 문서의
          개념을 다른 규격과 비교하거나 매핑하는 경우를 제외하고는 이 용어를
          사용하지 않는다. 이 규격은 <a>신원 제공자</a> 개념을 <a>발급자</a>와
          <a>보유자</a>라는 두 가지 구별되는 개념으로 분리한다.
        </dd>
        <dt><dfn data-lt="issuers|issuer's|발급자">발급자(issuer)</dfn></dt>
        <dd>
          하나 이상의 <a>주체</a>에 대한 <a>클레임</a>을 주장하고, 이
          <a>클레임</a>으로부터 <a>검증가능한 크리덴셜</a>을 생성하고, 이를
          <a>보유자</a>에게 전송함으로써 <a>엔티티</a>가 수행할 수 있는
          역할이다.
        </dd>
        <dt>
          <dfn data-lt="named graphs|명명된 그래프"
            >명명된 그래프(named graph)</dfn
          >
        </dt>
        <dd>
          `verifiableCredential`과 같은 특정 속성과 관련된 <a>그래프</a>이다.
          이러한 속성은 해당 JSON 객체에 정의된 모든 <a>클레임</a>을 포함하는
          별도의 <a>그래프</a>를 생성한다.
        </dd>
        <dt>
          <dfn data-lt="presentation|presentations|프레젠테이션"
            >프레젠테이션(presentation)</dfn
          >
        </dt>
        <dd>
          하나 이상의 <a>발급자</a>가 발급한 하나 이상의
          <a>검증가능한 크리덴셜</a>에서 파생되어 특정 <a>검증자</a>와 공유되는
          데이터이다.
        </dd>
        <dt>
          <dfn
            data-lt="credential repository|credential repositories|repositories|리포지토리|크리덴셜 리포지토리"
            >리포지토리(repository)</dfn
          >
        </dt>
        <dd>
          저장소 금고나 개인 <a>검증가능한 크리덴셜</a> 지갑과 같이
          <a>보유자</a>의 <a>검증가능한 크리덴셜</a>에 대한 액세스를 저장하고
          보호하는 프로그램이다.
        </dd>
        <dt>
          <dfn data-lt="selective disclosure|선택적 공개"
            >선택적 공개(selective disclosure)</dfn
          >
        </dt>
        <dd>
          <a>보유자</a>가 공유할 정보에 대해 세부적인 결정을 내릴 수 있는
          능력이다.
        </dd>
        <dt><dfn data-lt="subjects|subject's|주체">주체(subject)</dfn></dt>
        <dd><a>클레임</a>의 대상이 되는 것이다.</dd>
        <dt>
          <dfn class="lint-ignore" data-lt="user agent|사용자 에이전트"
            >사용자 에이전트(user agent)</dfn
          >
        </dt>
        <dd>
          브라우저나 기타 웹 클라이언트와 같이 <a>보유자</a>, <a>발급자</a>,
          <a>검증자</a> 간의 통신을 중재하는 프로그램이다.
        </dd>
        <dt>
          <dfn data-lt="claim validation|유효성 검사"
            >유효성 검사(validation)</dfn
          >
        </dt>
        <dd>
          특정 <a>발급자</a>의 <a>클레임</a>이 특정 용도에 대한 <a>검증자</a>의
          비즈니스 요구사항을 충족한다는 보증이다. 이 규격은 검증자가
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>을 검증하는
          방법을 정의한다.<br />
          또한 <a>검증자</a>가 <a>검증가능한 크리덴셜</a>의 클레임을 신뢰하기
          전에 검증해야 함을 명시한다. 그러나 이러한 검증 수단은 매우 다양하며
          이 규격의 범위를 벗어난다. <a>검증자</a>는 특정 클레임에 대해 특정
          <a>발급자</a>를 신뢰하고, 어떤 <a>크리덴셜</a>의 어떤 클레임이 자신의
          시스템에서 사용하기에 적합한지 판단하기 위해 자체 규칙을 적용할 것으로
          예상된다.
        </dd>
        <dt>
          <dfn
            data-lt="verifiable credential|verifiable credentials|vc|vcs|검증가능한 크리덴셜"
            >검증가능한 크리덴셜(verifiable credential)</dfn
          >
        </dt>
        <dd>
          검증가능한 크리덴셜은 암호학적으로 검증할 수 있는 저작권이 있는 변조
          방지 크리덴셜이다. 검증가능한 크리덴셜은
          <a>검증가능한 프레젠테이션</a>을 구축하는 데 사용될 수 있으며, 이 역시
          암호학적으로 검증할 수 있다.
        </dd>
        <dt>
          <dfn data-lt="verifiable data registries|검증가능한 데이터 레지스트리"
            >검증가능한 데이터 레지스트리(verifiable data registry)</dfn
          >
        </dt>
        <dd>
          <a>검증가능한 크리덴셜</a>을 사용하는 데 필요할 수 있는 식별자, 키 및
          기타 관련 데이터 (예: <a>검증가능한 크리덴셜</a> 스키마, 폐기
          레지스트리, 발급자 공개 키 등)의 생성 및 <a>검증</a>을 중재함으로써
          시스템이 수행할 수 있는 역할이다. 일부 구성에서는 <a>주체</a>에 대해
          상관관계가 있는 식별자가 필요할 수 있다. UUID 및 공개 키용
          레지스트리와 같은 일부 레지스트리는 식별자에 대한 네임스페이스로만
          작동할 수 있다.
        </dd>
        <dt>
          <dfn
            data-lt="verifiable presentation|verifiable presentations|vp|vps|검증가능한 프레젠테이션"
            >검증가능한 프레젠테이션(verifiable presentation)</dfn
          >
        </dt>
        <dd>
          검증가능한 프레젠테이션은 암호화 검증 프로세스 후에 데이터의 저작권을
          신뢰할 수 있는 방식으로 인코딩된 변조 방지 프레젠테이션이다. 특정
          유형의 검증가능한 프레젠테이션에는 원본 <a>검증가능한 크리덴셜</a>에서
          합성되었지만 이를 포함하지 않는 데이터가 포함될 수 있다 (예: 영지식
          증명).
        </dd>
        <dt>
          <dfn
            data-lt="verify|verified|verifying|verifiable|verifiability|verification|검증|검증 가능"
            >검증(verification)</dfn
          >
        </dt>
        <dd>
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>이 각각
          발급자 또는 제시자의 진정하고 현재 유효한 진술인지 여부를 평가하는
          것이다. 여기에는 크리덴셜(또는 프레젠테이션)이 규격을 준수하는지, 증명
          방법이 충족되는지, 상태 확인이 성공하는지(있는 경우) 확인하는 작업이
          포함된다. 크리덴셜의 검증은 크리덴셜에 인코딩된 <a>클레임</a>의
          진실성에 대한 평가를 의미하지 않는다.
        </dd>
        <dt>
          <dfn
            data-lt="verifier|verifiers|verifier's|credential verifiers|credential verifier's|검증자"
            >검증자(verifier)</dfn
          >
        </dt>
        <dd>
          처리를 위해 <a>검증가능한 프레젠테이션</a> 내부에 선택적으로 하나
          이상의 <a>검증가능한 크리덴셜</a>을 수신하여 <a>엔티티</a>가 수행하는
          역할이다. 다른 규격에서는 이 개념을
          <dfn data-lt="relying parties|신뢰 당사자"
            >신뢰 당사자(relying party)</dfn
          >라고 한다.
        </dd>
        <dt>
          <dfn data-lt="verification material|검증 자료"
            >검증 자료(verification material)</dfn
          >
        </dt>
        <dd>
          증명을 검증하는 데 사용되는 암호화 공개 키 또는 기타 데이터일 수 있는
          정보이다.
        </dd>
        <dt><dfn data-lt="URL|URLs">URL</dfn></dt>
        <dd>
          [[URL]]에 정의된 대로 Uniform Resource Locator를 말한다. URL은
          역참조되어 문서와 같은 리소스를 생성할 수 있다. URL 역참조 또는
          가져오기 규칙은 URL [=url/scheme=]에 의해 정의된다. 이 규격에서는 웹
          개발자에게 혼란스러운 것으로 간주되어 URI 또는 IRI라는 용어를 사용하지
          않는다.
        </dd>
      </dl>
    </section>

    <section class="informative">
      <h2 id="core-data-model">핵심 데이터 모델</h2>

      <p>
        다음 섹션에서는 이 규격의 기반을 형성하는 [=클레임=], [=크리덴셜=],
        [=프레젠테이션=], [=검증가능한 크리덴셜=], [=검증가능한 프레젠테이션=]과
        같은 핵심 데이터 모델 개념에 대해 설명한다.
      </p>

      <p class="note" title="크리덴셜과 검증가능한 크리덴셜의 차이">
        독자는 이 섹션에서 설명하는 [=크리덴셜=]과 [=프레젠테이션=]과 같은 일부
        개념에는 이 규격에서 정의한 미디어 타입이 없다는 점에 주목할 수 있다.
        그러나 [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]의 개념은
        [=적합한 문서=]로 정의되며 관련 미디어 타입을 가지고 있다. 이러한 개념들
        사이의 구체적인 차이점 &mdash; [=크리덴셜=]과 [=프레젠테이션=] vs.
        [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=] &mdash; 은 단순히
        "검증가능한" 객체가 암호학적으로 검증할 수 있는 방식으로 보안되어 있고,
        다른 객체는 그렇지 않다는 사실이다. 자세한 내용은
        <a href="#securing-mechanisms"></a> 섹션을 참조하라.
      </p>

      <section class="informative">
        <h3>클레임</h3>

        <p>
          [=클레임=]은 [=주체=]에 대한 진술이다. [=주체=]는 [=클레임=]이
          만들어질 수 있는 대상이다. [=클레임=]은 <strong><em>주체</em></strong
          >-<dfn data-lt="property|properties">속성</dfn>-<dfn
            class="lint-ignore"
            >값</dfn
          >
          관계를 사용하여 표현된다.
        </p>

        <figure id="basic-structure">
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/claim.svg"
            alt="subject has a property which
            has a value"
          />
          <figcaption style="text-align: center">
            The basic structure of a claim.
          </figcaption>
        </figure>

        <p>
          위의 <a href="#basic-structure"></a>에 설명된 [=클레임=]의 데이터
          모델은 강력하며 다양한 진술을 표현하는 데 사용될 수 있다. 예를 들어,
          누군가가 특정 대학을 졸업했는지 여부는 아래
          <a href="#basic-example"></a>와 같이 표현될 수 있다.
        </p>

        <figure id="basic-example">
          <img
            style="margin: auto; display: block; width: 60%"
            src="diagrams/claim-example.svg"
            alt="Pat has an alumniOf
            property whose value is Example University"
          />
          <figcaption style="text-align: center">
            A basic claim expressing that Pat is an alumni of "Example
            University".
          </figcaption>
        </figure>

        <p>
          개별 [=클레임=]은 [=주체=]에 대한 정보의 [=그래프=]를 표현하기 위해
          결합될 수 있다. 아래 <a href="#multiple-claims"></a>에 표시된 예는
          Pat이 Sam을 알고 있으며 Sam이 교수로 고용되어 있다는 [=클레임=]을
          추가하여 이전 [=클레임=]을 확장한 것이다.
        </p>

        <figure id="multiple-claims">
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/claim-extended.svg"
            alt="extends previous
            diagram with another property called knows whose value is
            Sam, and Sam has a property jobTitle whose value is Professor"
          />
          <figcaption style="text-align: center">
            Multiple claims can be combined to express a graph of information.
          </figcaption>
        </figure>

        <p>
          이 시점에서 [=클레임=]과 정보의 [=그래프=] 개념이 소개되었다.
          [=클레임=]을 신뢰할 수 있으려면 그래프에 더 많은 정보가 추가될 것으로
          예상된다.
        </p>
      </section>

      <section class="informative">
        <h3>크리덴셜</h3>

        <p>
          [=크리덴셜=]은 동일한 [=엔티티=]에 의해 만들어진 하나 이상의
          [=클레임=] 집합이다. [=크리덴셜=]에는 [=발급자=], 유효 날짜 및 기간,
          대표 이미지, [=검증 자료=], 폐기 메커니즘 등과 같은 [=크리덴셜=]의
          속성을 설명하는 식별자와 메타데이터도 포함될 수 있다. 메타데이터에는
          [=발급자=]의 서명이 포함될 수 있다. [=검증가능한 크리덴셜=]은 변조
          방지 [=클레임=]과 메타데이터 집합으로, 누가 발급했는지를 암호학적으로
          증명한다.
        </p>

        <figure id="basic-vc">
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/vc.svg"
            alt="a Verifiable
               Credential contains Credential Metadata, Claim(s), and
               Proof(s)"
          />
          <figcaption style="text-align: center">
            Basic components of a verifiable credential.
          </figcaption>
        </figure>

        <p>
          [=검증가능한 크리덴셜=]의 예로는 디지털 직원 신분증, 디지털
          출생증명서, 디지털 교육 증명서 등이 있다.
        </p>
        <p class="note">
          [=크리덴셜=] 식별자는 종종 [=크리덴셜=]의 특정 인스턴스를 식별하는 데
          사용된다. 이러한 식별자는 상관관계에도 사용될 수 있다. 상관관계를
          최소화하려는 [=보유자=]는 [=크리덴셜=] 식별자를 공개하지 않는 선택적
          공개 체계를 사용하는 것이 좋다.
        </p>
        <p>
          위의 <a href="#basic-vc"></a>는 [=검증가능한 크리덴셜=]의 기본 구성
          요소를 보여주지만, [=클레임=]이 정보 [=그래프=]로 구성되는 방법과
          이러한 정보 [=그래프=]가 [=검증가능한 크리덴셜=]로 구성되는 방법에
          대한 세부 사항은 추상화한다.
        </p>
        <p>
          아래 <a href="#info-graph-vc"></a>는 [[?VC-DATA-INTEGRITY]]에 기반한
          [=내장된 증명=]을 사용하는 [=검증가능한 크리덴셜=]의 보다 완전한
          묘사를 보여준다. 이는 적어도 두 개의 정보 [=그래프=]로 구성된다. 첫
          번째 정보 [=그래프=]인 [=검증가능한 크리덴셜 그래프=]([=기본
          그래프=])는 [=크리덴셜=] 메타데이터와 기타 [=클레임=]을 통해
          [=검증가능한 크리덴셜=] 자체를 표현한다. `proof` 속성에 의해 참조되는
          두 번째 정보 [=그래프=]는 [=검증가능한 크리덴셜=]의
          <dfn data-lt="proof graph|증명 그래프">증명 그래프</dfn>이며, 별도의
          [=명명된 그래프=]이다. [=증명 그래프=]는 디지털 증명을 표현하며, 이
          경우에는 디지털 서명이다.
        </p>

        <figure id="info-graph-vc">
          <img
            style="margin: auto; display: block; width: 100%"
            src="diagrams/vc-graph.svg"
            alt="Diagram with a collections of
claims for a 'verifiable credential graph' on top
connected via a proof property (or predicate) to a 'verifiable credential proof
graph' on the bottom. The claims for a verifiable credential include 'Credential
123' as a subject with 4 properties: 'type' of value ExampleAlumniCredential,
'issuer' of Example University, 'validFrom' of 2010-01-01T19:23:24Z, and
credentialSubject of Pat, who also has an alumniOf property with value of
Example University.  The verifiable credential proof graph has an object
'Signature 456' subject with 5 properties: 'type' of DataIntegrityProof,
'verificationMethod' of Example University Public Key 7, 'created' of
2017-06-18T21:19:10Z, a 'nonce' of 34dj239dsj328, and 'proofValue' of
'zBavE110…3JT2pq'. The verifiable credential graph is also annotated with the
parenthetical remark '(the default graph)', the verifiable credential proof
graph is annotated with the parenthetical remark '(a named graph)'."
          />
          <figcaption style="text-align: center">
            Information graphs associated with a basic verifiable credential,
            using an [=embedded proof=] based on [[[VC-DATA-INTEGRITY]]]
            [[?VC-DATA-INTEGRITY]].
          </figcaption>
        </figure>

        <p>
          아래의 <a href="#info-graph-vc-jwt"></a>는
          <a href="#info-graph-vc"></a>와 동일한 [=검증가능한 크리덴셜=]을
          보여주지만, [[?VC-JOSE-COSE]]에 기반한 JOSE를 사용한다. 페이로드는
          [=크리덴셜=] 메타데이터와 기타 [=클레임=]을 포함하는 [=검증가능한
          크리덴셜 그래프=]인 단일 정보 그래프를 포함한다.
        </p>

        <figure id="info-graph-vc-jwt">
          <img
            style="margin: auto; display: block; width: 100%"
            src="diagrams/vc-jwt.svg"
            alt="Diagram with, on the left, a box, labeled as
'SD-JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vc+ld+json+sd-jwt The 'Payload' label on the left side is connected,
with an arrow, to a separate rectangle, containing a single graph. The
rectangle has a label: 'verifiable credential graph (serialized in
JSON)' The claims in the graph include 'Credential 123' as a subject
with 4 properties: 'type' with value 'ExampleAlumniCredential',
'issuer' with value 'Example University', 'validFrom' with value
'2010-01-01T19:23:24Z', and 'credentialSubject' with value 'Pat', who
also has an 'alumniOf' property with value 'Example University'.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'DtEhU3ljbEg8L38VWAfUA...'.
          "
          />
          <figcaption style="text-align: center">
            Information graphs associated with a basic verifiable credential,
            using an [=enveloping proof=] based on [[[VC-JOSE-COSE]]]
            [[?VC-JOSE-COSE]].
          </figcaption>
        </figure>

        <p class="note">
          결혼 증명서와 같이 서로 관련이 없어도 되는 다른 [=주체=]에 대한 여러
          [=클레임=]을 포함하는 [=크리덴셜=]을 가질 수 있다.
        </p>
        <p class="note">
          [=크리덴셜=]이 발급된 [=엔티티=]에 대한 [=클레임=]을 전혀 포함하지
          않는 [=크리덴셜=]을 가질 수 있다. 예를 들어, 특정 개에 대한
          [=클레임=]만 포함하지만 개의 주인에게 발급되는 [=크리덴셜=]이 있다.
        </p>
      </section>

      <section class="informative">
        <h3>프레젠테이션</h3>
        <p>
          프라이버시 향상은 이 규격의 핵심 설계 기능이다. 따라서 이 기술을
          사용하는 [=엔티티=]가 특정 상황에 적합한 페르소나의 일부분만 표현할 수
          있는 것이 중요하다. 페르소나의 일부를 표현하는 것을 [=검증가능한
          프레젠테이션=]이라고 한다. 서로 다른 페르소나의 예로는 한 사람의
          직업상 페르소나, 온라인 게임 페르소나, 가족 페르소나 또는 익명
          페르소나 등이 있다.
        </p>

        <p>
          [=검증가능한 프레젠테이션=]은 [=보유자=]에 의해
          <dfn class="lint-ignore">생성</dfn>되며, 여러 [=검증가능한
          크리덴셜=]의 데이터를 표현할 수 있고, JSON-LD로 인코딩된 임의의 추가
          데이터를 포함할 수 있다. 이들은 [=클레임=]을 [=검증자=]에게 제시하는
          데 사용된다. [=검증가능한 크리덴셜=]을 직접 제시하는 것도 가능하다.
        </p>

        <p>
          [=프레젠테이션=]의 데이터는 종종 동일한 [=주체=]에 관한 것이지만, 여러
          [=발급자=]에 의해 발급되었을 수 있다. 이 정보의 집합은 일반적으로
          사람, 조직 또는 [=엔티티=]의 한 측면을 표현한다.
        </p>

        <figure id="basic-vp">
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/presentation.svg"
            alt="A Verifiable
            Presentation contains Presentation Metadata, Verifiable
            Credential(s), and Proof(s)"
          />
          <figcaption style="text-align: center">
            Basic components of a verifiable presentation.
          </figcaption>
        </figure>

        <p>
          <a href="#basic-vp"></a> above shows the components of a [=verifiable
          presentation=], but abstracts the details about how [=verifiable
          credentials=] are organized into information [=graphs=], which are
          then organized into [=verifiable presentations=].
        </p>
        <p id="info-graph-vp-explanation">
          <a href="#info-graph-vp"></a> below shows a more complete depiction of
          a [=verifiable presentation=] using an [=embedded proof=] based on
          [[?VC-DATA-INTEGRITY]]. It is composed of at least four information
          [=graphs=]. The first of these information [=graphs=], the
          [=verifiable presentation graph=] (which is the [=default graph=]),
          expresses the [=verifiable presentation=] itself through
          [=presentation=] metadata. The [=verifiable presentation=] refers, via
          the `verifiableCredential` property, to a [=verifiable credential=].
          This [=credential=] is a self-contained [=verifiable credential
          graph=] containing [=credential=] metadata and other [=claims=]. This
          [=credential=] refers to a [=verifiable credential=] [=proof graph=]
          via a `proof` property, expressing the proof (usually a digital
          signature) of the [=credential=]. This [=verifiable credential
          graph=], and its linked [=proof graph=], constitute the second and
          third information [=graphs=], respectively, and each is a separate
          [=named graph=]. The [=presentation=] also refers, via the `proof`
          property, to the [=presentation=]'s [=proof graph=], which is the
          fourth information [=graph=] (another [=named graph=]). This
          [=presentation=] [=proof graph=] represents the digital signature of
          the [=verifiable presentation graph=], the [=verifiable credential
          graph=], and the [=proof graph=] linked from the [=verifiable
          credential graph=].
        </p>

        <figure id="info-graph-vp">
          <img
            style="margin: auto; display: block; width: 100%"
            src="diagrams/vp-graph.svg"
            alt="Diagram with a
'verifiable presentation graph' on top connected via a 'proof' to
a 'verifiable presentation proof graph on the bottom.  The verifiable
presentation graph has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. The
graph is annotated with the parenthetical remark '(the default graph)'. This
graph is connected, through 'verifiableCredential', to the part of the figure
which is identical to Figure 6, except that the verifiable credential graph is
annotated to be a named graph instead of a default graph.
The verifiable presentation proof graph has an object with 'Signature 8910'
with 5 properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod' with value 'Example
Presenter Public Key 11'; 'created' with value '2018-01-15T12:43:56Z';
'nonce' with value 'd28348djsj3239'; and 'proofValue' with value
'zp2KaZ...8Fj3K='. This graph is annotated with the parenthetical remark '(a
named graph)'"
          />
          <figcaption style="text-align: center">
            Information [=graphs=] associated with a basic [=verifiable
            presentation=] that is using an [=embedded proof=] based on
            [[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]].
          </figcaption>
        </figure>

        <p>
          <a href="#info-graph-vp-jwt"></a> 아래는
          <a href="#info-graph-vp"></a>와 동일한 [=검증가능한 프레젠테이션=]을
          보여주지만, [[?VC-JOSE-COSE]]에 기반한 [=봉인된 증명=]을 사용한다.
          페이로드는 두 개의 정보 그래프만 포함한다: 프레젠테이션 메타데이터를
          통해 [=검증가능한 프레젠테이션=] 자체를 표현하는 [=검증가능한
          프레젠테이션 그래프=]와 verifiableCredential 속성으로 참조되는 해당
          [=검증가능한 크리덴셜 그래프=]이다. [=검증가능한 크리덴셜 그래프=]는
          data: URL [[RFC2397]]을 통해 <a href="#info-graph-vc-jwt"></a>에
          표시된 [=봉인된 증명=]으로 보안된 검증가능한 크리덴셜을 참조하는 단일
          <a href="#defn-EnvelopedVerifiableCredential"
            >EnvelopedVerifiableCredential</a
          >
          인스턴스를 포함한다.
        </p>

        <figure id="info-graph-vp-jwt">
          <img
            style="margin: auto; display: block; width: 100%"
            src="diagrams/vp-jwt.svg"
            alt="Diagram with, on the left, a box, labeled as
'JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vp+ld+json+sd-jwt The 'Payload' label of the left side is connected,
with an arrow, to a separate rectangle, consisting of two related
graphs (stacked vertically) connected by a an arrow labeled
'verifiableCredential'. The two graphs have each a label 'verifiable
presentation graph (serialized in JSON)' and 'verifiable credential
graph (serialized in JSON)', respectively. The top graph in the
rectangle has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not
Archive'. The bottom graph includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'XaOOh4ljklxH7L99RTVSfOl...'.
          "
          />
          <figcaption style="text-align: center">
            Information graphs associated with a basic [=verifiable
            presentation=] that is using an [=enveloping proof=] based on JOSE
            [[?VC-JOSE-COSE]]. The `data:` URL refers to the [=verifiable
            credential=] shown on <a href="#info-graph-vc-jwt"></a>.
          </figcaption>
        </figure>

        <p class="note">
          대학 증명서 모음과 같이 종종 관련이 있지만 반드시 그럴 필요는 없는
          여러 [=주체=]에 대한 여러 [=크리덴셜=]을 사용하는 [=프레젠테이션=]을
          가질 수 있다. 이는 `verifiableCredential` 속성을 사용하여 여러
          [=검증가능한 크리덴셜=]을 참조함으로써 달성된다. 자세한 내용은 부록
          <a href="#additional-diagrams-for-verifiable-presentations"></a>을
          참조하라.
        </p>
      </section>

      <section class="informative">
        <h3>구체적인 라이프사이클 예시</h3>

        <p>
          이전 섹션에서는 그래픽 묘사를 사용하여 [=클레임=], [=검증가능한
          크리덴셜=], [=검증가능한 프레젠테이션=]의 개념을 소개했다. 이
          섹션에서는 이 규격에서 지원하는 구체적인 구문 중 하나로 표현된 데이터
          모델의 간단하지만 완전한 라이프사이클 예시를 제공한다.
          <a href="#ecosystem-overview">검증가능한 크리덴셜 생태계</a>에서
          [=크리덴셜=]과 [=프레젠테이션=]의 라이프사이클은 일반적으로 다음과
          같은 공통 경로를 거친다:
        </p>

        <ol>
          <li>하나 이상의 [=검증가능한 크리덴셜=] 발급.</li>
          <li>
            [=검증가능한 크리덴셜=]을 (디지털 지갑과 같은) [=크리덴셜
            리포지토리=]에 저장.
          </li>
          <li>
            [=검증자=]를 위해 [=검증가능한 크리덴셜=]을 [=검증가능한
            프레젠테이션=]으로 구성.
          </li>
          <li>[=검증자=]에 의한 [=검증가능한 프레젠테이션=]의 [=검증=].</li>
          <li>
            [=검증자=]에 의한 [=검증가능한 프레젠테이션=]에 포함된 관련
            [=클레임=]의 [=유효성 검사=].
          </li>
        </ol>
        <p>
          이 라이프사이클을 설명하기 위해, 대학에서 동문 할인을 받는 예시를
          사용할 것이다. 아래 예시에서 Pat은 대학에서 동문 [=검증가능한
          크리덴셜=]을 받고, Pat은 [=검증가능한 크리덴셜=]을 디지털 지갑에
          저장한다.
        </p>

        <pre
          class="example nohighlight"
          title="A simple example of the contents of a verifiable credential"
        >
{
  <span class='comment'>// set the context, which establishes the special terms we will be using
  // such as 'issuer' and 'alumniOf'.</span>
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class='comment'>// specify the identifier for the credential</span>
  "id": "http://university.example/credentials/1872",
  <span class='comment'>// the credential types, which declare what data to expect in the credential</span>
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  <span class='comment'>// the entity that issued the credential</span>
  "issuer": "https://university.example/issuers/565049",
  <span class='comment'>// when the credential was issued</span>
  "validFrom": "2010-01-01T19:23:24Z",
  <span class='comment'>// claims about the subjects of the credential</span>
  "credentialSubject": {
    <span class='comment'>// identifier for the only subject of the credential</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// assertion about the only subject of the credential</span>
    "alumniOf": {
      <span class='comment'>// identifier for the university</span>
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      <span class='comment'>// name of the university</span>
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
          그런 다음 Pat은 동문 할인을 받으려고 시도한다. 티켓 판매 시스템인
          [=검증자=]는 "Example University"의 동문은 스포츠 이벤트 시즌 티켓
          구매 시 할인을 받을 수 있다고 명시한다. Pat은 모바일 기기를 사용하여
          시즌 티켓 구매 프로세스를 시작한다. 이 프로세스의 한 단계에서 동문
          [=검증가능한 크리덴셜=]을 요청하고, 이 요청은 Pat의 디지털 지갑으로
          전달된다. 디지털 지갑은 Pat에게 이전에 발급받은 [=검증가능한
          크리덴셜=]을 제공할지 묻는다. Pat은 동문 [=검증가능한 크리덴셜=]을
          선택하고, 이는 [=검증가능한 프레젠테이션=]으로 구성된다. [=검증가능한
          프레젠테이션=]은 [=검증자=]에게 전송되고 [=검증=]된다.
        </p>
        <p>
          일단 진본이며 현재 유효한 것으로 [=검증=]되면, 시즌 티켓 판매자는
          [=검증가능한 크리덴셜=]의 [=발급자=]가 동문 자격에 대한 클레임으로
          인정되는지 확인한다 &mdash; Example University에서 발급되었으므로
          인정된다 &mdash; 그리고 오늘 날짜가 `validFrom`과 `validUntil` 속성
          값으로 정의된 유효 기간 내에 있는지 확인한다. [=보유자=]가
          [=검증가능한 크리덴셜=]의 [=주체=]일 것으로 예상되므로, [=검증자=]는
          동문 클레임의 `id`가 [=검증가능한 프레젠테이션=] 생성자의 `id`와
          일치하는지도 확인한다.
        </p>
        <p>
          크리덴셜과 프레젠테이션을 [=검증=]하고 관련 클레임의 유효성을 검사한
          후, 티켓 판매자는 Pat이 합법적으로 동문 할인을 받을 자격이 있다는
          확신을 가지고 Pat에게 안전하게 동문 할인을 제공한다.
        </p>
        <pre
          class="example nohighlight"
          title="A simple example of a verifiable presentation"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// the verifiable credential issued in the previous example</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/1872",
    "type": ["VerifiableCredential", "ExampleAlumniCredential"],
    "issuer": "https://university.example/issuers/565049",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": "Example University"
      }
    }
  }]
}
        </pre>

        <p class="note">
          위의 예시들은 보안이 적용되지 않았다. [=검증가능한 크리덴셜=]의 보안에
          대해 더 알고 싶은 구현자는 [[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]와
          [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]] 규격 및 [[[VC-SPECS]]]
          [[VC-SPECS]]의 "증명" 섹션을 참조할 수 있다.
        </p>
      </section>
    </section>

    <section class="normative">
      <h2 id="basic-concepts">기본 개념</h2>

      <p>
        이 섹션에서는 문서 뒷부분의 <a href="#advanced-concepts"></a> 섹션을
        준비하기 위해 이 규격의 몇 가지 기본 개념을 소개한다.
      </p>

      <section class="informative">
        <h3 id="getting-started">시작하기</h3>
        <p>
          이 규격은 새로운 유형의 [=검증가능한 크리덴셜=] 프로토타이핑을
          용이하게 하기 위해 설계되었다. 개발자는 아래 템플릿을 복사하여
          일반적인 [=검증가능한 크리덴셜=] 도구에 붙여넣어 프로토타입 크리덴셜을
          발급, 보유 및 검증할 수 있다.
        </p>

        <p>
          개발자는 아래 `MyPrototypeCredential`을 만들고자 하는 크리덴셜
          유형으로 변경할 것으로 예상된다. [=검증가능한 크리덴셜=]은 주체에 대해
          이야기하므로, `credentialSubject` 객체의 각 속성-값 쌍은 크리덴셜
          주체의 특정 속성을 표현한다. 개발자가 이러한 속성-값 조합을 여러 개
          추가하면, 수정된 객체를 [=검증가능한 크리덴셜=] 발급자 소프트웨어로
          보내고 개발자를 위한 [=검증가능한 크리덴셜=]이 생성될 것이다.
          프로토타이핑 관점에서 개발자가 해야 할 일은 그것뿐이다.
        </p>

        <pre
          class="example nohighlight"
          title="A template for creating prototype verifiable credentials"
        >
{
  "@context": ["https://www.w3.org/ns/credentials/v2"],
  "type": ["VerifiableCredential", "MyPrototypeCredential"],
  "credentialSubject": {
    "mySubjectProperty": "mySubjectValue"
  }
}
        </pre>

        <p>
          개발자가 크리덴셜의 모든 속성이 안정적이라고 생각할 정도로
          프로토타입을 만들었다면, 애플리케이션을 위한 어휘와 컨텍스트 파일을
          생성하고 안정적인 URL에 게시하여 다른 개발자가 동일한 어휘와
          컨텍스트를 사용하여 상호운용성을 달성할 수 있도록 하는 것이 좋다. 이
          프로세스는 <a href="#extensibility"></a> 섹션에서 다룬다. 또는
          개발자는 자신의 사용 사례에 맞는 기존 어휘 및 컨텍스트 파일을 재사용할
          수 있다. 재사용 가능한 리소스는 [[[VC-SPECS]]] [[VC-SPECS]]에서 찾아볼
          수 있다.
        </p>
      </section>

      <section>
        <h3 id="contexts">컨텍스트(Context)</h3>

        <p>
          두 소프트웨어 시스템이 데이터를 교환해야 할 때, 두 시스템이 모두
          이해하는 용어를 사용해야 한다. 비유하자면, 두 사람이 어떻게
          의사소통하는지 생각해보자. 두 사람은 동일한 언어를 사용해야 하고
          사용하는 단어는 서로에게 동일한 의미를 가져야 한다. 이를
          <em>대화의 맥락</em>이라고 부를 수 있다.
        </p>
        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]에는 [=URL=]
          [[URL]]로 식별되는 많은 속성과 값이 있다. 그러나 이러한 [=URL=]은 길고
          사람이 친숙하지 않을 수 있다. 이런 경우 짧은 형식의 사람에게 친숙한
          별칭이 더 도움이 될 수 있다. 이 규격은 `@context` [=속성=]을 사용하여
          이러한 짧은 형식의 별칭을 특정 [=검증가능한 크리덴셜=]과 [=검증가능한
          프레젠테이션=]에 필요한 [=URL=]에 매핑한다.
        </p>
        <p class="note">
          JSON-LD에서 `@context` [=속성=]은 데이터 타입 정보, 언어 정보, 변환
          규칙 등 이 규격의 요구사항을 넘어서지만 향후 또는 관련 작업에 유용할
          수 있는 다른 세부사항을 전달하는 데에도 사용될 수 있다. 자세한 내용은
          [[[JSON-LD11]]] [[JSON-LD11]] 규격의
          <a href="https://www.w3.org/TR/json-ld11/#the-context"
            >Section 3.1: 컨텍스트</a
          >를 참조하라.
        </p>
        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]은 반드시
          `@context` [=속성=]을 포함해야 한다.
        </p>

        <dl>
          <dt><dfn class="export">@context</dfn></dt>
          <dd>
            `@context` [=속성=]의 값은 반드시 정렬된 집합이어야 하며, 첫 번째
            항목은 값이 `https://www.w3.org/ns/credentials/v2`인 [=URL=]이어야
            한다. 참고로, 기본 컨텍스트의 사본은 부록
            <a href="#base-context"></a>에 제공된다. 배열의 후속 항목은 반드시
            [=URL=] 및/또는 객체의 조합으로 구성되어야 하며, 각각은
            <a data-cite="JSON-LD11#the-context">JSON-LD 컨텍스트</a>로 처리할
            수 있어야 한다.
          </dd>
        </dl>
        <p class="note">
          이 규격은 `@context` [=속성=]이 존재할 것을 요구한다. 이 속성은
          [[JSON-LD11]]에 의해 정의된다.
        </p>
        <pre class="example nohighlight" title="Usage of the @context property">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ]</span>,
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
          위의 예시는 대화가 [=검증가능한 크리덴셜=]에 관한 것임을 나타내기 위해
          기본 컨텍스트 [=URL=](`https://www.w3.org/ns/credentials/v2`)을
          사용한다. 두 번째
          [=URL=](`https://www.w3.org/ns/credentials/examples/v2`)은 대화가
          예시에 관한 것임을 나타낸다.
        </p>

        <p class="note">
          이 문서는 예시를 보여주기 위해 예시 컨텍스트
          [=URL=](`https://www.w3.org/ns/credentials/examples/v2`)을 사용한다.
          구현에서는 이 [=URL=]을 파일럿 또는 프로덕션 시스템과 같은 다른
          목적으로 사용하지 않을 것으로 예상된다.
        </p>

        <p>
          `https://www.w3.org/ns/credentials/v2`에서 사용 가능한 데이터는 절대
          업데이트되지 않는 정적 문서이며, 다운로드하여 캐시해야 한다.
          검증가능한 크리덴셜 데이터 모델과 관련된 사람이 읽을 수 있는 어휘
          문서는
          <a href="https://www.w3.org/2018/credentials/"
            >https://www.w3.org/2018/credentials/</a
          >에서 확인할 수 있다. 이 개념은 <a href="#extensibility"></a> 섹션에서
          더 자세히 설명된다.
        </p>
      </section>

      <section>
        <h3>식별자(Identifiers)</h3>

        <p>
          사람, 제품 또는 조직과 같은 특정 사물에 대한 진술을 표현할 때, 해당
          사물에 대해 전역적으로 고유한 식별자를 사용하는 것이 유용할 수 있다.
          전역적으로 고유한 식별자를 사용하면 다른 사람이 동일한 사물에 대한
          진술을 표현할 수 있다. 이 규격은 그러한 식별자를 위해 선택적인 `id`
          [=속성=]을 정의한다. `id` [=속성=]은 [=검증가능한 크리덴셜=]에서 특정
          사물에 대한 진술을 표현할 수 있게 하며, [=검증가능한 크리덴셜=]에서
          객체를 표현할 때는 [=발급자=]가, [=검증가능한 프레젠테이션=]에서
          객체를 표현할 때는 [=보유자=]가 설정한다. `id` 값의 예로는
          UUID(`urn:uuid:0c07c1ce-57cb-41af-bef2-1b932b986873`), HTTP
          URL(`https://id.example/things#123`), DID(`did:example:1234abcd`) 등이
          있다.
        </p>

        <p><em>만약</em> `id` [=속성=]이 존재한다면:</p>
        <ul>
          <li>
            `id` [=속성=]은 반드시 다른 사람이 해당 식별자로 식별되는 특정
            사물에 대한 진술을 표현할 때 사용할 것으로 예상되는 식별자를
            표현해야 한다.
          </li>
          <li>`id` [=속성=]은 반드시 하나 이상의 값을 가져서는 안 된다.</li>
          <li>
            `id` [=속성=]의 값은 반드시 역참조할 수 있는 [=URL=]이어야 한다.
          </li>
        </ul>

        <p class="note">
          개발자는 가명성이 필요한 시나리오에서 식별자가 유해할 수 있음을
          기억해야 한다. 개발자는 그러한 시나리오를 고려할 때
          <a href="#identifier-based-correlation"></a> 섹션을 주의 깊게 읽을
          것을 권장한다. <a href="#privacy-considerations"></a> 섹션에 문서화된
          다른 유형의 상관관계 메커니즘도 프라이버시 문제를 일으킨다.
          프라이버시가 중요한 고려사항인 경우 `id` [=속성=]은 생략될 수 있다.
          일부 사용 사례에서는 `id` [=속성=]이 필요하지 않거나 명시적으로 생략을
          요구한다.
        </p>
        <dl>
          <dt><dfn class="export">id</dfn></dt>
          <dd>
            `id` [=속성=]의 값은 반드시 단일 [=URL=]이어야 한다. `id`의
            [=URL=]을 역참조하면 `id`에 대한 기계 판독 가능한 정보가 포함된
            문서가 반환되는 것이 권장된다.
          </dd>
        </dl>

        <pre
          class="example nohighlight vc"
          title="Usage of the id property"
          data-vc-vm="https://university.example/issuers/565049#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class="highlight">"id": "http://university.example/credentials/3732"</span>,
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          위의 예시는 두 가지 유형의 식별자를 사용한다. 첫 번째 식별자는
          [=검증가능한 크리덴셜=]을 위한 것이며 HTTP 기반 URL을 사용한다. 두
          번째 식별자는 [=검증가능한 크리덴셜=]의 [=주체=]([=클레임=]이 관련된
          사물)를 위한 것이며 [=DID=]라고도 하는 [=탈중앙 식별자=]를 사용한다.
        </p>

        <p class="note">
          이 출판물 기준으로, [=DID=]는 [=검증가능한 크리덴셜=]이 유용하기 위해
          필요하지 않은 새로운 유형의 식별자이다. 구체적으로, [=검증가능한
          크리덴셜=]은 [=DID=]에 의존하지 않으며 [=DID=]는 [=검증가능한
          크리덴셜=]에 의존하지 않는다. 그러나 많은 [=검증가능한 크리덴셜=]이
          [=DID=]를 사용할 것으로 예상되며, 이 규격을 구현하는 소프트웨어
          라이브러리는 [=DID=]를 해석할 필요가 있을 것이다. [=DID=] 기반 URL은
          [=주체=], [=발급자=], [=보유자=], 크리덴셜 상태 목록, 암호화 키 및
          [=검증가능한 크리덴셜=]과 관련된 기타 기계 판독 가능한 정보와 관련된
          식별자를 표현하는 데 사용된다.
        </p>
      </section>

      <section>
        <h3>타입(Types)</h3>

        <p>
          이 문서에 지정된 종류의 객체를 처리하는 소프트웨어 시스템은 제공된
          [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]이 의도된 사용
          사례에 적합한지 여부를 결정하기 위해 타입 정보를 사용한다. 이 규격은
          타입 정보 표현을 위한 `type` [=속성=]을 정의한다. 이 타입 정보는 부록
          <a href="#validation"></a>에 설명된 대로 [=유효성 검사=] 프로세스 중에
          사용될 수 있다.
        </p>
        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]은 반드시 `type`
          [=속성=]을 가져야 한다. 즉, `type` [=속성=]이 없는 [=크리덴셜=] 또는
          [=프레젠테이션=]은 <em>[=검증 가능=]하지 않으므로</em> [=검증가능한
          크리덴셜=]도 [=검증가능한 프레젠테이션=]도 아니다.
        </p>
        <dl>
          <dt><dfn class="export" data-lt="type|types|타입">type</dfn></dt>
          <dd>
            `type` [=속성=]의 값은 반드시 하나 이상의 [=URL=]이거나 (`@context`
            속성의 해석을 통해) 하나 이상의 [=URL=]에 매핑되어야 한다. 둘 이상의
            [=URL=]이 제공되는 경우, [=URL=]은 순서가 없는 집합으로 해석되어야
            한다. 개발자 사용을 용이하게 하기 위해 구문적 편의성이 사용되어야
            한다. 이러한 편의성에는 JSON-LD 용어가 포함될 수 있다. `type`의 각
            [=URL=]은 역참조될 경우 `type`에 대한 기계 판독 가능한 정보가 포함된
            문서를 반환하는 것이 좋다(RECOMMENDED).
          </dd>
        </dl>

        <pre
          class="example nohighlight vc"
          title="Usage of the type property"
          data-vc-vm="https://university.example/issuers/565049#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "ExampleDegreeCredential"]</span>,
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          With respect to this specification, the following table lists the
          objects that MUST have a [=type=] specified.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>Object</th>
              <th>Type</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>[=Verifiable credential=]&nbsp;object</td>
              <td>
                `VerifiableCredential`과 선택적으로 더 구체적인 [=검증가능한
                크리덴셜=] [=타입=]. 예를 들어,<br />
                `"type": ["VerifiableCredential", "ExampleDegreeCredential"]`
              </td>
            </tr>
            <tr>
              <td>[=Verifiable presentation=]&nbsp;object</td>
              <td>
                `VerifiablePresentation`과 선택적으로 더 구체적인 [=검증가능한
                프레젠테이션=] [=타입=]. 예를 들어,<br />
                `"type": ["VerifiablePresentation", "ExamplePresentation"]`
              </td>
            </tr>
            <tr>
              <td><a href="#status">credentialStatus</a>&nbsp;object</td>
              <td>
                유효한 [=크리덴셜=] 상태 [=타입=]. 예를 들어,<br />
                `"type": "BitstringStatusListEntry"`
              </td>
            </tr>
            <tr>
              <td><a href="#terms-of-use">termsOfUse</a>&nbsp;object</td>
              <td>
                유효한 사용 약관 [=타입=]. 예를 들어,<br />
                `"type": "ExampleTermsPolicy"`
              </td>
            </tr>
            <tr>
              <td><a href="#evidence">evidence</a>&nbsp;object</td>
              <td>
                유효한 evidence [=타입=]. 예를 들어,<br />
                `"type": "ExampleEvidence"`
              </td>
            </tr>
          </tbody>
        </table>

        <p class="note">
          검증가능한 크리덴셜 데이터 모델의 [=타입=] 시스템은 [[JSON-LD11]]과
          동일하며
          <a href="https://www.w3.org/TR/json-ld/#specifying-the-type"
            >Section 3.5: 타입 지정</a
          >과
          <a href="https://www.w3.org/TR/json-ld/#json-ld-grammar"
            >Section 9: JSON-LD 문법</a
          >에 상세히 설명되어 있다. JSON-LD 컨텍스트(섹션
          <a href="#extensibility"></a> 참조)를 사용할 때, 이 규격은 JSON-LD
          문서를 보다 쉽게 이해할 수 있도록 `@type` 키워드를 `type`으로
          별칭한다. 애플리케이션 개발자와 문서 작성자는 JSON-LD 타입 시스템의
          세부 사항을 이해할 필요는 없지만, 상호운용 가능한 확장성을 지원하려는
          이 규격의 구현자는 이해해야 한다.
        </p>
        <p>
          모든 [=크리덴셜=], [=프레젠테이션=], 캡슐화된 객체는 추가적인 더
          제한적인 [=타입=](예: `ExampleDegreeCredential`)을 지정하거나
          연관시켜야 하므로 소프트웨어 시스템이 이 추가 정보를 더 쉽게 감지하고
          처리할 수 있다.
        </p>
        <p>
          이 규격에 정의된 캡슐화된 객체(예: `credentialSubject` 객체와
          연관되거나 그 안에 깊이 중첩된 객체)를 처리할 때, 소프트웨어 시스템은
          계층의 상위에 있는 캡슐화 객체에 지정된 [=타입=] 정보를 사용해야 한다.
          구체적으로, [=크리덴셜=]과 같은 캡슐화 객체는 연관된 객체 [=타입=]을
          전달하여 [=검증자=]가 캡슐화 객체 [=타입=]을 기반으로 연관된 객체의
          내용을 신속하게 파악할 수 있어야 한다.
        </p>
        <p>
          예를 들어, `ExampleDegreeCredential`의 `type`을 가진 [=크리덴셜=]
          객체는 `credentialSubject` 속성과 연관된 객체가 다음을 위한 식별자를
          포함하고 있음을 [=검증자=]에게 알린다:
        </p>
        <ul>
          <li>`id` 속성의 [=주체=].</li>
          <li>`type` 속성의 학위 유형.</li>
          <li>`name` 속성의 학위 제목.</li>
        </ul>
        <p>
          이를 통해 구현자는 [=검증=] 목적으로 `type` 속성과 관련된 값에 의존할
          수 있다. [=타입=]과 그와 관련된 속성에 대한 기대는 최소한 사람이 읽을
          수 있는 규격에 문서화되어야 하며, 가급적이면 추가적인 기계 판독 가능한
          표현으로 문서화되는 것이 좋다.
        </p>
        <p class="note">
          이 규격에 설명된 데이터 모델에 사용되는 타입 시스템은 데이터와 타입을
          연결하는 여러 가지 방법을 허용한다. 구현자와 작성자는 검증가능한
          크리덴셜 구현 지침 [[?VC-IMP-GUIDE]]의 타이핑 섹션을 읽어보는 것이
          좋다.
        </p>
      </section>

      <section>
        <h3>이름과 설명(Names and Descriptions)</h3>

        <p>
          [=크리덴셜=]을 표시할 때, [=발급자=]가 제공한 텍스트로 [=크리덴셜=]에
          이름과 그 목적에 대한 간단한 설명을 제공하는 것이 유용할 수 있다.
          `name`과 `description` [=속성=]은 이러한 목적을 위해 사용된다.
        </p>
        <dl>
          <dt><dfn class="export">name</dfn></dt>
          <dd>
            [=크리덴셜=]의 이름을 표현하는 선택적 속성이다. `name` [=속성=]이
            있는 경우, 그 값은 <a href="#language-and-base-direction"></a>에
            설명된 대로 문자열 또는 언어 값 객체이어야 한다. 이상적으로
            [=크리덴셜=]의 이름은 간결하고 사람이 읽을 수 있어야 하며, 개인이
            보유하고 있는 다른 [=크리덴셜=]과 빠르게 구별할 수 있어야 한다.
          </dd>
          <dt><dfn class="export">description</dfn></dt>
          <dd>
            [=크리덴셜=]에 대한 구체적인 세부 정보를 전달하는 선택적 속성이다.
            `description` [=속성=]이 있는 경우, 그 값은
            <a href="#language-and-base-direction"></a>에 설명된 대로 문자열
            또는 언어 값 객체이어야 한다. 이상적으로 [=크리덴셜=]의 설명은
            길이가 몇 문장을 넘지 않아야 하며, 개인이 [=클레임=] 전체를 살펴보지
            않고도 [=크리덴셜=]의 내용을 상기할 수 있을 정도의 충분한 정보를
            전달해야 한다.
          </dd>
        </dl>

        <pre
          class="example nohighlight vc"
          title="Usage of the name and description property"
          data-vc-vm="https://university.example/issuers/565049#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": "Example University",
    "description": "A public university focusing on teaching examples."
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": "Example University Degree",
  "description": "2015 Bachelor of Science and Arts Degree",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          이름과 설명은 또한 다른 언어로 내용을 표현하는 것을 지원한다. 언어 및
          [=기본 방향=] 정보가 포함된 문자열을 표현하기 위해, 텍스트 값, 언어
          태그, 기본 방향을 각각 표현하는 `@value`, `@language`, `@direction`
          속성을 포함하는 객체를 사용할 수 있다. 자세한 내용은
          <a href="#language-and-base-direction"></a>를 참조하라.
        </p>
        <p class="note">
          아래 예시의 `@direction` 속성은 관련된 단일 언어 문자열에 필요하지
          않은데, 이는 기본 방향이 속성에 설정된 방향과 동일하기 때문이다.
          여기서는 시연의 명확성을 위해, 그리고 복사+붙여넣기+편집이 기능적
          결과를 제공하도록 하기 위해 `@direction` 속성을 포함한다. 구현자는
          JSON-LD 1.1 규격 [[JSON-LD11]]의
          <a data-cite="JSON-LD11#string-internationalization"
            >JSON-LD 문자열 국제화</a
          >
          섹션을 읽어보는 것이 좋다.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the name and description property"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": [{
      "@value": "Example University",
      "@language": "en"
    }, {
      "@value": "Université Exemple",
      "@language": "fr"
    }, {
      "@value": "جامعة المثال",
      "@language": "ar",
      "@direction": "rtl"
    }],
    "description": [{
      "@value": "A public university focusing on teaching examples.",
      "@language": "en"
    }, {
      "@value": "Une université publique axée sur l'enseignement d'exemples.",
      "@language": "fr"
    }, {
      "@value": ".جامعة عامة تركز على أمثلة التدريس",
      "@language": "ar",
      "@direction": "rtl"
    }]
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": [{
    "@value": "Example University Degree",
    "@language": "en"
  }, {
    "@value": "Exemple de Diplôme Universitaire",
    "@language": "fr"
  }, {
    "@value": "مثال الشهادة الجامعية",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "description": [{
    "@value": "2015 Bachelor of Science and Arts Degree",
    "@language": "en"
  }, {
    "@value": "2015 Licence de Sciences et d'Arts",
    "@language": "fr"
  }, {
    "@value": "2015 بكالوريوس العلوم والآداب",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": [{
        "@value": "Bachelor of Science and Arts Degree",
        "@language": "en"
      }, {
        "@value": "Licence de Sciences et d'Arts",
        "@language": "fr"
      }, {
        "@value": "بكالوريوس العلوم والآداب",
        "@language": "ar",
        "@direction": "rtl"
      }]
    }
  }
}
        </pre>
      </section>

      <section>
        <h3>Credential Subject</h3>

        <p>
          [=검증가능한 크리덴셜=]은 하나 이상의 [=주체=]에 대한 [=클레임=]을
          포함한다. 이 규격은 하나 이상의 [=주체=]에 대한 [=클레임=] 표현을 위해
          `credentialSubject` [=속성=]을 정의한다.
        </p>
        <p>
          [=검증가능한 크리덴셜=]은 반드시 `credentialSubject` [=속성=]을 가져야
          한다.
        </p>
        <dl>
          <dt>
            <dfn class="export" id="defn-credentialSubject"
              >credentialSubject</dfn
            >
          </dt>
          <dd>
            `credentialSubject` [=속성=]의 값은 각 객체가 반드시 하나 이상의
            [=클레임=]의 [=주체=]여야 하는 객체 집합으로 정의되며, 이는 반드시
            `credentialSubject` [=속성=] 내부에 직렬화되어야 한다. 각 객체는
            <a href="#identifiers"></a> 섹션에 설명된 대로 [=주체=]를 식별하기
            위해 `id`를 포함할 수도 있다.
          </dd>
        </dl>

        <pre
          class="example nohighlight vc"
          title="Usage of the credentialSubject property"
          data-vc-vm="https://university.example/issuers/565049#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          [=검증가능한 크리덴셜=]에서 여러 [=주체=]와 관련된 정보를 표현할 수
          있다. 아래 예시는 배우자 관계인 두 [=주체=]를 지정한다.
          `credentialSubject` 속성과 여러 [=주체=]를 연결하기 위해 배열 표기법을
          사용한 점에 주목하라.
        </p>

        <pre
          class="example nohighlight"
          title="Specifying multiple subjects in a verifiable credential"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.com/issuer/123",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "https://subject.example/subject/8675",
    "name": "Morgan Doe",
    "spouse": "https://subject.example/subject/7421"
  }]</span>
}
        </pre>
      </section>

      <section>
        <h3>Issuer</h3>

        <p>
          이 규격은 [=검증가능한 크리덴셜=]의 [=발급자=]를 표현하기 위한 속성을
          정의한다.
        </p>
        <p>[=검증가능한 크리덴셜=]은 반드시 `issuer` [=속성=]을 가져야 한다.</p>
        <dl>
          <dt><var id="defn-issuer">issuer</var></dt>
          <dd>
            `issuer` [=속성=]의 값은 반드시 [=URL=]이거나, 값이 [=URL=]인 `id`
            [=속성=]을 포함하는 객체여야 한다. 어느 경우든 발급자는 이 [=URL=]을
            선택하여 자신을 전역적으로 명확하게 식별한다. 이 [=URL=]은 역참조될
            경우 [[VC-DATA-INTEGRITY]] 또는 [[VC-JOSE-COSE]]에 정의된 대로
            [=발급자=]에 대한 제어 문서를 반환하여 [=크리덴셜=]에 표현된 정보를
            [=검증=]하는 데 사용할 수 있는 것이 좋다(RECOMMENDED).
          </dd>
        </dl>

        <pre
          class="example nohighlight vc"
          title="Usage of issuer property"
          data-vc-vm="https://university.example/issuers/14#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": "https://university.example/issuers/14"</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          또한 발급자 속성과 객체를 연결하여 발급자에 대한 추가 정보를 표현할 수
          있다:
        </p>

        <pre
          class="example nohighlight vc"
          title="Usage of issuer expanded property"
          data-vc-vm="did:example:76e12ec712ebc6f1c221ebfeb1f#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p class="note">
          `issuer` [=속성=]의 값은 JWK(예: `"https://example.com/keys/foo.jwk"`)
          또는 [=DID=](예: `"did:example:abfe13f712120431c276e12ecab"`)일 수도
          있다.
        </p>
      </section>

      <section>
        <h3>Validity Period</h3>

        <p>
          이 규격은 [=크리덴셜=]이 유효해지는 날짜와 시간을 발급자가 표현할 수
          있도록 `validFrom` [=속성=]을 정의하고, [=크리덴셜=]이 더 이상
          유효하지 않게 되는 날짜와 시간을 표현하기 위해 `validUntil` [=속성=]을
          정의한다.
        </p>
        <p>
          날짜와 시간을 비교할 때, 계산은 "시간적으로" 수행되는데, 이는 문자열
          값이 타임라인 상의 한 지점으로 존재하는 "시간적 값"으로 변환됨을
          의미한다. 그런 다음 비교되는 날짜와 시간이 타임라인의 특정 지점과
          관련하여 어디에 있는지 확인하여 시간적 비교가 수행된다.
        </p>

        <dl>
          <dt><var id="defn-validFrom">validFrom</var></dt>
          <dd>
            `validFrom` [=속성=]이 있는 경우, 그 값은 반드시 [=크리덴셜=]이
            유효해지는 날짜와 시간을 나타내는 [<a
              data-cite="XMLSCHEMA11-2#dateTime"
              >XMLSCHEMA11-2</a
            >] `dateTimeStamp` 문자열 값이어야 하며, 이는 미래 또는 과거의
            날짜와 시간일 수 있다. 이 값은 `credentialSubject` [=속성=]과 관련된
            정보가 유효해지는 가장 빠른 시점을 나타낸다는 점에 유의하시오.
            `validUntil` 값도 존재하는 경우, `validFrom` 값은 반드시
            `validUntil` 값으로 표현된 날짜시간과 시간적으로 동일하거나 그보다
            이른 날짜시간을 표현해야 한다.
          </dd>
          <dt><var id="defn-validUntil">validUntil</var></dt>
          <dd>
            `validUntil` [=속성=]이 있는 경우, 그 값은 반드시 [=크리덴셜=]이
            유효하지 않게 되는 날짜와 시간을 나타내는 [<a
              data-cite="XMLSCHEMA11-2#dateTimeStamp"
              >XMLSCHEMA11-2</a
            >] `dateTimeStamp` 문자열 값이어야 하며, 이는 과거 또는 미래의
            날짜와 시간일 수 있다. 이 값은 `credentialSubject` [=속성=]과 관련된
            정보가 유효한 가장 늦은 시점을 나타낸다는 점에 유의하시오.
            `validFrom` 값도 존재하는 경우, `validUntil` 값은 반드시 `validFrom`
            값으로 표현된 날짜시간과 시간적으로 동일하거나 그보다 늦은
            날짜시간을 표현해야 한다.
          </dd>
        </dl>

        <pre
          class="example nohighlight vc"
          title="Usage of validFrom and validUntil property"
          data-vc-vm="https://university.example/issuers/14#key-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  <span class="highlight">"validFrom": "2010-01-01T19:23:24Z"</span>,
  <span class="highlight">"validUntil": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p class="note">
          만약 `validFrom`과 `validUntil`이 존재하지 않는다면, [=검증가능한
          크리덴셜=]의 유효 기간은 무기한으로 간주된다. 이러한 경우,
          [=검증가능한 크리덴셜=]은 `verifiable credential`이 생성된 시점부터
          유효한 것으로 가정한다.
        </p>

        <h4>시간 표현(Representing Time)</h4>

        <p>
          구현자는 시간 값을 표현하고 처리하는 것이 보이는 것만큼 단순하지
          않으며, 즉시 명확하지 않고 세계 다른 지역에서 일관되게 관찰되지 않는
          다양한 특이점이 있다는 점을 이해해야 한다. 예를 들면:
        </p>
        <ul>
          <li>
            그레고리력 이외의 달력 체계가 다양한 지역에서 적극적으로 사용되고
            있다.
          </li>
          <li>
            일광 절약/하절기 시간을 처리할 때, 1) 모든 지역에서 준수되는 것은
            아니고, 2) 반드시 같은 날 또는 같은 시간에 시작되거나 종료되는 것은
            아니며, 3) 조정의 양 또는 방향이 항상 다른 유사한 지역과 일치하는
            것은 아니라는 점을 이해하는 것이 중요하다.
          </li>
          <li>
            윤초는 특히 윤초 도입 이전의 날짜와 시간에 대해 모든 소프트웨어
            시스템에서 고려되지 않을 수 있다. 윤초는 에포크로부터의 정확한
            밀리초 오프셋에 의존하는 고도로 민감한 시스템에 영향을 줄 수 있다.
            그러나 대부분의 애플리케이션의 경우 영향을 받는 유일한 시간은 윤초
            자체의 1초 기간이라는 점에 유의하시오. 즉, 가장 최근의 윤초 이후의
            순간은 해당 시스템이 윤초를 이해하는지 여부에 관계없이 항상 다음
            날의 첫 번째 순간(예: `2023-01-01T00:00:00Z`)으로 표현될 수 있다.
          </li>
        </ul>

        <p>
          이것은 벽에 걸린 시계에서 볼 수 있는 실제 시간이 한 지역에는
          존재하지만 다른 지역에는 존재하지 않을 수 있음을 보여주는 몇 가지
          예시일 뿐이다. 이러한 이유로, 구현자는 일광 절약/하절기 시간의 영향을
          받는 값보다는 `Z` 시간대에 고정된 값과 같이 보다 보편적인 시간 값을
          사용하는 것이 좋다.
        </p>
        <p>
          이 규격은 [<a data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a
          >] 규격에서 처음 설정된 `dateTimeStamp` 구문을 활용하여 날짜와 시간의
          보편적으로 인식되는 조합의 수를 늘리고 시간 값의 잘못된 해석 가능성을
          줄이고자 한다. 서로 다른 시간대 간의 잘못된 해석을 줄이기 위해,
          [=적합한 문서=]에 표현된 모든 시간 값은 `dateTimeStamp` 형식으로
          지정되어야 하며, 값의 끝에 `Z`로 표시된 협정 세계시(UTC) 또는 UTC를
          기준으로 한 시간대 오프셋으로 지정되어야 한다. 오프셋 없이 잘못
          직렬화된 시간 값은 반드시 UTC로 해석되어야 한다. UTC를 기준으로 한
          유효한 시간대 오프셋의 예로는 `Z`, `+01:00`, `-08:00`, `+14:00` 등이
          있다. 허용 가능한 모든 값에 대한 정규식은 이 섹션의 끝 부분을
          참조하라.
        </p>
        <p>
          시간대 정의는 때때로 관할 기관에 의해 변경된다. 새로운 [=검증가능한
          크리덴셜=]을 대체하거나 발급할 때, 구현자는 현지 시간대 규칙의
          변경으로 인해 예기치 않은 유효성 격차가 발생하지 않도록 해야 한다.
          예를 들어, UTC-8의 원시 오프셋을 가지고 2024년에 일광 절약 시간 준수를
          중단하기로 투표한 `America/Los_Angeles` 영역을 고려해보자. `validUtil`
          값이 `2024-07-12T12:00:00-07:00`인 주어진 [=검증가능한 크리덴셜=]은
          `validFrom` 값이 `2024-07-12T12:00:00-08:00`이 되도록 재발급될 수
          있는데, 이는 [=검증가능한 크리덴셜=]이 유효하지 않은 1시간의 간격을
          만들 것이다.
        </p>
        <p>
          `dateTimeStamp` 값의 유효성을 확인하려는 구현자는 아래에 제공된
          정규식을 사용할 수 있다. 이 정규식은 편의를 위해 [<a
            data-cite="XMLSCHEMA11-2#dateTimeStamp"
            >XMLSCHEMA11-2</a
          >] 규격에서 재생산되었다. 의심의 여지를 없애기 위해,
          [[XMLSCHEMA11-2]]의 정규식이 규범적 정의이다. 구현자는 아래 정규식을
          통과하는 모든 `dateTimeStamp` 값이 유효한 시간의 순간은 아니라는 점에
          유의해야 한다. 예를 들어, 아래 정규식은 모든 달에 31일을 허용하여
          윤년, 윤초, 그리고 존재하지 않는 장소의 일수까지 허용한다. 그렇다고
          해서, 현대 시스템 라이브러리에서 생성된 `dateTimeStamp` 값은 종종
          유효한 `dateTimeStamp` 값 생성에 있어 오류가 없다. 아래 표시된
          정규식(가독성을 위해 여기에 포함된 공백은 제외)은 현대 시스템에서
          라이브러리에서 생성된 날짜와 시간을 처리할 때 종종 적절하다.
        </p>

        <pre
          class="example nohighlight"
          title="Regular expression to detect a valid XML Schema 1.1: Part 2 dateTimeStamp"
        >
-?([1-9][0-9]{3,}|0[0-9]{3})
-(0[1-9]|1[0-2])
-(0[1-9]|[12][0-9]|3[01])
T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))
(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))
        </pre>
      </section>

      <section>
        <h3>보안 메커니즘(Securing Mechanisms)</h3>
        <p>
          이 규격은 두 가지 유형의 보안 메커니즘을 인식한다: 봉인된 증명을
          사용하는 것과 내장된 증명을 사용하는 것이다.
        </p>
        <p>
          <dfn class="export" data-lt="봉인된 증명|enveloping proof|봉인"
            >봉인된 증명</dfn
          >은 이 데이터 모델의 직렬화를 감싸는 것이다. 이러한 권장 봉인된 증명
          메커니즘 중 하나가 [[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]에 정의되어
          있다.
        </p>
        <p>
          <dfn class="export" data-lt="내장된 증명|embedded proof"
            >내장된 증명</dfn
          >은 증명이 데이터 모델의 직렬화에 포함되는 메커니즘이다. 이러한 권장
          내장된 증명 메커니즘 중 하나가 [[[VC-DATA-INTEGRITY]]]
          [[VC-DATA-INTEGRITY]]에 정의되어 있다.
        </p>
        <p>
          이 두 가지 유형의 보안 메커니즘은 상호 배타적이지 않다.
          <a href="#securing-mechanism-specifications"></a> 섹션의 규칙에 따라
          추가적인 보안 메커니즘 규격이 정의될 수도 있다.
        </p>

        <pre
          class="example nohighlight"
          title="A verifiable credential utilizing an embedded proof"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "did:example:6fb1f712ebe12c27cc26eebfe11",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "https://subject.example/subject/3921",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "created": "2021-11-13T18:19:39Z",
    "verificationMethod": "https://university.example/issuers/14#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z58DAdFfa9SkqZMVPxAQp...jQCrfFPP2oumHKtz"
  }</span>
}
        </pre>

        <pre
          class="example nohighlight"
          title="A verifiable credential that uses an enveloping proof in SD-JWT format"
        >
eyJhbGciOiJFUzM4NCIsImtpZCI6IkdOV2FBTDJQVlVVMkpJVDg5bTZxMGM3U3ZjNDBTLWJ2UjFTT0
Q3REZCb1UiLCJ0eXAiOiJ2YytsZCtqc29uK3NkLWp3dCIsImN0eSI6InZjK2xkK2pzb24ifQ
.
eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvdjIiLCJodHRwcz
ovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvZXhhbXBsZXMvdjIiXSwiaXNzdWVyIjoiaHR0cHM6
Ly91bml2ZXJzaXR5LmV4YW1wbGUvaXNzdWVycy81NjUwNDkiLCJ2YWxpZEZyb20iOiIyMDEwLTAxLT
AxVDE5OjIzOjI0WiIsImNyZWRlbnRpYWxTY2hlbWEiOnsiX3NkIjpbIlNFOHp4bmduZTNNbWEwLUNm
S2dlYW1rNUVqU1NfOXRaNlN5NDdBdTdxRWMiLCJjT3lySEVrSlZwdEtSdURtNkNZVTREajJvRkExd0
JQRjFHcTJnWEo1NXpzIl19LCJjcmVkZW50aWFsU3ViamVjdCI6eyJkZWdyZWUiOnsibmFtZSI6IkJh
Y2hlbG9yIG9mIFNjaWVuY2UgYW5kIEFydHMiLCJfc2QiOlsibVNfSVBMa0JHcTIxbVA3Z0VRaHhOck
E0ZXNMc1ZKQ1E5QUpZNDFLLVRQSSJdfSwiX3NkIjpbIlhTSG9iU05Md01PVl9QNkhQMHNvMnZ1clNy
VXZ3UURYREJHQWtyTXk3TjgiXX0sIl9zZCI6WyJQNE5qWHFXa2JOc1NfRzdvdmlLdm1NOG0yckhDTm
5XVVV2SXZBbW9jb2RZIiwieFNvSHBKUXlCNGV1dmg4SkFJdDFCd1pjNFVEOHY5S3ZOTmVLMk9OSjFC
QSJdLCJfc2RfYWxnIjoic2hhLTI1NiIsImlzcyI6Imh0dHBzOi8vdW5pdmVyc2l0eS5leGFtcGxlL2
lzc3VlcnMvNTY1MDQ5IiwiaWF0IjoxNzAzNjI1OTAxLCJleHAiOjE3MzUyNDgzMDEsImNuZiI6eyJq
d2siOnsia3R5IjoiRUMiLCJjcnYiOiJQLTM4NCIsImFsZyI6IkVTMzg0IiwieCI6Inl1Zlo1SFUzcU
NfOTRMbkI3Zklzd0hmT0swQlJra0Z5bzVhd1QyX21ld0tJWUpLMVNfR0QySVB3UjRYUTZpdFEiLCJ5
IjoiRmEtV2pOd2NLQ1RWWHVDU2tCY3RkdHJOYzh6bXdBTTZWOWxudmxxd1QyQnRlQ0ZHNmR6ZDJoMF
VjeXluTDg0dCJ9fX0
.
M7BFJB9LEV_xEylSJpP00fd_4WjrOlXshh0dUv3QgOzw2MEGIfSfi9PoCkHJH7TI0InsqkD6XZVz38
MpeDKekgBW-RoDdJmxnifYOEJhKpJ5EN9PvA007UPi9QCaiEzX
~
WyJFX3F2V09NWVQ1Z3JNTkprOHNXN3BBIiwgImlkIiwgImh0dHA6Ly91bml2ZXJzaXR5LmV4YW1wbG
UvY3JlZGVudGlhbHMvMTg3MiJd
~
WyJTSEc4WnpfRDVRbFMwU0ZrZFUzNXlRIiwgInR5cGUiLCBbIlZlcmlmaWFibGVDcmVkZW50aWFsIi
wgIkV4YW1wbGVBbHVtbmlDcmVkZW50aWFsIl1d
~
WyJqZzJLRno5bTFVaGFiUGtIaHV4cXRRIiwgImlkIiwgImh0dHBzOi8vZXhhbXBsZS5vcmcvZXhhbX
BsZXMvZGVncmVlLmpzb24iXQ
~
WyItQmhzaE10UnlNNUVFbGt4WGVXVm5nIiwgInR5cGUiLCAiSnNvblNjaGVtYSJd~WyJ0SEFxMEUwN
nY2ckRuUlNtSjlSUWRBIiwgImlkIiwgImRpZDpleGFtcGxlOjEyMyJd
~
WyJ1Ynd6bi1kS19tMzRSMGI0SG84QTBBIiwgInR5cGUiLCAiQmFjaGVsb3JEZWdyZWUiXQ
        </pre>
      </section>

      <section>
        <h3>상태(Status)</h3>

        <p>
          이 규격은 [=검증가능한 크리덴셜=]의 상태와 관련된 정보(예: 정지 또는
          폐기 여부)를 발견하기 위한
          <strong id="defn-credentialStatus">credentialStatus</strong>
          [=속성=]을 정의한다.
        </p>
        <p>
          `credentialStatus` [=속성=]과 연관된 값이 있는 경우, 그 값은 단일 객체
          또는 하나 이상의 객체 집합이다. 모든 객체에 대해 다음과 같은
          [=속성=]이 정의된다:
        </p>
        <dl>
          <dt>id</dt>
          <dd>
            `id` [=속성=]은 선택 사항이다. 크리덴셜 상태 객체에 대한 고유
            식별자를 제공하는 데 사용될 수 있다. 존재하는 경우
            <a href="#identifiers"></a> 섹션의 규범적 지침을 반드시 따라야 한다.
          </dd>
          <dt>type</dt>
          <dd>
            `type` [=속성=]은 필수이다. 객체에 의해 표현되는 상태 정보의 유형을
            표현하는 데 사용된다. <a href="#types"></a> 섹션의 관련 규범적
            지침을 반드시 따라야 한다.
          </dd>
        </dl>
        <p>
          [=크리덴셜=] 상태 정보의 정확한 내용은 특정 `credentialStatus`
          [=타입=] 정의에 의해 결정되며, 구현이 간단한지 또는 프라이버시를
          강화하는지 여부 등의 요인에 따라 달라진다. 값이 [=크리덴셜=]의 현재
          상태를 결정하기에 충분한 정보를 제공하고 URL에서 기계 판독 가능한
          정보를 검색할 수 있을 것으로 예상된다. 예를 들어, 객체는
          [=크리덴셜=]이 정지되었는지 또는 폐기되었는지 여부를 기록하는 외부
          문서에 대한 링크를 포함할 수 있다.
        </p>

        <pre class="example nohighlight" title="Usage of the status property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://university.example/credentials/status/3#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://university.example/credentials/status/3"
  }</span>
}
        </pre>

        <p>
          [=크리덴셜=]은 폐기 또는 정지 여부와 같이 하나 이상의 상태와 연관될 수
          있다.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of multiple entries for the status property"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://license.example/credentials/9837",
  "type": ["VerifiableCredential", "ExampleDrivingLicenseCredential"],
  "issuer": "https://license.example/issuers/48",
  "validFrom": "2020-03-14T12:10:42Z",
  "credentialSubject": {
    "id": "did:example:f1c276e12ec21ebfeb1f712ebc6",
    "license": {
      "type": "ExampleDrivingLicense",
      "name": "License to Drive a Car"
    }
  },
  <span class="highlight">"credentialStatus": [{
    "id": "https://license.example/credentials/status/84#14278",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "14278",
    "statusListCredential": "https://license.example/credentials/status/84"
  }, {
    "id": "https://license.example/credentials/status/84#82938",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "suspension",
    "statusListIndex": "82938",
    "statusListCredential": "https://license.example/credentials/status/84"
  }]</span>
}
        </pre>

        <p>
          구현자는 여러 상태 항목이 있는 [=크리덴셜=]에 상충되는 정보가 포함될
          수 있음에 주의해야 한다. 이러한 상충을 조정하는 것은 [=검증=]
          프로세스의 일부이므로 검증자의 비즈니스 로직의 일부이며, 따라서 이
          규격의 범위를 벗어난다.
        </p>
        <p>
          상태 체계를 위한 데이터 모델, 형식 및 프로토콜 정의는 이 규격의 범위를
          벗어난다. 검증가능한 크리덴셜 사양 디렉토리 [[?VC-SPECS]]에는
          [=검증가능한 크리덴셜=] 상태 확인을 구현하려는 구현자를 위한 사용
          가능한 상태 체계가 포함되어 있다.
        </p>
        <p>상태 체계를 만드는 규격 작성자에게 다음 지침이 제공된다:</p>
        <ul>
          <li>
            상태 체계는 [=발급자=]가 [=검증자=]가 특정 [=보유자=] 또는
            [=주체=]에 관심이 있을 때 (직접 또는 간접적으로) 통지받는 등 개인을
            추적할 수 있는 방식으로 구현되어서는 안 된다(MUST NOT). 크리덴셜을
            사용할 때마다 특정 개인의 상태를 확인하기 위해 크리덴셜의
            [=발급자=]에게 연락하는 "폰 홈(phone home)" 방식이나, 크리덴셜을
            사용할 때마다 [=발급자=]에게 정보 요청을 하여 [=발급자=]가 특정
            개인에 대한 [=검증자=]의 관심을 유추할 수 있게 하는 "가명성
            감소(pseudonymity reduction)" 방식 등은 허용되지 않는 접근 방식에
            해당한다.
          </li>
        </ul>
      </section>

      <section>
        <h3>프레젠테이션(Presentations)</h3>

        <p>
          [=검증가능한 프레젠테이션=]은 여러 [=검증가능한 크리덴셜=]의 정보를
          집계하는 데 사용될 수 있다.
        </p>
        <p>
          [=검증가능한 프레젠테이션=]은 수명이 매우 짧아야 하며, [=검증자=]가
          제공한 챌린지에 바인딩되어야 한다. 이를 달성하기 위한 세부 사항은 보안
          메커니즘, 전송 프로토콜 및 [=검증자=] 정책에 따라 달라진다. 특정 보안
          메커니즘 또는 임베딩 프로토콜에 의해 추가 요구사항이 정의되지 않는 한,
          [=검증자=]는 일반적으로 [=검증가능한 프레젠테이션=]이 제시된
          [=검증가능한 크리덴셜=]과 어떤 상관관계가 있다고 가정할 수 없다.
        </p>
        <p>
          [=검증가능한 프레젠테이션=]의 [=기본 그래프=]는
          <dfn
            data-lt="verifiable presentation graph|검증가능한 프레젠테이션 그래프"
            >검증가능한 프레젠테이션 그래프</dfn
          >라고도 한다.
        </p>
        <p>다음은 [=검증가능한 프레젠테이션=]에 대해 정의된 속성이다:</p>
        <dl>
          <dt>|id|</dt>
          <dd>
            `id` [=속성=]은 선택 사항이다. [=검증가능한 프레젠테이션=]에 대한
            고유 식별자를 제공하는 데 사용될 수 있다. 존재하는 경우
            <a href="#identifiers"></a> 섹션의 규범적 지침을 반드시 따라야 한다.
          </dd>
          <dt>|type|</dt>
          <dd>
            `type` [=속성=]은 반드시 존재해야 한다. [=검증가능한
            프레젠테이션=]의 타입을 표현하는 데 사용된다. 이 속성의 한 값은
            반드시 `VerifiablePresentation`이어야 하지만, 추가 타입이 포함될 수
            있다. <a href="#types"></a> 섹션의 관련 규범적 지침을 반드시 따라야
            한다.
          </dd>
          <dt>
            <var id="defn-verifiableCredential">verifiableCredential</var>
          </dt>
          <dd>
            `verifiableCredential` [=속성=]은 존재할 수 있다. 그 값은 반드시
            하나 이상의 [=검증가능한 크리덴셜=] 및/또는
            <a href="#enveloped-verifiable-credentials"
              >봉인 검증가능한 크리덴셜</a
            >
            객체여야 한다 (명확히 하자면, 값은 숫자, 문자열 또는 URL과 같은
            비객체 값이 아니어야 한다(MUST NOT)). 이러한 유형의 객체를
            <a href="#verifiable-credential-graphs"
              >검증가능한 크리덴셜 그래프</a
            >라고 하며, 반드시
            <a href="#securing-mechanisms">보안 메커니즘</a>을 사용하여 보안되는
            정보를 표현해야 한다. 자세한 내용은
            <a href="#verifiable-credential-graphs"></a> 섹션을 참조하라.
          </dd>
          <dt><var id="defn-holder">holder</var></dt>
          <dd>
            [=검증가능한 프레젠테이션=]은 `holder` [=속성=]을 포함할 수 있다.
            존재하는 경우, 값은 반드시 [=URL=] 또는 `id` [=속성=]을 포함하는
            객체여야 한다. `holder` 또는 그 `id`의 [=URL=]은 역참조될 경우
            [=검증가능한 프레젠테이션=]에 표현된 정보를 [=검증=]하는 데 사용할
            수 있는 [=보유자=]에 대한 기계 판독 가능한 정보가 포함된 문서를
            반환하는 것이 좋다(RECOMMENDED). `holder` [=속성=]이 없는 경우,
            [=보유자=]에 대한 정보는 보안 메커니즘을 통해 얻거나 [=검증가능한
            프레젠테이션=]의 [=검증=]과 관련이 없을 것으로 예상된다.
          </dd>
        </dl>
        <p>아래 예시는 [=검증가능한 프레젠테이션=]을 보여준다:</p>

        <pre
          class="example nohighlight"
          title="Basic structure of a presentation"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }]
}</span>
        </pre>

        <p>
          위에 표시된 `verifiableCredential` [=속성=]의 내용은 이 규격에서
          설명하는
          <a href="#verifiable-credential-graphs">검증가능한 크리덴셜 그래프</a
          >이다.
        </p>

        <section>
          <h4>봉인된 검증가능한 크리덴셜(Enveloped Verifiable Credentials)</h4>

          <p>
            [=검증가능한 프레젠테이션=]에 [[[?VC-JOSE-COSE]]]
            [[?VC-JOSE-COSE]]와 같이 페이로드를 "봉인"하는 보안 메커니즘을
            사용하여 보안된 하나 이상의 [=검증가능한 크리덴셜=]을 포함하는 것이
            가능하다. 이는 `verifiableCredential` 속성을 `type`이
            `EnvelopedVerifiableCredential`인 객체와 연결하여 달성할 수 있다.
          </p>
          <dl>
            <dt id="defn-EnvelopedVerifiableCredential">
              EnvelopedVerifiableCredential
            </dt>
            <dd>
              [=검증가능한 프레젠테이션=]의 `verifiableCredential` 속성과 봉인
              [=검증가능한 크리덴셜=]을 포함하는 객체를 연결하는 데 사용된다.
              객체의 `@context` 속성은 반드시 존재해야 하며, 이 규격의
              <a href="#base-context">기본 컨텍스트</a>와 같이 이 규격에서
              제공하는 기본 컨텍스트에 의해 정의된 `id`, `type` 및
              `EnvelopedVerifiableCredential` 용어를 최소한 정의하는 컨텍스트를
              포함해야 한다. 객체의 `id` 값은 반드시 [[[VC-JOSE-COSE]]]
              [[VC-JOSE-COSE]]와 같은 [=봉인=] 보안 체계를 사용하여 보안된
              [=검증가능한 크리덴셜=]을 표현하는 `data:` URL [[RFC2397]]이어야
              한다. 객체의 `type` 값은 반드시
              `EnvelopedVerifiableCredential`이어야 한다.
            </dd>
          </dl>
          <p>
            아래 예시는 봉인된 [=검증가능한 크리덴셜=]을 포함하는 [=검증가능한
            프레젠테이션=]을 보여준다:
          </p>

          <pre
            class="example nohighlight"
            title="Basic structure of a presentation"
          >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "id": "data:application/vc+ld+json+sd-jwt;QzVjV...RMjU",
    "type": "EnvelopedVerifiableCredential"
  }]</span>
}
          </pre>

          <p class="note" title="RDF로 봉인화된 콘텐츠 처리하기">
            구현자가 이 섹션에 설명된 객체와 `id` 값으로 표현된 봉인된
            프레젠테이션을 RDF 환경에서 처리하고 RDF와 관련된 객체 간의 연결을
            생성하고 싶어할 수 있다. 이를 위한 요구와 메커니즘은 사용 사례에
            따라 달라지므로 구현에 따라 달라질 것이다.
          </p>
        </section>
        <section>
          <h4>
            봉인된 검증가능한 프레젠테이션(Enveloped Verifiable Presentations)
          </h4>
          <p>
            [[[?VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]와 같이 페이로드를 "봉인"하는
            메커니즘을 사용하여 보안된 [=검증가능한 프레젠테이션=]을 표현하는
            것이 가능하다. 이는 `type`이 `EnvelopedVerifiablePresentation`인
            객체를 사용하여 달성할 수 있다.
          </p>
          <dl>
            <dt id="defn-EnvelopedVerifiablePresentation">
              EnvelopedVerifiablePresentation
            </dt>
            <dd>
              봉인 [=검증가능한 프레젠테이션=]을 표현하는 데 사용된다. 객체의
              `@context` 속성은 반드시 존재해야 하며, 이 규격의
              <a href="#base-context">기본 컨텍스트</a>와 같이 이 규격에서
              제공하는 기본 컨텍스트에 의해 정의된 `id`, `type` 및
              `EnvelopedVerifiablePresentation` 용어를 최소한 정의하는
              컨텍스트를 포함해야 한다. 객체의 `id` 값은 반드시
              [[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]와 같은 [=봉인=] 보안
              메커니즘을 사용하여 보안된 [=검증가능한 프레젠테이션=]을 표현하는
              `data:` URL [[RFC2397]]이어야 한다. 객체의 `type` 값은 반드시
              `EnvelopedVerifiablePresentation`이어야 한다.
            </dd>
          </dl>
          <p>아래 예시는 봉인된 [=검증가능한 프레젠테이션=]을 보여준다:</p>

          <pre
            class="example nohighlight"
            title="Basic structure of an enveloped verifiable presentation"
          >
{
  "@context": "https://www.w3.org/ns/credentials/v2",
  <span class="highlight">"id": "data:application/vp+ld+json+jwt;eyJraWQiO...zhwGfQ",
  "type": "EnvelopedVerifiablePresentation"</span>
}
          </pre>
        </section>

        <section>
          <h4>
            파생 크리덴셜을 사용한 프레젠테이션(Presentations Using Derived
            Credentials)
          </h4>

          <p>
            일부 영지식 암호 체계는 [=보유자=]가 [=검증가능한 크리덴셜=]의 모든
            클레임을 공개하지 않고도 해당 [=검증가능한 크리덴셜=]에서
            [=클레임=]을 보유하고 있음을 간접적으로 증명할 수 있게 해준다.
            이러한 체계에서 [=검증가능한 크리덴셜=]은 [=검증자=]가 [=발급자=]를
            신뢰한다면 값을 신뢰할 수 있도록 암호학적으로 주장되는 프레젠테이션
            가능한 데이터를 파생시키는 데 사용될 수 있다.
          </p>
          <p>
            일부 선택적 공개 체계는 [=검증가능한 크리덴셜=]에서 파생된
            [=클레임=] 부분 집합을 공유할 수 있다.
          </p>
          <p class="note">
            직접 내장된 [=검증가능한 크리덴셜=] 대신 파생 데이터를 포함하는 ZKP
            스타일의 [=검증가능한 프레젠테이션=] 예시는
            <a href="#zero-knowledge-proofs"></a> 섹션을 참조하라.
          </p>

          <figure>
            <img
              style="margin: auto; display: block; width: 50%"
              src="diagrams/claim-example-2.svg"
              alt="Pat has a property
                 overAge whose value is 21"
            />
            <figcaption style="text-align: center">
              A basic claim expressing that Pat is over the age of 21.
            </figcaption>
          </figure>
        </section>
        <section>
          <h4>
            보유자 클레임을 포함하는 프레젠테이션(Presentations Including Holder
            Claims)
          </h4>
          <p>
            [=보유자=]는 [=검증가능한 프레젠테이션=]에서 `verifiableCredential`
            [=속성=]을 사용하여 자신을 포함한 모든 [=발급자=]의 [=검증가능한
            크리덴셜=]을 포함할 수 있다. [=검증가능한 크리덴셜=]의 [=발급자=]가
            [=보유자=]인 경우, 해당 [=검증가능한 크리덴셜=]의 [=클레임=]은
            <em>자가 증명된</em> 것으로 간주된다. 이러한 자가 증명된 클레임은
            그것이 포함된 [=검증가능한 프레젠테이션=]을 보호하는 동일한 메커니즘
            또는 다른 [=검증가능한 크리덴셜=]에 사용할 수 있는 모든 메커니즘에
            의해 보호될 수 있다.
          </p>
          <p>
            이러한 자가 증명된 [=클레임=]의 <a href="#dfn-subjects">주체</a>에는
            제한이 없으므로, 이 [=클레임=]은 [=보유자=], 포함된 다른
            [=검증가능한 크리덴셜=] 중 하나 또는 심지어 자가 증명된 [=검증가능한
            크리덴셜=]이 포함된 [=검증가능한 프레젠테이션=]에 대한 진술을 포함할
            수 있다. 각 경우에 `id` [=속성=]은 자가 증명되지 않은 [=검증가능한
            크리덴셜=]에서 수행되는 것처럼, [=클레임=]이 만들어진 객체의 특정
            [=주체=]를 식별하는 데 사용된다.
          </p>
          <p>
            [=검증가능한 프레젠테이션=]과 동일한 메커니즘만을 사용하여 보호되는
            자가 증명된 [=검증가능한 크리덴셜=]을 포함하는 [=검증가능한
            프레젠테이션=]은 반드시 `holder` [=속성=]을 포함해야 한다.
          </p>
          <p>
            [=검증가능한 크리덴셜=]에 대해 정의된 모든 규범적 요구사항은 자가
            증명된 [=검증가능한 크리덴셜=]에도 적용된다.
          </p>
          <p>
            자가 증명된 [=검증가능한 크리덴셜=]이 [=검증가능한 프레젠테이션=]과
            동일한 메커니즘을 사용하여 보호되는 경우, [=검증가능한 크리덴셜=]의
            `issuer` [=속성=] 값은 반드시 [=검증가능한 프레젠테이션=]의 `holder`
            [=속성=]과 동일해야 한다.
          </p>
          <p>
            아래 예시는 [=검증가능한 프레젠테이션=]과 동일한 메커니즘을 사용하여
            보호되는 자가 증명된 [=검증가능한 크리덴셜=]을 포함하는 [=검증가능한
            프레젠테이션=]을 보여준다.
          </p>

          <pre
            class="example nohighlight"
            title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential"
          >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleFoodPreferenceCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      "favoriteCheese": "Gouda"
    },
    { <span class="comment">...</span> }
  }],
  "proof": [{ <span class="comment">...</span> }]
}
          </pre>
          <p>
            아래 예시는 [=검증가능한 프레젠테이션=]에 대한 [=클레임=]을 포함하는
            자가 증명된 [=검증가능한 크리덴셜=]을 내장한 [=검증가능한
            프레젠테이션=]을 보여준다. 이는 [=검증가능한 프레젠테이션=]과 동일한
            메커니즘을 사용하여 보호된다.
          </p>

          <pre
            class="example nohighlight"
            title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential about the verifiable presentation"
          >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleAssertCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
      "assertion": "This VP is submitted by the subject as evidence of a legal right to drive"
    },
    "proof": { <span class="comment">...</span> }
  }],
  "proof": { <span class="comment">...</span> }
}
          </pre>
        </section>
      </section>

      <section>
        <h3>데이터 스키마(Data Schemas)</h3>

        <p>
          데이터 스키마는 특정 데이터 집합에 특정 구조를 적용할 때 유용하다. 이
          규격에서 고려하는 데이터 스키마의 유형은 최소한 두 가지이다:
        </p>
        <ul>
          <li>
            [=크리덴셜=] 또는 [=검증가능한 크리덴셜=]의 구조와 내용이 게시된
            스키마를 준수하는지 확인하는 데 사용되는 데이터 검증 스키마.
          </li>
          <li>
            [=검증가능한 크리덴셜=]의 내용을 영지식 증명에 사용되는 형식과 같은
            대체 표현 형식에 매핑하는 데 사용되는 데이터 인코딩 스키마.
          </li>
        </ul>
        <p>
          데이터 스키마가 `@context` 속성과는 다른 목적을 가지고 있다는 점을
          이해하는 것이 중요하다. `@context` 속성은 데이터 구조나 데이터 구문을
          강제하지 않으며, 대체 표현 형식으로의 임의 인코딩 정의를 가능하게
          하지도 않는다.
        </p>
        <p>
          이 규격은 [=발급자=]가 발행하는 [=검증가능한 크리덴셜=]에 포함할 수
          있는 데이터 스키마 표현을 위한 다음과 같은 [=속성=]을 정의한다:
        </p>
        <dl>
          <dt><var id="defn-credentialSchema">credentialSchema</var></dt>
          <dd>
            <p>
              `credentialSchema` [=속성=]의 값은 반드시 제공된 데이터가 제공된
              스키마에 부합하는지 결정하기 위해 [=검증자=]에게 충분한 정보를
              제공하는 하나 이상의 데이터 스키마여야 한다. 각
              `credentialSchema`는 반드시 그 `type`(예: `JsonSchema`)과 스키마
              파일을 식별하는 [=URL=]이어야 하는 `id` [=속성=]을 지정해야 한다.
              각 데이터 스키마의 정확한 내용은 특정 유형 정의에 의해 결정된다.
            </p>
            <p>
              여러 스키마가 존재하는 경우, 유효성은 각 관련 `credentialSchema`
              `type` 속성에 의해 명시된 처리 규칙에 따라 결정된다.
            </p>
          </dd>
        </dl>
        <p class="note">
          `credentialSchema` [=속성=]은 유형 정의에 주석을 달거나 어휘의 특정
          버전에 고정할 수 있는 기회를 제공한다. [=검증가능한 크리덴셜=]의
          작성자는 일부 콘텐츠 무결성 보호 메커니즘에 고정된
          `credentialSchema`를 사용하여 어휘의 정적 버전을 포함할 수 있다.
          `credentialSchema` [=속성=]은 또한 [=크리덴셜=]에 대한 구문 검사를
          수행하고 JSON 스키마 [[?VC-JSON-SCHEMA]] 유효성 검사와 같은 [=검증=]
          메커니즘을 사용할 수 있게 해준다.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the credentialSchema property to perform JSON schema validation"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential", "ExamplePersonCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    },
    "alumniOf": {
      "name": "Example University"
    }
  },
  <span class="highlight">"credentialSchema": [{
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchema"
  },
  {
    "id": "https://example.org/examples/alumni.json",
    "type": "JsonSchema"
  }]</span>
}
        </pre>

        <p>
          위의 예시에서 [=발급자=]는 `credentialSchema`를 지정하고 있는데, 이는
          [=검증자=]가 [=검증가능한 크리덴셜=]이 well-formed인지 여부를 결정하는
          데 사용할 수 있는 [[?VC-JSON-SCHEMA]] 파일을 가리킨다.
        </p>
        <p class="note">
          JSON 스키마 [[?VC-JSON-SCHEMA]] 또는 기타 선택적 스키마 검증
          메커니즘에 대한 연결에 대한 정보는 검증가능한 크리덴셜 구현 지침
          [[VC-IMP-GUIDE]] 문서를 참조하라.
        </p>
        <p>
          데이터 스키마는 또한 영지식 증명을 수행하는 데 사용되는 형식과 같은
          다른 형식에 대한 매핑을 지정하는 데 사용될 수도 있다. 영지식 증명과
          함께 `credentialSchema` [=속성=]을 사용하는 방법에 대한 자세한 내용은
          <a href="#zero-knowledge-proofs"></a> 섹션을 참조하라.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the credentialSchema property to perform zero-knowledge validation"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree",
    "type": "ZkpExampleSchema2018"
  }</span>
}
        </pre>

        <p>
          위의 예시에서 [=발급자=]는 입력 데이터를 [=검증자=]가 [=검증가능한
          크리덴셜=]과 함께 제공된 증명이 well-formed인지 여부를 결정하는 데
          사용할 수 있는 형식으로 변환하는 수단을 가리키는 `credentialSchema`를
          지정하고 있다.
        </p>
      </section>
    </section>

    <section>
      <h2>고급 개념(Advanced Concepts)</h2>

      <p>
        <a href="#basic-concepts"></a> 섹션에서 소개된 개념을 기반으로, 이
        섹션에서는 [=검증가능한 크리덴셜=]에 대한 보다 복잡한 주제를 탐구한다.
      </p>

      <section class="informative">
        <h3>라이프사이클 세부 정보(Lifecycle Details)</h3>

        <p>
          <a href="#ecosystem-overview"></a> 섹션에서는 [=검증가능한 크리덴셜=]
          생태계에 대한 개요를 제공했다. 이 섹션에서는 생태계가 어떻게 작동할
          것으로 예상되는지에 대해 더 자세히 설명한다.
        </p>

        <figure id="life-cycle-details">
          <img
            style="margin: auto; display: block; width: 85%"
            src="diagrams/ecosystemdetail.svg"
            alt="diagram showing how
         credentials flow from issuer to holder, and optionally
         from one holder to another; and how
         presentations flow from holder to verifier,
         optionally from one verifier to another through verification and validation.
         All parties can use information from a logical
         verifiable data registry. Holder may also delete credential."
          />
          <figcaption style="text-align: center">
            Lifecycle of a single Verifiable Credential: the roles and
            information flows for this specification.
          </figcaption>
        </figure>

        <p class="issue" title="Validation needs to be added to image.">
          The process of validation needs to be added to the image above.
        </p>

        <p>[=검증가능한 크리덴셜=] 생태계의 역할과 정보 흐름은 다음과 같다:</p>
        <ul>
          <li>
            [=발급자=]는 [=보유자=]에게 [=검증가능한 크리덴셜=]을
            <dfn class="export" data-lt="issue">발급</dfn>한다. 발급은 항상
            [=크리덴셜=]과 관련된 다른 모든 작업 전에 발생한다.
          </li>
          <li>
            [=보유자=]는 자신의 [=검증가능한 크리덴셜=] 중 하나 이상을 다른
            [=보유자=]에게 <dfn class="export" data-lt="transfers">이전</dfn>할
            수 있다.
          </li>
          <li>
            [=보유자=]는 자신의 [=검증가능한 크리덴셜=] 중 하나 이상을
            [=검증자=]에게 선택적으로 [=검증가능한 프레젠테이션=] 내에서
            <dfn class="export" data-lt="present">제시</dfn>한다.
          </li>
          <li>
            [=검증자=]는 제시된 [=검증가능한 프레젠테이션=]과 [=검증가능한
            크리덴셜=]의 진위를 [=검증=]하고 [=검증가능한 크리덴셜=]의
            <a href="#status">크리덴셜 상태</a>(있는 경우)를 확인한다.
          </li>
          <li>
            [=검증=] 후, [=검증자=]는 자신의 비즈니스 로직을 사용하여 어떤
            발급자가 어떤 클레임에 적합한지, 어떤 주체가 요청된 사용에 적합한지
            평가하여 제시된 [=검증가능한 크리덴셜=]의 관련 클레임을 검증한다.
          </li>
          <li>
            [=발급자=]는 [=검증가능한 크리덴셜=]을
            <dfn class="export" data-lt="revoke">폐기</dfn>할 수 있다.
          </li>
          <li>
            [=보유자=]는 [=검증가능한 크리덴셜=]을
            <dfn class="export" data-lt="delete">삭제</dfn>할 수 있다.
          </li>
        </ul>

        <p class="note">
          위의 작업 순서는 고정되어 있지 않으며, 일부 작업은 두 번 이상 수행될
          수 있다. 이러한 작업 반복은 즉시 또는 나중에 언제든지 발생할 수 있다.
        </p>

        <p>가장 일반적인 작업 순서는 다음과 같이 예상된다:</p>

        <ol>
          <li>
            [=발급자=]가 [=보유자=]에게 [=검증가능한 크리덴셜=]을
            <a href="#lifecycle-details">발급</a>한다.
          </li>
          <li>
            [=보유자=]가 [=검증자=]에게
            <a href="#lifecycle-details">제시</a>한다.
          </li>
          <li>[=검증자=]가 <a href="#lifecycle-details">검증</a>한다.</li>
          <li>
            [=검증자=]가 클레임의
            <a href="#lifecycle-details">유효성을 검사</a>한다.
          </li>
          <li>[=검증자=]가 유효한 클레임을 적용한다.</li>
        </ol>

        <p>
          이 규격은 [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]을
          전송하기 위한 어떠한 프로토콜도 정의하지 않지만, 다른 규격에서 엔티티
          간에 어떻게 전송되는지 명시한다고 가정하면 이 검증가능한 크리덴셜
          데이터 모델을 직접 적용할 수 있다.
        </p>

        <p>
          이 규격은 권한 부여 프레임워크를 정의하지 않으며 [=검증자=]가
          [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]을 [=검증=]한
          후 내릴 수 있는 비즈니스 결정을 제한하지도 않는다. 오히려 [=검증자=]는
          [=보유자=], [=검증가능한 크리덴셜=]의 [=발급자=], [=검증가능한
          크리덴셜=]의 클레임, [=검증자=] 자신의 정책을 고려하여 클레임을 유효한
          것으로 처리하기 전에 자신의 비즈니스 규칙을 적용한다.
        </p>

        <p>
          특히, <a href="#terms-of-use"></a> 섹션과 검증가능한 크리덴셜 구현
          가이드 [[VC-IMP-GUIDE]]의
          <a
            href="https://w3c.github.io/vc-imp-guide/#subject-holder-relationships"
            >주체-보유자 관계</a
          >
          섹션은 [=검증자=]가 다음을 결정할 수 있는 방법을 명시한다:
        </p>

        <ul>
          <li>[=보유자=]가 [=검증가능한 크리덴셜=]의 [=주체=]인지 여부.</li>
          <li>[=주체=]와 [=보유자=] 사이의 관계.</li>
          <li>
            원래 [=보유자=]가 [=검증가능한 크리덴셜=]을 후속 [=보유자=]에게
            전달했는지 여부.
          </li>
          <li>
            [=보유자=] 또는 [=검증자=]에 의한 [=검증가능한 크리덴셜=] 사용에
            대한 제한 사항.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>신뢰 모델(Trust Model)</h3>

        <p>[=검증가능한 크리덴셜=]의 신뢰 모델은 다음과 같다:</p>

        <ul>
          <li>
            [=검증자=]는 [=발급자=]가 수신한 [=크리덴셜=]을 발급한 것을
            신뢰한다. 이 신뢰를 구축하기 위해 [=크리덴셜=]은 다음 중 하나를
            수행할 것으로 예상된다:
            <ul>
              <li>
                [=발급자=]가 [=크리덴셜=]을 생성했음을 나타내는(즉, 그것이
                [=검증가능한 크리덴셜=]임을 나타내는)
                <a href="#securing-mechanisms">보안 메커니즘</a>으로
                [=크리덴셜=]을 보호하거나,
              </li>
              <li>
                [=발급자=]가 [=검증가능한 크리덴셜=]을 생성했으며 [=검증가능한
                크리덴셜=]이 전송 또는 저장 중에 변조되지 않았음을 명확히
                나타내는 방식으로 전송되었어야 한다. 이 신뢰는 [=검증자=]의 위험
                평가에 따라 약화될 수 있다.
              </li>
            </ul>
          </li>
          <li>
            모든 [=엔티티=]는 [=검증가능한 데이터 레지스트리=]가 변조 방지되고
            어떤 데이터가 어떤 [=엔티티=]에 의해 제어되는지에 대한 정확한
            기록임을 신뢰한다.
          </li>
          <li>
            [=보유자=]와 [=검증자=]는 [=발급자=]가 [=주체=]에 대해 사실(즉,
            거짓이 아닌) [=크리덴셜=]을 발급하고, 적절할 때 신속히 폐기할 것을
            신뢰한다.
          </li>
          <li>
            [=보유자=]는 [=리포지토리=]가 [=크리덴셜=]을 안전하게 저장하고,
            [=보유자=] 이외의 누구에게도 공개하지 않으며, 관리 중에 손상되거나
            분실되지 않을 것을 신뢰한다.
          </li>
        </ul>
        <p>이 신뢰 모델은 다음을 보장함으로써 다른 신뢰 모델과 차별화된다:</p>
        <ul>
          <li>
            [=발급자=]와 [=검증자=]는 [=리포지토리=]를 신뢰할 필요가 없다.
          </li>
          <li>[=발급자=]는 [=검증자=]를 알거나 신뢰할 필요가 없다.</li>
        </ul>

        <p>
          [=신원 제공자=]와 [=신뢰 당사자=] 간의 신뢰를 분리함으로써 시장 경쟁과
          고객 선택권이 증가하는 보다 유연하고 역동적인 신뢰 모델이 만들어진다.
        </p>
        <p>
          이 신뢰 모델이 작업 그룹에서 연구한 다양한 위협 모델과 어떻게
          상호작용하는지에 대한 자세한 정보는 검증가능한 크리덴셜 사용 사례 문서
          [[VC-USE-CASES]]를 참조하라.
        </p>

        <p class="note">
          이 규격에 상세히 설명된 데이터 모델은 전통적인 인증 기관 신뢰 모델에서
          제공하는 것과 같은 전이적 신뢰 모델을 의미하지 않는다. 검증가능한
          크리덴셜 데이터 모델에서 [=검증자=]는 [=발급자=]를 직접 신뢰하거나
          신뢰하지 않는다. 검증가능한 크리덴셜 데이터 모델을 사용하여 전이적
          신뢰 모델을 구축할 수 있지만, 구현자는 인증 기관 시스템에서 채택한
          방식으로
          <a
            href="https://www.usenix.org/conference/imc-05/perils-transitive-trust-domain-name-system"
            >광범위하게 신뢰를 위임</a
          >함으로써 도입되는
          <a href="https://datatracker.ietf.org/doc/draft-iab-web-pki-problems/"
            >보안 취약점에 대해 알아보는</a
          >
          것이 좋다.
        </p>
      </section>

      <section>
        <h3>확장성(Extensibility)</h3>

        <p>
          검증가능한 크리덴셜 데이터 모델의 목표 중 하나는 허가 없는 혁신을
          가능하게 하는 것이다. 이를 달성하기 위해서는 데이터 모델이 여러 가지
          방식으로 확장 가능해야 한다. 데이터 모델은 다음이 요구된다:
        </p>
        <ul>
          <li>
            [=그래프=] 기반 데이터 모델을 사용하여 복잡한 다중 엔티티 관계를
            모델링한다.
          </li>
          <li>
            중앙 집중식 시스템을 사용하지 않고 [[?LINKED-DATA]]를 사용하여
            데이터 모델의 정보를 설명하는 데 사용되는 기계 판독 가능한 어휘를
            확장한다.
          </li>
          <li>
            JOSE 또는 COSE [[VC-JOSE-COSE]], 데이터 무결성 증명
            [[VC-DATA-INTEGRITY]], 검증가능한 크리덴셜 사양 디렉토리
            [[?VC-SPECS]]에 나열된 다양한 암호화 제품군을 사용하여 여러 유형의
            암호화 증명 형식을 지원한다.
          </li>
          <li>
            [[JSON-LD11]]의 사용을 통해 가능해지고 소프트웨어 개발자와 웹 페이지
            작성자에게 인기 있는 데이터 형식으로 위에서 설명한 모든 확장성
            메커니즘을 제공한다.
          </li>
        </ul>
        <p>
          이러한 데이터 모델링 접근 방식은 종종 <em>개방 세계 가정</em>이라고
          하는데, 이는 모든 엔티티가 다른 모든 엔티티에 대해 어떤 것이든 말할 수
          있다는 것을 의미한다. 이러한 접근 방식은 단순하고 예측 가능한
          소프트웨어 시스템 구축과 상충되는 것처럼 보이지만, 확장성과 프로그램
          정확성의 균형을 맞추는 것은 폐쇄형 소프트웨어 시스템보다 개방 세계
          가정에서 항상 더 어렵다.
        </p>
        <p>
          이 섹션의 나머지 부분에서는 일련의 예시를 통해 확장성과 프로그램
          정확성을 모두 달성하는 방법을 설명한다.
        </p>
        <p>아래 표시된 [=검증가능한 크리덴셜=]로 시작한다고 가정해 보자.</p>

        <pre
          class="example nohighlight vc"
          title="A simple credential"
          data-vc-vm="https://university.example/issuers/14#keys-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  }
}
        </pre>

        <p>
          이 [=검증가능한 크리덴셜=]은 `did:example:abcdef1234567`와 연결된
          [=엔티티=]가 값이 `Jane Doe`인 `name`을 가지고 있음을 나타낸다.
        </p>
        <p>
          이제 개발자가 [=검증가능한 크리덴셜=]을 확장하여 두 가지 추가 정보, 즉
          내부 기업 참조 번호와 Jane의 좋아하는 음식을 저장하고 싶다고 가정해
          보자.
        </p>
        <p>
          먼저 할 일은 아래와 같이 두 개의 새로운 용어를 포함하는 JSON-LD
          컨텍스트를 만드는 것이다.
        </p>

        <pre class="example nohighlight" title="A JSON-LD context">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

        <p>
          이 JSON-LD 컨텍스트가 생성된 후, 개발자는 [=검증가능한 크리덴셜=]을
          처리할 [=검증자=]가 접근할 수 있도록 어딘가에 게시한다. 위의 JSON-LD
          컨텍스트가 `https://example.com/contexts/mycontext.jsonld`에
          게시되었다고 가정하면, 컨텍스트를 포함하고 새로운 [=속성=]과
          [=크리덴셜=] [=타입=]을 [=검증가능한 크리덴셜=]에 추가하여 이 예시를
          확장할 수 있다.
        </p>

        <pre
          class="example nohighlight"
          title="A verifiable credential with a custom extension"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  }
}
        </pre>

        <p>
          이 예시는 허가 없이 분산된 방식으로 검증가능한 크리덴셜 데이터 모델을
          확장하는 것을 보여준다. 이러한 방식으로 생성된 [=검증가능한
          크리덴셜=]이 네임스페이스 충돌과 의미적 모호성을 방지하기 위한
          메커니즘을 제공하도록 보장한다.
        </p>
        <p>
          이와 같은 동적 확장성 모델은 구현 부담을 증가시킨다. 이러한 시스템을
          위해 작성된 소프트웨어는 애플리케이션의 위험 프로필에 따라 확장된
          [=검증가능한 크리덴셜=]이 수용 가능한지 여부를 결정해야 한다. 일부
          애플리케이션은 특정 확장만 수용할 수 있는 반면, 고도로 안전한
          환경에서는 어떠한 확장도 수용하지 않을 수 있다. 이러한 결정은 이들
          애플리케이션의 개발자에게 달려 있으며 이 규격의 영역이 아니다.
        </p>
        <p>
          개발자는 확장 JSON-LD 컨텍스트를 높은 가용성으로 제공해야 한다.
          컨텍스트를 역참조할 수 없는 구현은 오류를 발생시킬 것이다. 확장
          JSON-LD 컨텍스트가 항상 사용 가능하도록 보장하는 전략으로는 컨텍스트에
          콘텐츠 주소 지정 URL을 사용하거나, 컨텍스트 문서를 구현과 함께
          번들링하거나, 컨텍스트의 적극적인 캐싱을 활성화하는 것 등이 있다.
        </p>
        <p>
          구현자는 <a href="#proofs-signatures"></a>, <a href="#status"></a>,
          <a href="#data-schemas"></a>, <a href="#refreshing"></a>,
          <a href="#terms-of-use"></a>, <a href="#evidence"></a> 섹션과 같은 이
          규격의 확장점에 세심한 주의를 기울일 것을 권장한다. 이 규격은 이러한
          확장점에 대한 구체적인 구현을 정의하지는 않지만, 검증가능한 크리덴셜
          사양 디렉토리 [[?VC-SPECS]]는 개발자가 이러한 확장점에서 사용할 수
          있는 비공식적이지만 큐레이션된 확장 목록을 제공한다.
        </p>

        <section>
          <h4>의미적 상호운용성(Semantic Interoperability)</h4>

          <p>
            애플리케이션별 어휘에서 새로운 용어를 정의할 때, 개발자는 용어를
            식별하기 위해 반드시 전역적으로 모호하지 않은 [=URL=]을 사용해야
            한다. 가능한 경우 [[[?DCTERMS]]] [[?DCTERMS]] 또는 [[[?schema-org]]]
            [[?schema-org]]와 같은 잘 알려진 공개 어휘에서 정의된 용어와 해당
            URL을 재사용하는 것이 권장된다. 그것이 불가능하다면, 작성자는 각
            용어에 대해 새로운 URL을 반드시 <em>정의</em>해야 한다. 그렇게 할
            때는 [[LINKED-DATA]]에 대한 일반적인 지침, 특히 다음 사항을 따를
            것으로 예상된다:
          </p>
          <ul>
            <li>
              각 용어의 의미론과 사용 제약 조건을 설명하는 사람이 읽을 수 있는
              문서를 반드시 게시해야 한다.
            </li>
            <li>
              모든 새로운 용어의 모음을 [[[?RDF-SCHEMA]]] [[?RDF-SCHEMA]]를
              사용하여 기계 판독 가능한 어휘로 게시하는 것도 권장된다.
            </li>
            <li>
              용어의 URL을 역참조하여 해당 용어의 설명 및/또는 정규 정의를 얻을
              수 있어야 한다.
            </li>
          </ul>
          <p>
            개발자는 새로운 어휘를 정의할 때 [[[?LD-BP]]] [[?LD-BP]]의
            <a data-cite="?LD-BP#vocabulary-checklist">상세 체크리스트</a>를
            따라야 한다.
          </p>
          <p>
            또한, 어휘의 `@context` [=속성=]에 지정된 URL에 기계 판독 가능한
            설명(즉,
            <a data-cite="JSON-LD11#dfn-context">JSON-LD 컨텍스트 문서</a>)을
            반드시 게시해야 한다. 이 컨텍스트는 각 용어를 해당 URL에 매핑해야
            하며, 속성 값의 유형과 같은 추가 제약 조건이 포함될 수 있다.
            `@context` [=속성=]의 값에 대한 예상 순서를 설명하는 사람이 읽을 수
            있는 문서도 상호운용성을 추구하는 모든 구현자가 게시할 것으로
            예상된다.
          </p>
          <p class="note">
            <a href="#dfn-context">이 규격에서 정의된</a> 기본 JSON-LD 컨텍스트
            문서에 의해 정의된
            <a data-cite="JSON-LD11#dfn-active-context">활성 컨텍스트</a>를
            처리할 때, JSON-LD 기반의 규격 준수 프로세서는 JSON-LD 컨텍스트가
            어떤 용어를 <em>재정의</em>할 때 오류를 생성한다. 기존 용어의 정의를
            변경하는 유일한 방법은 새로운 용어 범위 내에서 활성 컨텍스트를
            지우는 새로운 용어를 도입하는 것이다. 이 기능에 관심이 있는 작성자는
            JSON-LD 1.1 규격의
            <a data-cite="JSON-LD11#protected-term-definitions">`@protected`</a>
            키워드에 대해 읽어보는 것이 좋다.
          </p>
          <p>
            이 규격의 기본 JSON-LD 컨텍스트 파일에는
            <a data-cite="JSON-LD11/#default-vocabulary">`@vocab`</a> 키워드를
            사용하는 추가 기능도 포함되어 있는데, 이는 [=검증가능한 크리덴셜=]
            또는 [=검증가능한 프레젠테이션=]의 정의되지 않은 모든 용어가
            자동으로 `https://www.w3.org/ns/credentials/issuer-dependent#`
            접두사가 붙은 URL에 매핑되도록 한다. 이는 개발 단계에서 정규 정의
            없이 용어를 조기에 실험할 수 있도록 하기 위한 것이다. 개발자는
            프로덕션 환경에서 이 기능을 사용하지 말아야 한다는 점에 유의해야
            한다. 이는 이름 충돌을 야기하여 다른 애플리케이션과 의미적 모호성을
            초래할 수 있기 때문이다. 대신 이 섹션 앞부분에서 설명한 대로 적절한
            상호운용성을 달성하기 위해 모든 용어를 정의해야 한다.
          </p>
        </section>
      </section>

      <section>
        <h2>관련 리소스의 무결성(Integrity of Related Resources)</h2>
        <p>
          [=검증가능한 크리덴셜=]에 외부 리소스에 대한 링크를 포함할 때,
          가리키는 리소스가 서명 시점과 검증 시점에 동일한지 여부를 아는 것이
          바람직하다. 이는 원격으로 검색되는 외부 리소스가 있는 경우와
          [=발급자=] 및/또는 [=검증자=]가 리소스의 로컬 캐시 사본을 가질 수 있는
          경우에 모두 적용된다.
        </p>
        <p>
          또한 [=검증가능한 크리덴셜=]에 사용된 JSON-LD 컨텍스트의 내용이
          [=발급자=]와 [=검증자=] 모두에 의해 사용될 때 동일한 것을 아는 것도
          바람직하다.
        </p>
        <p>
          [=검증가능한 크리덴셜=]이 참조하는 리소스가 발급 시점과 검증 시점에
          동일한지 검증하기 위해, 구현자는
          <code id="defn-relatedResource">relatedResource</code>라는 속성을
          포함할 수 있다. 이 속성은 [=검증가능한 크리덴셜=]에서 참조하는 각
          리소스에 대한 추가 무결성 메타데이터를 설명하는 객체의 배열을
          저장한다. `relatedResource`가 존재하는 경우, 검증가능한 크리덴셜에
          사용된 각 컨텍스트에 대해 각 원격 리소스마다 배열에 객체가 반드시
          있어야 한다.
        </p>
        <p
          class="issue"
          title="relatedResource에서 컨텍스트의 필수 나열은 논의 중입니다."
        >
          `relatedResource`에 컨텍스트를 나열해야 한다는 요구사항은 현재
          VCWG에서 논의 중이다. 이 요구사항은 향후 규격 반복에서 제거될 수 있다.
        </p>
        <p>
          `relatedResource` 배열의 각 객체는 반드시 다음을 포함해야 한다: `id`로
          명명된 리소스의 [[URL]]과
          <a href="https://www.w3.org/TR/SRI/#integrity-metadata"
            >하위 리소스 무결성</a
          >에 지정된 방법을 사용하여 구성된 리소스의
          <code id="defn-digestSRI">digestSRI</code> 정보.
        </p>
        <p
          class="issue"
          title="암호화 해시 표현 형식의 통합에 대해 논의 중입니다"
        >
          현재 작업 그룹은 VCWG 핵심 규격 전체에서 암호화 해시 표현 형식을
          통합할 수 있는지 여부를 결정하려고 시도하고 있다. 이 메커니즘의
          후보로는 `digestSRI`와 `digestMultibase`가 있다. WG에서 현재 논의 중인
          통합에 대한 찬반 논거가 있다.
        </p>
        <p>
          `relatedResource`에는 `id`당 하나 이상의 객체가 존재해서는 안 된다.
        </p>
        <p>
          `relatedResource` 배열의 객체에는 표시된 `resource`에 대해 예상되는
          미디어 유형을 나타내는 `mediaType`이라는 속성이 포함될 수 있다.
          `mediaType`이 포함된 경우 그 값은 다음과 같아야 한다:
        </p>

        <ul>
          <li>
            <a
              href="https://www.iana.org/assignments/media-types/media-types.xhtml"
              >IANA 미디어 유형</a
            >
            레지스트리에 나열된 유효한 미디어 유형이어야 한다.
          </li>
          <li>`Accept` HTTP 헤더와 같이 콘텐츠를 검색할 때 사용되어야 한다.</li>
          <li>
            `Content-Type` HTTP 헤더와 같이 검색된 콘텐츠 미디어 유형과 일치해야
            한다.
          </li>
        </ul>

        <p>
          `id` [[URL]] 속성을 포함하는 [=검증가능한 크리덴셜=]의 모든 객체는
          객체에 `digestSRI`를 포함하여 이 섹션에 지정된 대로 무결성 정보로
          주석을 달 수 있다.
        </p>
        <p>
          선택적 공개가 바람직한 객체는 `relatedResource` 배열의 객체로 포함되지
          않는 것이 좋다.
        </p>
        <p>
          [=적합한 문서=] 내부의 객체의 `id`에 기반하여 리소스를 가져오는
          알고리즘을 작성하는 규격 작성자는 해당 리소스의 내용이 문서의 유효성에
          필수적인지 여부를 고려해야 한다. 그렇다면 리소스가 예상되는 미디어
          유형을 가지고 있고 그 바이트가 예상되는 다이제스트로 해시되지 않는 한
          규격은 반드시 유효성 검사 오류를 생성해야 한다.
        </p>
        <p>
          구현자는
          <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf"
            >FIPS 180-4 보안 해시 표준</a
          >과
          <a
            href="https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF"
            >상용 국가 보안 알고리즘 제품군 2.0</a
          >과 같은 적절한 출처를 참조하여 현재 신뢰할 수 있는 해시 알고리즘을
          선택하고 있는지 확인해야 한다. 이 글을 쓰는 시점에서 `sha384`는
          구현자가 사용하기 위한 최소 강도 해시 알고리즘으로 간주되어야 한다.
        </p>
        <p class="issue">
          작업 그룹은 해당 규격의
          <a href="https://www.w3.org/TR/json-ld11/#security"
            >현재 보안 고려사항</a
          >에 명시된 대로 [[SRI]]에 정의된 하위 리소스 무결성의 더 많은 측면을
          [[JSON-LD11]] 규격에 채택할 것인지 논의 중이다. VC의 이 해시는 VC를
          발급할 때 사용된 캐시된 컨텍스트가 원격 리소스와 일치하는지 확인하기
          위한 추가 검사로 사용될 수 있다.
        </p>
        <p>JSON-LD 컨텍스트를 참조하는 관련 리소스 무결성 객체의 예시이다.</p>

        <pre
          class="example nohighlight"
          title="Usage of the relatedResource property"
        >
"relatedResource": [{
  "id": "https://www.w3.org/ns/credentials/v2",
  "digestSRI":
    "sha384-lHKDHh0msc6pRx8PhDOMkNtSI8bOfsp4giNbUrw71nXXLf13nTqNJoRp3Nx+ArVK",
},{
  "id": "https://www.w3.org/ns/credentials/examples/v2",
  "digestSRI":
    "sha384-zNNbQTWCSUSi0bbz7dbua+RcENv7C6FvlmYJ1Y+I727HsPOHdzwELMYO9Mz68M26",
}]
        </pre>

        <p>
          An example of an object in a `credentialSubject` that is refering to
          an integrity protected image.
        </p>

        <pre
          class="example nohighlight"
          title="An integrity-protected image that is associated with a credentialSubject"
        >
"credentialSubject": {
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "image": {
    "id": "https://university.example.org/images/58473",
    "digestSRI":
      "sha384-ZfAwuJmMgoX3s86L7x9XSPi3AEbiz6S/5SyGHJPCxWHs5NEth/c5S9QoS1zZft+J",
    "mediaType": "application/svg+xml",
  },
  ...
}
        </pre>
      </section>

      <section>
        <h3>갱신(Refreshing)</h3>

        <p
          class="issue"
          title="(AT RISK) Feature depends on demonstration of independent implementations"
        >
          이 기능은 위험하며, 후보 권고안 단계가 끝날 때까지 단일 확장 유형에
          대해 최소 두 개의 독립적이고 상호운용 가능한 구현이 시연되지 않으면
          규격에서 제거될 것이다. 이 기능이 제거되면 향후 구현 및 규격 포함을
          예상하여 <a href="#reserved-extension-points"></a> 섹션에 해당 속성이
          포함된다.
        </p>

        <p>
          만료된 [=검증가능한 크리덴셜=]을 수동 또는 자동으로 갱신할 수 있도록
          하는 것이 시스템에 유용하다. [=검증가능한 크리덴셜=]의 유효 기간에
          대한 자세한 내용은 <a href="#validity-periods"></a> 섹션을 참조하시오.
          이 규격은 [=발급자=]가 갱신 서비스에 대한 링크를 포함할 수 있도록 하는
          `refreshService` [=속성=]을 정의한다.
        </p>
        <p>
          [=발급자=]는 [=검증자=] 또는 [=보유자=](또는 둘 다)를 위한 것이라면
          [=검증가능한 크리덴셜=] 내부에, [=보유자=]만을 위한 것이라면
          [=검증가능한 프레젠테이션=] 내부에 갱신 서비스를 요소로 포함할 수
          있다. 후자의 경우 [=보유자=]가 [=검증자=]와 공유할 [=검증가능한
          프레젠테이션=]을 생성하기 전에 [=검증가능한 크리덴셜=]을 갱신할 수
          있게 해준다. 전자의 경우 [=검증가능한 크리덴셜=] 내부에 갱신 서비스를
          포함하면 [=보유자=] 또는 [=검증자=]가 향후 [=크리덴셜=]을 업데이트할
          수 있다.
        </p>
        <p>
          갱신 서비스는 [=크리덴셜=]이 만료되었거나 [=발급자=]가 [=크리덴셜=]
          상태 정보를 게시하지 않을 때만 사용될 것으로 예상된다. [=발급자=]는
          공개 정보를 포함하지 않거나 갱신 서비스가 어떤 식으로든 보호되지 않는
          [=검증가능한 크리덴셜=]에 `refreshService` [=속성=]을 넣지 않는 것이
          좋다.
        </p>
        <p class="note">
          [=검증자=]가 사용할 수 있도록 [=검증가능한 크리덴셜=]에
          `refreshService` [=속성=]을 배치하면 [=보유자=]의 제어와 동의를
          제거하고 [=검증가능한 크리덴셜=]이 [=보유자=]를 무시하고
          [=검증자=]에게 직접 발급될 수 있다.
        </p>
        <dl>
          <dt><var id="defn-refreshService">refreshService</var></dt>
          <dd>
            `refreshService` [=속성=]의 값은 반드시 수신자의 소프트웨어가
            [=검증가능한 크리덴셜=]을 갱신할 수 있도록 수신자에게 충분한 정보를
            제공하는 하나 이상의 갱신 서비스여야 한다. 각 `refreshService` 값은
            반드시 그 `type`을 지정해야 한다. 각 갱신 서비스의 정확한 내용은
            특정 `refreshService` [=타입=] 정의에 의해 결정된다.
          </dd>
        </dl>

        <pre
          class="example nohighlight"
          title="Usage of the refreshService property by an issuer"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://w3id.org/vc-refresh-service/v1"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2020-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "type": "VerifiableCredentialRefreshService2021",
    "url": "https://university.example/workflows/refresh-degree",
    "validFrom": "2021-09-01T19:23:24Z",
    "validUntil": "2022-02-01T19:23:24Z"
  }</span>
}
        </pre>

        <p>
          위의 예에서 [=발급자=]는 [=보유자=]를
          `https://university.example/workflows/refresh-degree`로 안내하여
          사용할 수 있는 자동 `refreshService`를 지정한다.
        </p>
      </section>

      <section>
        <h3>사용 약관(Terms of Use)</h3>

        <p>
          [=발급자=] 또는 [=보유자=]는 [=검증가능한 크리덴셜=] 또는 [=검증가능한
          프레젠테이션=]이 발급된 조건을 전달하기 위해 사용 약관을 활용할 수
          있다. [=발급자=]는 [=검증가능한 크리덴셜=] 내에 자신의 사용 약관을
          배치한다. [=보유자=]는 [=검증가능한 프레젠테이션=] 내에 자신의 사용
          약관을 배치한다. 이 규격은 사용 약관 정보를 표현하기 위한 `termsOfUse`
          [=속성=]을 정의한다.
        </p>
        <p>
          `termsOfUse` [=속성=]의 값은 다음을 포함하여 [=검증자=]에게 다음 중
          하나 또는 모두를 알리는 데 사용될 수 있다:
        </p>
        <ul>
          <li>
            [=검증가능한 크리덴셜=]을 발급할 때 사용된 절차 또는 정책. 예를
            들어, 이러한 절차 또는 정책을 찾을 수 있는 공개 위치("phone home"
            프라이버시 문제를 피하기 위해)에 대한 포인터 또는 이를 정의하는
            표준의 이름을 제공한다.
          </li>
          <li>
            [=검증자=]에게 이 [=검증가능한 크리덴셜=]을 제시하는 데 적용되는
            [=발급자=]의 규칙 및 정책. 예를 들어, 이러한 규칙 또는 정책을 찾을
            수 있는 공개 위치("phone home" 프라이버시 문제를 피하기 위해)를
            가리키는 정보를 제공한다.
          </li>
          <li>
            [=발급자=]가 이 특정 [=검증가능한 크리덴셜=]을 발급한 권한을 가진
            엔티티의 ID.
          </li>
        </ul>
        <dl>
          <dt><var id="defn-termsOfUse">termsOfUse</var></dt>
          <dd>
            `termsOfUse` [=속성=]의 값은 제작자가 [=크리덴셜=] 또는
            [=프레젠테이션=]을 발급한 하나 이상의 사용 약관 정책을 지정해야
            한다. 수신자([=보유자=] 또는 [=검증자=])가 명시된 사용 약관을 준수할
            의사가 없는 경우 자신의 책임하에 그렇게 해야 하며, 명시된 사용
            약관을 위반하면 법적 책임을 질 수 있다. 각 `termsOfUse` 값은
            [=type=](예: `IssuerPolicy`)을 지정해야 하며 인스턴스 `id`를 지정할
            수 있다. 각 사용 약관의 정확한 내용은 특정 `termsOfUse` [=type=]
            정의에 의해 결정된다.
          </dd>
        </dl>

        <pre
          class="example nohighlight"
          title="Usage of the termsOfUse property by an issuer"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:did:123456",
  "type": [
    "VerifiableCredential",
    "EbsiTermsOfUseExample"
  ],
  "issuer": "did:ebsi:zz7XsC9ixAXuZecoD9sZEM1",
  "validFrom": "2021-11-01T00:00:00Z",
  "validUntil": "2021-10-30T00:00:00Z",
  "credentialSubject": {
    "id": "did:key:z2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbrDt4zxXoDrBWYFiATYZ8G9JMeEXC7Kki24fbTwtsJbGe5qcbkYFunSzcDokMRmj8UJ1PbdCGh33mf97K3To89bMzd15qrYq3VkDztoZqfmujkJVpvTbqoXWXqxmzNDbvMJ",
    "personalIdentifier": "IT/DE/1234",
    "familyName": "Castafiori",
    "firstName": "Bianca",
    "dateOfBirth": "1930-10-01"
  },
  "credentialSchema": {
    "id": "https://api-test.ebsi.eu/trusted-schemas-registry/v2/schemas/z3MgUFUkb722uq4x3dv5yAJmnNmzDFeK5UC8x83QoeLJM",
    "type": "JsonSchema"
  },
  "termsOfUse": {
    "id": "https://api-test.ebsi.eu/trusted-issuers-registry/v4/issuers/did:ebsi:zz7XsC9ixAXuZecoD9sZEM1/attributes/7201d95fef05f72667f5454c2192da2aa30d9e052eeddea7651b47718d6f31b0",
    "type": "IssuanceCertificate"
  }
}
        </pre>

        <p>
          In the example above, the [=issuer=] is asserting that as a European
          Blockchain Services Infrastructure (EBSI) accredited issuer, it
          complies with the EBSI policies as an accredited issuer and is
          registered in the EBSI register of trusted issuers. The `termsOfUse`
          [=id=] can be resolved by the [=verifier=] to confirm that the
          [=issuer=] has been issued an accreditation VC (in JWT format) by a
          trusted issuer higher in the EBSI trust chain [?EBSI].
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the termsOfUse property by a holder"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    {
        "@protected": true,
        "VerifiablePresentationTermsOfUseExtension": {
          "@id": "https://www.w3.org/2018/credentials/examples#VerifiablePresentationExtension",
          "@context": {
            "@protected": true,
            "termsOfUse": {
              "@id": "https://www.w3.org/2018/credentials#termsOfUse",
              "@type": "@id"
            }
          }
        }
    }
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/3732",
    "type": ["VerifiableCredential", "ExampleDegreeCredential"],
    "issuer": "https://university.example/issuers/14",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
        "type": "ExampleBachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://university.example/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }]</span>
}
        </pre>

        <p>
          위의 예에서 [=주체=]이기도 한 [=보유자=](`assigner`)는
          [=검증자=](`assignee`, `https://wineonline.example.org`)가 제공된
          정보를 제3자 서비스를 사용하여 [=보유자=] 또는 [=주체=]와 상관관계를
          만드는 데 사용하는 것을 금지하는 사용 약관을 표현했다. [=검증자=]가
          상관관계를 위해 제3자 서비스를 사용한다면 [=보유자=]가
          [=프레젠테이션=]을 생성한 조건을 위반하게 된다.
        </p>
        <p>
          이 기능은 또한 정부 발급 [=검증가능한 크리덴셜=]에서 민감한 데이터의
          예기치 않은 사용으로부터 시민을 보호하기 위해 유사한 정부 조직으로
          사용을 제한하도록 디지털 지갑에 지시하는 데 사용될 것으로 예상된다.
          마찬가지로 민간 산업에서 발급한 일부 [=검증가능한 크리덴셜=]은 조직 내
          부서 내에서 또는 업무 시간 동안 사용을 제한할 것으로 예상된다.
          구현자는 Verifiable Credentials Implementation Guidelines
          [[?VC-IMP-GUIDE]] 문서의 해당 섹션에서 이 빠르게 진화하는 기능에 대해
          더 읽어볼 것을 권장한다.
        </p>
      </section>

      <section>
        <h3>증거(Evidence)</h3>

        <p
          class="issue"
          data-number="1303"
          title="(AT RISK) Feature depends on demonstration of independent implementations"
        >
          이 기능은 위험하며, Candidate Recommendation 단계 종료까지 하나의 확장
          유형에 대해 최소 두 개의 독립적이고 상호 운용 가능한 구현이 입증되지
          않으면 규격에서 제거된다. 이 기능이 제거되면 해당 속성은 향후 구현 및
          규격 포함을 예상하여 섹션 <a href="#reserved-extension-points"></a>에
          포함된다.
        </p>

        <p>
          [=발급자=]는 [=검증가능한 크리덴셜=]에서 [=검증자=]에게 추가 지원
          정보를 제공하기 위해 증거를 포함할 수 있다. 이는 [=검증자=]가
          [=검증가능한 크리덴셜=]의 클레임을 신뢰하는 데 있어 확신을 가질 수
          있도록 사용될 수 있다.
        </p>
        <p>
          예를 들어, [=발급자=]는 [=크리덴셜=]을 발급하기 전에 [=주체=]가 제공한
          물리적 문서를 확인하거나 일련의 배경 조사를 수행할 수 있다. 특정
          시나리오에서 이 정보는 [=검증자=]가 특정 [=크리덴셜=]에 의존하는 것과
          관련된 위험을 결정할 때 유용하다.
        </p>
        <p>
          이 규격은 증거 정보를 표현하기 위한 `evidence` [=속성=]을 정의한다.
        </p>
        <dl>
          <dt><dfn id="defn-evidence" class="export">evidence</dfn></dt>
          <dd>
            `evidence` [=속성=]의 값은 [=검증자=]가 [=발급자=]가 수집한 증거가
            [=크리덴셜=]에 의존하기 위한 신뢰 요구사항을 충족하는지 여부를
            결정하기에 충분한 정보를 제공하는 하나 이상의 증거 스키마여야 한다.
            각 증거 스키마는 해당 [=type=]으로 식별된다. `id` [=속성=]은
            선택사항이지만, 있는 경우 이 증거 인스턴스에 대한 자세한 정보를 찾을
            수 있는 URL을 포함해야 한다. 각 증거 스키마의 정확한 내용은 특정
            `evidence` [=type=] 정의에 의해 결정된다.
          </dd>
        </dl>
        <p class="note">
          [=크리덴셜=] 및 비크리덴셜 데이터에 대한 첨부 파일 및 참조가 규격에서
          어떻게 지원될 수 있는지에 대한 정보는 Verifiable Credentials
          Implementation Guidelines [[VC-IMP-GUIDE]] 문서를 참조하라.
        </p>

        <pre class="example nohighlight" title="Usage of the evidence property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": {
    "id": "https://university.example/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://university.example/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical",
    "licenseNumber": "123AB4567"
  }</span>
}
        </pre>
        <pre
          class="example nohighlight"
          title="Example of evidence supporting a skill achievement credential"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://purl.imsglobal.org/spec/ob/v3p0/context-3.0.3.json"
  ],
  "id": "http://1edtech.edu/credentials/3732",
  "type": [
    "VerifiableCredential",
    "OpenBadgeCredential"
  ],
  "issuer": {
    "id": "https://1edtech.edu/issuers/565049",
    "type": "Profile"
  },
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "type": "AchievementSubject",
    "name": "Alice Smith",
    "activityEndDate": "2023-12-02T00:00:00Z",
    "activityStartDate": "2023-12-01T00:00:00Z",
    "awardedDate": "2024-01-01T00:00:00Z",
    "achievement": [{
      "id": "urn:uuid:d46e8ef1-c647-419b-be18-5e045d1c4e64",
      "type": ["Achievement"],
      "name": "Basic Barista Training",
      "criteria": {
        "narrative": "Team members are nominated for this badge by their supervisors, after passing the Basic Barista Training course."
      },
      "description": "This achievement certifies that the bearer is proficient in basic barista skills."
    }]
  },
  "evidence": [{
      <span class='comment'>// url to an externally hosted evidence file/artifact</span>
      "id": "https://videos.example.com/training/alice-espresso.mp4",
      "type": ["Evidence"],
      "name": "Talk-aloud video of double espresso preparation",
      "description": "This is a talk-aloud video of Alice demonstrating preparation of a double espresso drink.",
      <span class='comment'>// digest hash of the mp4 video file</span>
      "digestSRI": "sha384-zNNbQTWCSUSi0bbz7dbua...OHdzwELMYO9Mz68M26"
    }
  ]
}
</pre>
        <p class="note">
          이 `evidence` 예에서 [=발급자=]는 [=크리덴셜=]의 [=주체=]를 명시된
          면허 번호가 있는 운전면허증의 물리적 복사본과 물리적으로 대조했다고
          주장하고 있다. 이 운전면허증은 발급 과정에서 "Example University"가
          크리덴셜 발급 전에 어떻게 주체를 확인했는지(물리적 확인) 검증하는 데
          사용되었다.
        </p>
        <p class="note">
          `evidence` [=속성=]은 사용된 보안 메커니즘과 다른 정보를 제공한다.
          `evidence` [=속성=]은 [=검증가능한 크리덴셜=]의 무결성과 관련된 증거
          서류와 같은 지원 정보를 표현하는 데 사용된다. 반면에 보안 메커니즘은
          [=발급자=]의 진위성 및 [=검증가능한 크리덴셜=]의 무결성과 관련된 기계
          검증 가능한 수학적 증명을 표현하는 데 사용된다. 보안 메커니즘에 대한
          자세한 내용은 섹션 <a href="#securing-mechanisms"></a>을 참조하라.
        </p>
      </section>

      <section>
        <h3>영지식증명(Zero-Knowledge Proofs)</h3>

        <p>
          영지식증명은 실제 값을 공개하지 않고도 사용자가 값에 대한 지식을
          증명할 수 있게 해주는 암호학적 방법이다. 이 데이터 모델은 영지식증명
          메커니즘의 사용으로 보안을 지원한다.
        </p>
        <p>
          [=검증가능한 크리덴셜=]과 호환되며 영지식증명 메커니즘으로 가능한 몇
          가지 기능은 다음과 같다:
        </p>
        <ul>
          <li>
            [=보유자=]가 [=검증자=]에게 [=검증가능한 크리덴셜=]의 속성을
            선택적으로 공개하는 것. 이를 통해 [=보유자=]는 [=검증자=]에게 정확히
            필요한 정보만 제공할 수 있다. 또한 프레젠테이션 중에 [=발급자=]를
            관여시킬 필요 없이 [=검증자=]의 데이터 스키마에 따라 포맷된 파생
            [=검증가능한 크리덴셜=]을 생성할 수 있다. 이는 [=보유자=]가 발급받은
            [=검증가능한 크리덴셜=]을 사용하는 데 상당한 유연성을 제공한다.
          </li>
          <li>
            [=검증자=]와 공유되는 서명 값의 블라인딩. 블라인드 서명은 연결
            불가능한 증명을 허용하며, 이는 하나 이상의 [=검증자=]에게 여러 번
            프레젠테이션할 때 [=보유자=] 상관관계의 공통 소스를 제거한다. 이를
            통해 [=보유자=]는 각 프레젠테이션마다 다른 서명 값을 공유할 수
            있으며, 이는 공유되는 데이터의 양을 줄인다.
          </li>
          <li>
            [=보유자=] 및/또는 [=주체=]의 프라이버시 보존 식별. 이를 통해
            [=보유자=]는 식별자를 공유하지 않고도 [=크리덴셜=]이 자신에게
            발급되었음을 증명하거나, [=주체=]는 [=크리덴셜=]이 자신에 대해
            발급되었음을 증명할 수 있다. 이는 공유해야 하는 데이터의 양도
            줄인다. 이 기능은 또한 [=검증자=]에게 [=검증가능한 크리덴셜=] 또는
            [=주체=] 식별자를 공개하지 않고 여러 [=발급자=]의 여러 [=검증가능한
            크리덴셜=]을 단일 [=검증가능한 프레젠테이션=]으로 결합하는 데 사용될
            수 있다.
          </li>
        </ul>
        <p>
          모든 기능이 모든 영지식증명 메커니즘에서 지원되는 것은 아니다. 특정
          영지식증명 메커니즘에서 제공하는 기능과 기술에 대한 구체적인 세부
          사항과 함께 [=검증가능한 크리덴셜=]과 함께 사용하기 위한 규범적
          요구사항은 해당 영지식증명 메커니즘으로 [=검증가능한 크리덴셜=]을
          보호하기 위한 규격에서 찾을 수 있다.
        </p>
        <p>
          대부분의 경우 [=보유자=]가 [=검증가능한 크리덴셜=]과 함께 영지식
          메커니즘을 사용하려면 [=발급자=]가 이러한 기능을 지원하는 방식으로
          [=검증가능한 크리덴셜=]을 보호해야 한다는 점에 유의한다.
        </p>
        <p>
          [=보유자=]가 [=검증가능한 크리덴셜=]의 일부를 선택적으로 공개한 경우,
          [=검증자=]는 파생 [=검증가능한 크리덴셜=]에 제공된 정보가 [=발급자=]가
          제공한 `credentialSchema` [=속성=]의 스키마와 호환되는지 확인하는 것이
          중요하다. [=검증자=]가 [=보유자=]의 데이터 요청의 일부로
          [=보유자=]에게 스키마를 제공하고, [=검증자=]가 파생 [=검증가능한
          크리덴셜=]이 해당 스키마와도 호환되는지 확인하는 것도 가능하다. 우리는
          이 규격에서 그러한 요청 스키마를 정의하지 않지만, 이를 수행하는 한
          가지 방법의 예는 [[?PRES-EX]]이다.
        </p>
        <p class="note">
          `credentialSchema` 구현자는 선택적 공개 크리덴셜의 영향을 고려하고
          구성에 따라 처리를 위한 지침을 제공하는 것이 좋다. 선택적 공개를
          염두에 두고 스키마가 형성되지 않은 경우 유효성 검사는 실패할 가능성이
          높다.
        </p>
        <p>
          아래 다이어그램은 데이터 모델이 영지식으로 [=검증가능한 크리덴셜=]을
          발급하고 제시하는 데 어떻게 사용될 수 있는지 보여준다.
        </p>
        <p class="issue">
          <a href="https://w3c.github.io/vc-di-bbs/">vc-di-bbs</a>를 활용한
          예시는 추후 여기에 추가되거나 이 섹션이 제거될 것이다.
        </p>

        <figure>
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/zkp-cred-pres.svg"
            alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2."
          />
          <figcaption style="text-align: center">
            A visual example of the relationship between credentials and derived
            credentials in a ZKP [=presentation=].
          </figcaption>
        </figure>

        <p>
          다음 지침은 연결 불가능성을 제공하는
          <a href="#securing-mechanisms">보안 메커니즘</a> 규격을 만드는 저자를
          위해 제공된다:
        </p>
        <ul>
          <li>
            연결 불가능한 보안 메커니즘은 [=검증자=]가 여러 [=검증가능한
            프레젠테이션=]에서 서로 다른 [=검증자=]에 대한 [=보유자=]를 연관시킬
            수 있는 정보를 유출하는 방식으로 설계되어서는 안 된다.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>인가(Authorization)</h3>

        <p>
          [=검증가능한 크리덴셜=]은 [=주체=]를 안정적으로 식별하기 위한 수단으로
          의도되었다. 역할 기반 접근 제어(RBAC)와 속성 기반 접근 제어(ABAC)가
          [=주체=]에 대한 리소스 접근 권한을 부여하는 수단으로 이러한 식별에
          의존한다는 점은 인정되지만, 이 규격은 RBAC 또는 ABAC를 위한 완전한
          솔루션을 제공하지는 않는다. 인가는 동반되는 인가 프레임워크 없이는 이
          규격에 적절한 사용이 아니다.
        </p>
        <p>
          Working Group은 이 규격을 만드는 동안 인가의 사용 사례를 고려했으며 이
          규격 위에 구축된 아키텍처 계층으로 해당 작업을 추진하고 있다.
        </p>
      </section>

      <section class="normative">
        <h3>예약된 확장 포인트(Reserved Extension Points)</h3>

        <p>
          이 규격은 가능한 확장 포인트로 사용할 수 있는 여러 [=속성=]을
          예약한다. 일부 구현자는 이러한 속성에 대한 관심을 표명했지만, 이
          규격에 포함시키는 것은 시기상조인 것으로 간주되었다. 이러한 확장
          포인트 중 일부는 이전 버전의 이 규격에서 원래 정의되었고, 다른 일부는
          그렇지 않았다. 이 속성들 중 어느 것도 이 규격에서 정의되지 않는다는
          점에 유의해야 한다. 따라서 구현자는 이러한 속성의 사용은 실험적인
          것으로 간주된다는 점에 주의해야 한다.
        </p>
        <p>
          구현자는 이러한 속성을 사용할 수 있지만, 이러한 속성 및/또는 그 의미가
          규범적으로 지정되는 과정에서 변경될 것으로 예상해야 한다. 구현자는
          구현을 설명하는 공개된 규격 없이 이러한 속성을 사용해서는 안 된다.
        </p>
        <p>
          다음 속성을 사용하는 방법과 관련된 충돌을 피하기 위해 구현에서는
          예약된 속성과 연결된 값에 `type` 속성을 반드시 지정해야 한다. `type`
          정보 추가와 관련된 자세한 내용은 섹션 <a href="#types"></a>을
          참조하라.
        </p>
        <p class="issue" title="워킹 그룹에서 고려 중인 확장 포인트">
          워킹 그룹은
          <a href="https://www.w3.org/ns/credentials/v2"
            >https://www.w3.org/ns/credentials/v2</a
          >에 추가 확장 포인트를 예약할지 논의 중이다.<br /><br />
          현재 워킹 그룹은 커뮤니티 그룹에서 초안 규격이 최소한 하나 이상 있는
          확장 포인트만 예약할 계획이다.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>예약된&nbsp;프로퍼티</th>
              <th>설명</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>`confidenceMethod`</td>
              <td>
                검증자가 검증가능한 크리덴셜이나 검증가능한 프레젠테이션의 속성
                값 또는 `initialRecipient`(일명 `issuee`), `presenter`,
                `authorizedPresenter`, `holder` 등의 속성이 정확하다는 확신을
                높이기 위해 사용할 수 있는 하나 이상의 방법을 지정하는 데
                사용되는 속성이다. 연결된 어휘 URL은 반드시
                `https://www.w3.org/2018/credentials#confidenceMethod`이어야
                한다.
                <p
                  class="issue"
                  title="(AT RISK) Reservation depends on implementations"
                >
                  이 속성 예약은 Candidate Recommendation 단계 종료까지 최소
                  하나의 규격과 두 개의 독립적인 구현이 입증되면 규격의 기존
                  섹션에 유리하게 삭제될 수 있다. 그렇지 않으면 이 예약은
                  남겠지만 규격의 기존 섹션은 제거될 것이다.
                  <a href="https://w3c-ccg.github.io/confidence-method-spec/"
                    >검증가능한 크리덴셜 신뢰 방법</a
                  >을 참조하라.
                </p>
              </td>
            </tr>
            <tr>
              <td>`evidence`</td>
              <td>
                크리덴셜을 발급하기 위해 제시된 증거를 지정하는 데 사용되는
                속성이다. 연결된 어휘 URL은 반드시
                `https://www.w3.org/2018/credentials#evidence`이어야 한다.
                <p
                  class="issue"
                  title="(AT RISK) Reservation depends on implementations"
                >
                  이 속성 예약은 Candidate Recommendation 단계 종료까지 최소
                  하나의 규격과 두 개의 독립적인 구현이 입증되면 규격의 기존
                  섹션에 유리하게 삭제될 수 있다. 그렇지 않으면 이 예약은
                  남겠지만 규격의 기존 섹션은 제거될 것이다.
                </p>
              </td>
            </tr>
            <tr>
              <td>`refreshService`</td>
              <td>
                크리덴셜을 새로 고칠 수 있는 방법을 지정하는 데 사용되는
                속성이다. 연결된 어휘 URL은 반드시
                `https://www.w3.org/2018/credentials#refreshService`이어야 한다.
                <p
                  class="issue"
                  title="(AT RISK) Reservation depends on implementations"
                >
                  이 속성 예약은 Candidate Recommendation 단계 종료까지 최소
                  하나의 규격과 두 개의 독립적인 구현이 입증되면 규격의 기존
                  섹션에 유리하게 삭제될 수 있다. 그렇지 않으면 이 예약은
                  남겠지만 규격의 기존 섹션은 제거될 것이다.
                </p>
              </td>
            </tr>
            <tr>
              <td>`renderMethod`</td>
              <td>
                크리덴셜을 시각적, 청각적 또는 촉각적 형식으로 렌더링하는 하나
                이상의 방법을 지정하는 데 사용되는 속성이다. 연결된 어휘 URL은
                반드시 `https://www.w3.org/2018/credentials#renderMethod`이어야
                한다.
                <p
                  class="issue"
                  title="(AT RISK) Reservation depends on implementations"
                >
                  이 예약된 속성은 위험하며, Candidate Recommendation 단계
                  종료까지 최소 하나의 규격과 두 개의 독립적인 구현이 입증되지
                  않으면 규격에서 제거될 것이다.
                  <a href="https://w3c-ccg.github.io/vc-render-method/"
                    >검증가능한 크리덴셜 렌더링 방법</a
                  >을 참조하라.
                </p>
              </td>
            </tr>
            <tr>
              <td>`termsOfUse`</td>
              <td>
                크리덴셜의 사용 약관을 지정하는 데 사용되는 속성이다. 연결된
                어휘 URL은 반드시
                `https://www.w3.org/2018/credentials#termsOfUse`이어야 한다.
                <p
                  class="issue"
                  title="(AT RISK) Reservation depends on implementations"
                >
                  이 속성 예약은 Candidate Recommendation 단계 종료까지 최소
                  하나의 규격과 두 개의 독립적인 구현이 입증되면 규격의 기존
                  섹션에 유리하게 삭제될 수 있다. 그렇지 않으면 이 예약은
                  남겠지만 규격의 기존 섹션은 제거될 것이다.
                </p>
              </td>
            </tr>
          </tbody>
        </table>

        <p>
          이 규격에 정의된 확장 포인트 및 이 섹션에 정의된 예약된 확장 포인트와
          관련된 규격의 비공식 목록은 검증가능한 크리덴셜 규격 디렉터리
          [[?VC-SPECS]]에서 찾을 수 있다. 예약된 확장 포인트를 참조하는
          디렉터리의 항목은 실험적인 것으로 취급해야 한다.
        </p>
      </section>

      <section class="normative">
        <h3>생태계 호환성(Ecosystem Compatibility)</h3>

        <p>
          이 문서에서 제공하는 데이터 모델을 기본적으로 사용하지 않지만 이
          규격의 여러 개념과 일치하는 여러 디지털 크리덴셜 형식이 있다. 출판
          당시 이러한 디지털 크리덴셜 형식의 예로는
          <a href="https://www.rfc-editor.org/rfc/rfc7519.html">JSON 웹 토큰</a
          >(JWT),
          <a href="https://www.rfc-editor.org/rfc/rfc8392.html">CBOR 웹 토큰</a
          >(CWT),
          <a href="https://www.iso.org/standard/69084.html">ISO-18013-5:2021</a
          >(mDL),
          <a href="https://hyperledger.github.io/anoncreds-spec/">AnonCreds</a>,
          <a href="https://datatracker.ietf.org/doc/draft-mcnally-envelope/"
            >Gordian Envelopes</a
          >,
          <a href="https://datatracker.ietf.org/doc/draft-ssmith-acdc/"
            >Authentic Chained Data Containers</a
          >(ACDC) 등이 있다.
        </p>

        <p>
          개념적으로 일치하는 디지털 크리덴셜 형식이 이 섹션에서 제공하는 규칙에
          따라 [=적합한 문서=]로 변환될 수 있는 경우
          <em>"W3C 검증가능한 크리덴셜 생태계와 호환된다"</em>고 간주된다.
          검증가능한 크리덴셜 생태계와의 호환성을 가능하게 하는 변환 방법을
          설명하는 규격은 다음과 같다:
        </p>

        <ul>
          <li>
            이 데이터 모델로의 변환이 단방향만 가능한지 아니면 왕복 가능한지
            식별해야 한다.
          </li>
          <li>왕복 가능한 변환을 수행할 때 `@context` 값을 보존해야 한다.</li>
          <li>
            이 규격에 설명된 데이터 모델로 변환할 때 [=적합한 문서=]가 되어야
            한다.
          </li>
          <li>입력 문서에 대해 등록된 미디어 유형을 지정해야 한다.</li>
          <li>
            이 규격의 데이터 모델에 대해 지정된 변환 알고리즘이 [=적합한
            문서=]를 생성함을 보여주는 테스트 스위트를 제공해야 한다.
          </li>
          <li>
            변환된 [=적합한 문서=]에서 사용되는 모든 의미론이 연결된 데이터에
            대한 모범 사례를 따르도록 해야 한다. 추가 지침은 섹션
            <a href="#getting-started"></a>, 섹션
            <a href="#extensibility"></a> 및 연결된 데이터 모범 사례
            [[?LD-BP]]를 참조하라.
          </li>
        </ul>

        <p class="note" title="검증가능한 크리덴셜을 구성하는 것">
          디지털 크리덴셜은 [=적합한 문서=]이고 이 규격에서 각각의 요구사항에
          따라 설명된 최소한 하나의 보안 메커니즘을 활용하는 경우에만 W3C
          검증가능한 크리덴셜 생태계와 호환되는 것으로 간주된다는 점을 독자에게
          안내한다. 일부 커뮤니티에서는 [=적합한 문서=]가 아닌 일부 디지털
          크리덴셜 형식을 "검증가능한 크리덴셜"이라고 부를 수 있지만, 그렇게
          한다고 해서 해당 디지털 크리덴셜이 이 규격을 준수하는 것은 아니다.
        </p>
      </section>

      <section>
        <h3>검증가능한 크리덴셜 그래프(Verifiable Credential Graphs)</h3>

        <p>
          [=검증가능한 크리덴셜=]을 표현할 때(예: [=프레젠테이션=]에서) 한
          [=검증가능한 크리덴셜=]의 데이터가 다른 [=검증가능한 크리덴셜=]의
          동일한 데이터로 오인되지 않도록 하는 것이 중요하다. 예를 들어, 각각
          `{"type": "Person", "name": "Jane Doe"}` 형식의 객체를 포함하는 두
          개의 [=검증가능한 크리덴셜=]이 있는 경우, 한 객체가 다른 객체와 동일한
          사람을 설명하고 있는지 알 수 없다. 즉, 동일한 엔티티 및/또는 속성에
          대해 논의하고 있는지 확인하지 않고 두 [=검증가능한 크리덴셜=] 간에
          데이터를 병합하면 데이터 세트가 손상될 수 있다.
        </p>
        <p>
          서로 다른 [=검증가능한 크리덴셜=]의 데이터가 실수로 섞이지 않도록 하기
          위해 각 [=검증가능한 크리덴셜=]을 캡슐화하기 위해
          <dfn
            class="export"
            data-lt="verifiable credential graph|검증가능한 크리덴셜 그래프"
            >검증가능한 크리덴셜 그래프</dfn
          >
          개념이 사용된다. 간단한 [=검증가능한 크리덴셜=]의 경우, 즉 JSON-LD
          문서에 단일 크리덴셜과 관련 증명이 포함된 경우 이 그래프는 [=기본
          그래프=]이다. [=프레젠테이션=]의 경우 [=프레젠테이션=]의
          `verifiableCredential` 속성과 연결된 각 값은 단일 [=검증가능한
          크리덴셜=] 또는
          <a href="#enveloped-verifiable-credentials"
            >봉인된 검증가능한 크리덴셜</a
          >을 포함하는 유형
          <dfn class="export">VerifiableCredentialGraph</dfn>의 별도 [=명명된
          그래프=]이다.
        </p>
        <p>
          이러한 [=그래프=]를 사용하면 JSON-LD 처리를 수행할 때 구체적인 효과가
          있으며, 한 그래프의 그래프 노드 식별자를 다른 그래프의 식별자와 적절히
          분리한다. 애플리케이션별 JSON-LD 문서로 입력을 제한하는 구현자는
          `credentialSubject.id`가 두 [=검증가능한 크리덴셜=]에서 동일하지만
          객체가 이전 단락에서 설명한 "Jane Doe" 형식의 객체를 포함할 수 있는
          경우와 같이 한 [=검증가능한 크리덴셜=]의 데이터를 다른 데이터와 병합할
          때 이 점을 명심해야 한다. URL과 같은 전역 식별자를 사용하는 `id`
          속성을 포함하지 않지만 유사한 속성을 가진 것처럼 보이는 객체를
          병합하지 않는 것이 중요하다.
        </p>
      </section>

      <section>
        <h3>보안 메커니즘 규격(Securing Mechanism Specifications)</h3>

        <p>
          섹션 <a href="#securing-mechanisms"></a>에 설명된 대로 구현자가
          [=적합한 문서=]를 보호할 때 사용할 수 있는 여러 전략이 있다. 유용성과
          상호운용성을 최대화하기 위해 [=적합한 문서=]를 보호하는 새로운 방법을
          작성하려는 규격 저자에게 이 섹션의 지침이 제공된다.
        </p>
        <p>
          보안 메커니즘 규격은 [=적합한 문서=]에 대한 내용 무결성 보호를
          제공하는 규범적 알고리즘을 문서화해야 한다. 알고리즘은 일반적일 수
          있으며 [=적합한 문서=] 이외의 데이터를 보호하는 데 사용될 수 있다.
        </p>
        <p>
          보안 메커니즘 규격은 `proof` 또는 JOSE/COSE 헤더 매개변수 및 서명과
          같은 보안 메커니즘 정보를 포함하지 않고 보호된 [=적합한 문서=]의
          정보만 반환하는 검증 메커니즘을 제공해야 한다. 규격은 보안 메커니즘
          데이터와 같이 유용할 수 있는 다른 정보(예: 유효성 검사 중 또는 디버깅
          목적)를 전달하기 위한 추가 메커니즘을 제공할 수 있다. 보안 메커니즘의
          검증 알고리즘은 미디어 유형([=string=] |inputMediaType|)과 바이트
          시퀀스([=byte sequence=] |inputBytes|) 또는 문서([=map=]
          |inputDocument|) 중 하나와 쌍을 이루는 입력을 받아들이고 최소한 다음
          [=struct/items=]로 검증 결과를 반환하는 인터페이스를 제공해야 한다:
        </p>
        <dl>
          <dt>[=boolean=] |status|</dt>
          <dd>
            검증에 성공하면 값이 `true`이고 그렇지 않으면 `false`인 검증 상태.
          </dd>
          <dt>[=map=] |document|</dt>
          <dd>성공적으로 보호된 정보만 포함하는 문서.</dd>
          <dt>[=string=] |mediaType|</dt>
          <dd>[[RFC6838]]에 정의된 미디어 유형.</dd>
        </dl>

        <p
          class="issue atrisk"
          title="Controller document reference might change"
        >
          현재 작업 그룹은 [[[?DID-CORE]]], [[[?VC-DATA-INTEGRITY]]],
          [[[?VC-JOSE-COSE]]] 간의 컨트롤러 문서 정의를 조정하려고 시도하고
          있다. 목표는 앞서 언급한 각 규격과 이 규격에서 컨트롤러 문서와 관련된
          규범적 명세를 참조할 수 있는 하나의 규격을 갖는 것이다. 컨트롤러
          문서에 대한 규범적 참조는 Candidate Recommendation 단계에서 변경될
          것으로 예상된다.
        </p>

        <p>
          보안 메커니즘 규격은 유효성 검사에 중요한 URL로 참조되는 모든 정보에
          대한 무결성 보호를 제공해야 한다. 이러한 보호를 달성할 수 있는
          메커니즘은 섹션 <a href="#integrity-of-related-resources"></a>와 섹션
          <a href="#base-context"></a>에서 논의된다.
        </p>

        <p>
          새로운 유형의 [=내장된 증명=]을 생성하는 보안 메커니즘 규격은
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=] 모두를 보호하기
          위한 [=속성=]을 지정해야 한다. 내장된 보안 메커니즘에서 사용하는
          속성에 대한 요구사항은 다음과 같다:
        </p>

        <ul>
          <li>
            해당 속성은 [=검증가능한 크리덴셜=] 또는 [=검증가능한
            프레젠테이션=]을 분리 가능하고 보안 가능한 [=증명 그래프=]와
            연관시켜야 한다.
          </li>
          <li>
            해당 속성은 [=증명 그래프=]에서 사용되는 모든 용어를 정의해야 한다.
            예를 들어, 메커니즘은 이 규격에서 사용되는 것과 같은 방식으로 어휘
            규격과 `@context` 파일을 정의할 수 있다.
          </li>
          <li>
            [=검증가능한 크리덴셜=]에서 해당 속성은 [=기본 그래프=]를 보호해야
            한다.
          </li>
          <li>
            [=검증가능한 프레젠테이션=]에서 해당 속성은 [=프레젠테이션=]의
            [=기본 그래프=]와 [=프레젠테이션=]에 있는 각 [=검증가능한
            크리덴셜=]과 관련된 모든 [=증명 그래프=]를 보호해야 한다.
          </li>
          <li>
            [[VC-DATA-INTEGRITY]]에 정의된 `proof` 속성은 내장된 보안
            메커니즘에서 사용될 수 있다.
          </li>
        </ul>

        <p>
          보안 메커니즘 규격은 [[[?VC-SPECS]]] [[?VC-SPECS]]의
          <a data-cite="?VC-SPECS#securing-mechanisms">보안 메커니즘</a> 섹션에
          보안 메커니즘을 등록해야 한다.
        </p>

        <p class="note" title="보안 메커니즘의 선택은 사용 사례에 따라 다름">
          여러 가지 허용되는 보안 메커니즘이 있으며, 이 규격은 [=검증가능한
          크리덴셜=] 또는 [=검증가능한 프레젠테이션=]에 사용할 특정 보안
          메커니즘을 의무화하지 않는다. 이 규격을 작성한 작업 그룹은
          [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]와 [[[VC-JOSE-COSE]]]
          [[VC-JOSE-COSE]]의 두 가지 보안 메커니즘 옵션을 표준화했다. 커뮤니티에
          알려진 다른 보안 메커니즘은 [[[?VC-SPECS]]] [[?VC-SPECS]]의
          <a data-cite="?VC-SPECS#securing-mechanisms">보안 메커니즘</a>
          섹션에서 찾을 수 있다.
        </p>
      </section>
    </section>

    <section>
      <h2>구문(Syntaxes)</h2>

      <p>
        섹션 <a href="#core-data-model"></a>, <a href="#basic-concepts"></a>,
        <a href="#advanced-concepts"></a>에 설명된 데이터 모델은 [=검증가능한
        크리덴셜=] 또는 [=검증가능한 프레젠테이션=]의 정식 구조적 표현이다. 모든
        직렬화는 특정 형식으로 된 해당 데이터 모델의 표현이다. 이 섹션에서는
        검증가능한 크리덴셜의 기본 미디어 유형인 `application/vc+ld+json`에 대해
        JSON-LD에서 데이터 모델이 어떻게 실현되는지 지정한다. 구문 매핑은
        JSON-LD에 대해서만 제공되지만, 애플리케이션과 서비스는
        `application/vc+ld+json`에 다시 매핑될 수 있는 다른 모든 데이터 표현
        구문(예: XML, YAML 또는 CBOR)을 사용할 수 있다. [=검증=] 및 [=유효성
        검사=] 요구사항이 데이터 모델 측면에서 정의되므로, 모든 직렬화 구문은
        처리, [=유효성 검사=] 또는 비교를 위해 데이터 모델로 결정적으로
        변환되어야 한다.
      </p>
      <p>
        이 규격에서 속성 값의 예상 아리티(arity)와 그러한 값을 보유하는 결과
        데이터 유형은 속성에 따라 달라질 수 있다. 존재하는 경우 다음 속성은 단일
        값으로 표시된다:
      </p>
      <ul>
        <li>`id` [=속성=]</li>
        <li>`issuer` [=속성=]</li>
        <li>`validFrom` [=속성=]</li>
        <li>`validUntil` [=속성=].</li>
      </ul>
      <p>존재하는 경우 다른 모든 속성은 단일 값 또는 값의 배열로 표시된다.</p>

      <section>
        <h3>JSON-LD</h3>

        <p>
          [[!JSON-LD11]]은
          <a href="https://www.w3.org/TR/ld-glossary/#linked-data"
            >연결된 데이터</a
          >를 직렬화하는 데 사용되는 JSON 기반 형식이다. 연결된 데이터는
          RDF(Resource Description Framework)를 사용하여 모델링된다. RDF
          [[?RDF11-CONCEPTS]]는 명제 그래프를 모델링하는 기술이다. 각 명제는
          단일 <i>주어→속성→값</i> (또는 <i>엔티티→특성→값</i>으로 알려진)
          관계이며, 이 규격에서는 <a>클레임</a>이라고 한다. JSON-LD
          [[?JSON-LD11]]는 관용적 JSON을 사용하여 RDF를 표현할 수 있게 하는
          기술로, JSON에 익숙한 개발자가 RDF를 JSON으로 사용하는 애플리케이션을
          작성할 수 있게 한다. 일반적으로 주어는 JSON 객체로 표현되며, 주어의 각
          속성과 값은 각각 JSON 키와 값으로 표현된다. 필요한 경우 이 규격에서
          <code>id</code> 키를 사용하여 주어의 식별자를 표현하는 특별한 편의
          기능이 제공된다. 자세한 내용은
          <a data-cite="?JSON-LD11#relationship-to-rdf">RDF와 JSON-LD의 관계</a
          >를 참조하라.
        </p>
        <p>
          [[!JSON-LD11]]은 이 규격에 설명된 데이터 모델을 확장할 때 유용하다.
          데이터 모델의 인스턴스는 JSON-LD 압축 형식 [[!JSON-LD11]]으로
          인코딩되며 `@context` [=속성=]을 포함한다.
          <a href="https://www.w3.org/TR/json-ld/#the-context"
            >JSON-LD 컨텍스트</a
          >는 [[!JSON-LD11]] 규격에서 자세히 설명되며, 그 사용은 섹션
          <a href="#contexts"></a>와 섹션 <a href="#extensibility"></a>에서
          상세히 다룬다.
        </p>
        <p>
          여러 컨텍스트를 사용하거나 결합하여 [=검증가능한 크리덴셜=]에 대한
          임의의 정보를 관용적 JSON으로 표현할 수 있다.
          `https://www.w3.org/ns/credentials/v2`에서 사용할 수 있는
          <a href="https://www.w3.org/TR/json-ld/#the-context"
            >JSON-LD 컨텍스트</a
          >는 절대 업데이트되지 않는 정적 문서이므로 클라이언트 측에서
          다운로드하여 캐시할 수 있다. 검증가능한 크리덴셜 데이터 모델과 관련된
          어휘 문서는 `https://www.w3.org/2018/credentials`에서 사용할 수 있다.
        </p>
        <p>
          이 규격은 데이터 모델의 JSON-LD 표현 사용을 제한한다. 기본 미디어
          유형인 `application/vc+ld+json`에서 데이터 모델의 모든 표현에는
          JSON-LD
          <a href="https://www.w3.org/TR/json-ld/#compacted-document-form"
            >압축 문서 형식</a
          >을 반드시 사용해야 한다.
        </p>
        <p>
          섹션 <a href="#type-specific-credential-processing"></a>에서 자세히
          설명한 것처럼, 일부 소프트웨어 애플리케이션은 일반화된 JSON-LD 처리를
          수행하지 않을 수 있다. [=적합한 문서=] 저자는 `@context` 값의 JSON-LD
          키워드가 `@base` 키워드를 전역적으로 설정하는 것과 같이 [=검증가능한
          크리덴셜=] 또는 [=검증가능한 프레젠테이션=]의 값에 전역적으로 영향을
          미치는 데 사용되는 경우 상호운용성이 감소할 수 있다는 점에 유의해야
          한다. 예를 들어, 이러한 값을 전역적으로 설정하면 [=유형별 크리덴셜
          처리=]를 수행하고 `@context` 값에 `@base` 값이 표현되는 것을 예상하지
          않는 구현에서 `@context` 값에 대한 JSON 스키마 검사가 실패할 수 있다.
        </p>
        <p>
          상호운용성을 높이기 위해 [=적합한 문서=] 저자는 [=유형별 크리덴셜
          처리=]를 수행할 때 쉽게 감지되지 않는 JSON-LD 기능을 사용하지 않는
          것이 좋다. 이러한 기능은 다음과 같다:
        </p>
        <ul>
          <li>
            `@base`의 전역 설정과 같이 문서 값 처리를 전역적으로 수정하는
            `@context` 값의 JSON-LD 키워드 사용
          </li>
          <li>`@context` 속성에서 JSON-LD 컨텍스트의 인라인 선언.</li>
          <li>
            JSON-LD 용어 및 유형(예:
            `https://www.w3.org/2018/credentials#VerifiableCredential` 또는
            `https://vocab.example/myvocab#SomeNewType`)에 전체 URL을 사용하는
            대신 JSON-LD `@context` 매핑(예:
            `https://www.w3.org/ns/credentials/v2`)으로 명시적으로 정의되거나
            정의되지 않은 모든 용어에 적용되는 `@vocab` 기능을 통해 암시적으로
            정의된 해당 값의 짧은 형식(예: `VerifiableCredential` 또는
            `SomeNewType`) 사용.
          </li>
        </ul>

        <section>
          <h3>Syntactic Sugar</h3>

          <p>
            일반적으로 이 문서에 설명된 데이터 모델과 구문은 개발자가 예제를
            복사하여 붙여넣어 자신의 소프트웨어 시스템에 [=검증가능한
            크리덴셜=]을 통합할 수 있도록 설계되었다. 이 접근 방식의 설계 목표는
            이질적인 소프트웨어 시스템 간의 전역적 상호운용성을 보장하면서도
            진입 장벽을 낮추는 것이다. 이 섹션에서는 대부분의 개발자는
            알아차리지 못하겠지만 구현자에게는 관심 있는 세부 사항인 이러한 접근
            방식 중 일부에 대해 설명한다. [[!JSON-LD11]]에서 제공하는 가장
            주목할 만한 구문적 설탕은 다음과 같다:
          </p>
          <ul>
            <li>
              `@id`와 `@type` 키워드는 각각 `id`와 `type`으로 별칭되어 개발자가
              이 규격을 관용적 JSON으로 사용할 수 있다.
            </li>
            <li>
              정수, 날짜, 측정 단위 및 URL과 같은 데이터 유형은 이를 필요로 하는
              사용 사례에 대해 더 강력한 유형 보장을 제공하기 위해 자동으로
              유형이 지정된다.
            </li>
            <li>
              `verifiableCredential` [=속성=]은
              <a href="https://www.w3.org/TR/json-ld11/#graph-containers"
                >JSON-LD 1.1 그래프 컨테이너</a
              >로 정의된다. 이를 위해서는 서로 다른 엔티티에 의해 주장된 데이터
              세트를 분리하는 데 사용되는 [=명명된 그래프=]를 생성해야 한다.
              예를 들어, 이는 각 그래프의 정보 출처가 보존되도록 각 [=발급자=]가
              제공하는 데이터 그래프와 [=검증가능한 크리덴셜=]을 제시하는
              [=보유자=]가 제공하는 데이터 그래프 간에 적절한 암호화 분리를
              보장한다.
            </li>
            <li>
              [[!JSON-LD11]] 1.1의 `@protected` 속성 기능은 이 규격에서 정의한
              용어를 재정의할 수 없도록 하는 데 사용된다. 즉, [=검증가능한
              크리덴셜=] 또는 [=검증가능한 프레젠테이션=] 맨 위에 동일한
              `@context` 선언이 이루어지는 한, [[!JSON-LD11]] 프로세서를
              사용하든 사용하지 않든 데이터 모델 사용자가 이해하는 모든 용어에
              대해 상호운용성이 보장된다.
            </li>
          </ul>
        </section>
        <section>
          <h3>목록과 배열</h3>
          <p>
            [[JSON-LD11]] 1.1을 사용할 때는 목록, 배열, 심지어 목록의 목록도
            가능하다. 목록과 배열이 필요한 사용 사례에서 RDF 의미론을 원하는
            사람들은
            <a href="https://www.w3.org/TR/json-ld11/#lists"
              >JSON-LD 1.1의 목록</a
            >에 대한 지침을 따르는 것이 좋다.
          </p>
          <p>
            일반적으로 JSON 배열은 순서가 있지만, JSON-LD 배열은 `@list`
            키워드를 사용하지 않는 한 순서가 없다.
          </p>
          <p class="note">
            JSON-LD 처리 없이 이 데이터 모델을 사용하는 것이 가능하지만, 그렇게
            하고 배열을 사용하는 사람들은 위의 지침을 따르지 않는 한 JSON-LD에서
            배열의 항목 순서를 보장할 수 없다는 점을 알아야 한다. 이는 예기치
            않은 동작으로 이어질 수 있다.
          </p>
          <p>
            애플리케이션에서 JSON 구조나 순서가 중요한 경우 `@context`를 통해
            그러한 요소에 `@json`으로 표시할 것을 권장한다.
          </p>
          <pre
            class="example"
            title="A @context file that defines a matrix as an embedded JSON data structure"
          >
{
  "@context":
    {
      "matrix": {
        "@id": "https://website.example/vocabulary#matrix",
        "@type": "@json"
      }
    }
}
          </pre>
          <pre
            class="example"
            title="A verifiable credential with an embedded JSON data structure"
          >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://website.example/matrix/v1"
  ],
  "id": "http://university.example/credentials/1872",
  "type": [
    "VerifiableCredential",
    "ExampleMatrixCredential"
  ],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "matrix": [
      [1,2,3,4,5,6,7,8,9,10,11,12],
      [1,1,1,1,1,1,1,1,0,0,0,0],
      [0,0,1,1,1,1,1,1,1,0,0,0]
    ]
  }
}
          </pre>
        </section>
      </section>
      <section>
        <h3>미디어 유형(Media Types)</h3>

        <p>
          [[RFC6838]]에 정의된 미디어 유형은 [=검증가능한 크리덴셜=]을 표현하는
          데 사용되는 구문과 기타 유용한 처리 지침을 식별한다.
        </p>
        <p>
          이 규격의 데이터 모델을 표현하는 데 사용되는 구문은 미디어 유형으로
          식별되어야 하며, [=검증가능한 크리덴셜=]로 미디어 유형을 정의하거나
          사용할 때는 이 섹션에 설명된 규칙을 따라야 한다.
        </p>
        <p>
          섹션 <a href="#iana-considerations"></a>에 나열된 핵심 데이터 모델과
          관련된 두 가지 미디어 유형이 있다: `application/vc+ld+json`과
          `application/vp+ld+json`.
        </p>
        <p>
          `application/vc+ld+json`과 `application/vp+ld+json` 미디어 유형은 특정
          보안 메커니즘을 의미하지 않지만, 보안 메커니즘과 함께 사용하기 위한
          것이다. 이러한 미디어 유형의 무결성을 보호하려면 보안 메커니즘을
          적용해야 한다. 콘텐츠를 전달하는 데 사용되는 미디어 유형에 관계없이
          콘텐츠의 보안을 가정하지 마라.
        </p>

        <section class="informative">
          <h3>미디어 유형 정밀도(Media Type Precision)</h3>

          <p>
            때로는 개발자나 시스템이 [=검증가능한 크리덴셜=] 또는 [=검증가능한
            프레젠테이션=]을 전달하기 위해 정밀도가 낮은 미디어 유형을 사용할 수
            있다. 정밀도가 낮은 미디어 유형을 사용하는 이유에는 다음이 포함된다:
          </p>

          <ul>
            <li>
              파일 확장자를 사용할 수 없고 미디어 유형을 결정할 수 없는 경우 웹
              서버는 기본적으로 `text/plain` 또는 `application/octet-stream`을
              사용한다.
            </li>
            <li>
              개발자가 파일 내용보다 덜 구체적인 미디어 유형으로 이어지는 파일
              확장자를 추가한다. 예를 들어, `.json`은 `application/json` 미디어
              유형으로 이어질 수 있고 `.jsonld`는 `application/ld+json` 미디어
              유형으로 이어질 수 있다.
            </li>
            <li>
              프로토콜에서 특정 트랜잭션에 대해 `application/vp+ld+json` 대신
              `application/json`과 같이 정밀도가 낮은 미디어 유형이 필요하다.
            </li>
          </ul>

          <p>
            페이로드에서 의도한 미디어 유형을 결정할 수 있고 사용된 미디어
            유형이 주어진 프로토콜에서 허용되는 경우, 구현자는 오류를 발생시키지
            않도록 해야 한다. 예를 들어, 애플리케이션이 `application/vc+ld+json`
            미디어 유형과 관련된 규칙을 준수하는 페이로드만 허용하지만,
            페이로드가 대신 `application/json` 또는 `application/ld+json`으로
            태그되어 있는 경우, 애플리케이션은 페이로드가 더 높은 정밀도의
            미디어 유형도 준수하는지 확인하기 위해 다음 단계를 수행할 수 있다:
          </p>
          <ol>
            <li>페이로드를 JSON 문서로 파싱한다.</li>
            <li>
              `@context` 필드의 첫 번째 요소가
              `https://www.w3.org/2018/credentials/v2`와 일치하는지 확인한다.
            </li>
            <li>
              JSON 문서에 `VerifiablePresentation` 요소를 포함하는 최상위 `type`
              필드가 있는 경우 `application/vp+ld+json` 미디어 유형을 가정한다.
              페이로드가 적합한 검증가능한 프레젠테이션을 표현하는지 확인하기
              위해 추가적인 후속 검사가 여전히 수행될 것으로 예상된다(이 규격에
              따라).
            </li>
            <li>
              JSON 문서에 `VerifiableCredential` 요소를 포함하는 최상위 `type`
              필드가 있는 경우 `application/vc+ld+json` 미디어 유형을 가정한다.
              페이로드가 적합한 검증가능한 크리덴셜을 표현하는지 확인하기 위해
              추가적인 후속 검사가 여전히 수행될 것으로 예상된다(이 규격에
              따라).
            </li>
          </ol>
          <p>
            가능할 때마다 구현자는 이 규격에서 정의한 모든 페이로드에 가장
            정밀한(가장 높은 정밀도) 미디어 유형을 사용하는 것이 좋다. 또한
            구현자는 정밀도가 낮은 미디어 유형으로 태그된 페이로드가 더 높은
            정밀도 유형으로 태그하는 데 필요한 규칙을 충족하지 않는다는 의미는
            아님을 인식해야 한다. 마찬가지로 정밀도가 높은 미디어 유형으로
            태그된 페이로드가 해당 미디어 유형과 관련된 요구사항을 충족한다는
            의미는 아니다. 페이로드의 수신자는 관련 미디어 유형에 관계없이
            페이로드가 특정 시스템에서 사용하기 위한 요구사항을 준수하는지
            확인하기 위해 적절한 검사를 수행할 것으로 예상된다.
          </p>
        </section>
        <section class="informative">
          <h2>HTTP</h2>
          <p>
            HTTP 엔드포인트는 accept 헤더와 콘텐츠 유형을 나타낼 때 [=검증가능한
            크리덴셜=]과 [=검증가능한 프레젠테이션=]과 관련된 미디어 유형을
            사용할 것으로 예상된다.
          </p>
          <p>
            그럼에도 불구하고 HTTP 서버는 accept 헤더를 무시하고 다른 콘텐츠
            유형을 반환하거나
            <a data-cite="RFC7231#section-6.5.13"
              >`415 Unsupported Media Type`</a
            >과 같은 오류 코드를 반환할 수 있다.
          </p>
        </section>
      </section>

      <section class="informative">
        <h2 id="type-specific-credential-processing">유형별 크리덴셜 처리</h2>

        <p>
          JSON은 다양한 종류의 정보를 표현하는 데 사용될 수 있으므로, 특정 JSON
          문서의 소비자는 다른 가능한 표현과 구별되는 맥락 정보를 가지고 있는
          경우에만 작성자의 의도를 올바르게 해석할 수 있다. 이 해석을 돕기 위한
          정보는 JSON 문서와 완전히 외부에 있거나 내부에서 연결될 수 있다.
          압축된 JSON-LD 문서에는 <a>클레임</a>을 표현하기 위해 맥락 정보를
          내부적으로 표현하거나 연결하는 <code>@context</code> 속성이 포함된다.
          이러한 기능을 통해 JSON-LD 문서를 한 맥락에서 다른 맥락으로 변환하는
          일반화된 프로세서를 작성할 수 있지만, 소비자가 이미 예상하는 맥락과
          모양을 사용하는 JSON-LD 문서를 받을 때는 이것이 필요하지 않다.
          <a>검증가능한 크리덴셜</a>의 <a>발급자</a>와 같은 JSON-LD 문서의
          작성자는 상호운용성을 촉진하기 위해 적절한 JSON-LD 맥락을 제공하고
          이러한 규칙을 따라야 한다.
        </p>
        <p>
          아래 텍스트는 소비자가 JSON-LD 문서가 해당 애플리케이션이 이미
          이해하는 맥락과 모양으로 표현되어 내용을 소비하기 위해 변환할 필요가
          없도록 하는 방법을 이해하는 데 도움이 된다. 특히 이것은 소비자가
          맥락을 전혀 이해할 필요가 없다는 것을 의미하지는 않는다. 오히려 소비
          애플리케이션은 작업할 맥락과 문서 모양의 선택된 집합만 이해하면 되고
          다른 것은 이해할 필요가 없다. 발급자는 일반화된 프로세서를 사용하지
          않는 소비자를 돕기 위해 다른 JSON 형식 데이터와 마찬가지로
          <a>검증가능한 크리덴셜</a>에 대한 맥락과 정보를 게시할 수 있다.
        </p>
        <p>
          <dfn>일반 JSON-LD 처리</dfn>는 JSON-LD 소프트웨어 라이브러리를
          활용하여 다양한 <a data-cite="?JSON-LD11#forms-of-json-ld">변환</a>을
          수행함으로써 [=적합한 문서=]를 처리하는 메커니즘으로 정의된다.
          <dfn>유형별 크리덴셜 처리</dfn>는 JSON-LD 소프트웨어 라이브러리가
          필요하지 않은 [=적합한 문서=]를 처리하기 위한 더 가벼운 메커니즘으로
          정의된다. 일부 [=검증가능한 크리덴셜=] 소비자는 특정 유형의 크리덴셜만
          소비하면 된다. 이러한 소비자는 일반화된 처리 대신 유형별 크리덴셜
          처리를 사용할 수 있다. 유형별 크리덴셜 처리가 바람직할 수 있는
          시나리오에는 다음이 포함되지만 이에 국한되지는 않는다:
        </p>

        <ul>
          <li>
            [=적합한 문서=]에 보안 메커니즘을 적용하기 전이나 보안 메커니즘으로
            보호된 [=적합한 문서=]를 검증한 후
            <a href="https://csrc.nist.gov/glossary/term/data_integrity"
              >데이터 무결성</a
            >을 보장하기 위해.
          </li>
          <li>
            섹션 <a href="#data-schemas"></a>에 설명된 대로 JSON 스키마 유효성
            검사를 수행할 때.
          </li>
          <li>
            [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]을 내용을
            저장하거나 색인하는 시스템으로 직렬화하거나 역직렬화할 때.
          </li>
          <li>
            [=일반 JSON-LD 처리=]가 필요한 보안 메커니즘에 대해 검증 또는 유효성
            검사가 수행된 후 소프트웨어 애플리케이션에서 [=검증가능한 크리덴셜=]
            또는 [=검증가능한 프레젠테이션=]에 대해 작업할 때.
          </li>
          <li>
            애플리케이션이 `+json` 구조화된 미디어 유형 접미사를 사용하여 미디어
            유형을 처리하도록 선택할 때.
          </li>
        </ul>

        <p>
          즉, 소비되거나 생성되는 문서가 [=적합한 문서=]인 한 [=유형별 크리덴셜
          처리=]가 허용된다. 이러한 유형의 처리가 원하는 경우 구현자는 다음
          규칙을 따르는 것이 좋다:
        </p>

        <ul>
          <li>
            `@context` 속성과 연결된 모든 값이 예상 순서대로 있고, 각 파일에
            대한 컨텍스트 파일의 내용이 알려진 양호한 암호화 해시와 일치하며,
            도메인 전문가가 내용이 의도한 사용 사례에 적합하다고 판단했는지
            확인한다.
          </li>
        </ul>

        <p>
          JSON 스키마와 함께 정적 컨텍스트 파일을 사용하는 것은 위의 규칙을
          구현하는 한 가지 허용되는 접근 방식이다. 이는 [=유형별 크리덴셜
          처리=]를 수행할 때 적절한 용어 식별, 입력 및 순서를 보장할 수 있다.
        </p>

        <p>
          위의 규칙은 `@context` 메커니즘을 통해 리터럴 JSON 키를 URI에 매핑하는
          두 가지 처리 메커니즘 간의 의미론적 상호운용성을 보장한다. [=일반
          JSON-LD 처리=]는 해당 알고리즘에서 제공하는 이전에 보지 못한
          `@context` 값을 사용하여 모든 용어가 올바르게 지정되었는지 확인할 수
          있지만, [=유형별 크리덴셜 처리=]를 수행하는 구현은 구현이 미리
          이해하도록 설계된 특정 `@context` 값만 허용하므로 JSON-LD API를
          호출하지 않고도 동일한 의미론을 얻을 수 있다. 즉, 데이터 교환이
          발생하는 맥락은 동일한 [=적합한 문서=] 의미론으로 이어지는 방식으로
          `@context`를 사용하여 두 처리 메커니즘에 대해 명시적으로 명시된다.
        </p>
      </section>
    </section>

    <section class="normative">
      <h2>알고리즘</h2>

      <p>
        이 섹션에는 구현에서 검증과 같은 일반적인 작업을 수행하는 데 사용할 수
        있는 알고리즘이 포함되어 있다. 알고리즘으로 표현되는 적합성 요구사항은
        [[[INFRA]]] [[INFRA]]의 규범적 개념을 활용한다. 구현 요구사항에 대한
        자세한 지침은 [[[INFRA]]]의
        <a data-cite="INFRA#conformance">적합성</a> 섹션을 참조하라.
      </p>

      <p class="issue atrisk" title="후보 권장안 전에 해결해야 할 이슈">
        이 섹션과 관련된 이슈 하나가 있으며, 이는 Working Group이 Candidate
        Recommendation 단계로 넘어가기 전에 해결되어야 한다. 해당 이슈가 해결될
        때까지 이 전체 섹션은 위험하다.
      </p>

      <p class="issue" data-number="1377"></p>

      <p
        class="note"
        title="구현자는 추가 검사, 경고 및 오류를 포함할 수 있다."
      >
        구현자는 이 섹션의 알고리즘에 구현이 이 규격에 대한 적합성을 테스트하는
        데 사용되는 최소한의 검사 세트가 포함되어 있음을 알아야 한다. 구현은
        잠재적인 문제를 디버깅하는 데 도움이 되는 개발자에게 유용한 경고를
        보고하는 추가 검사를 제공할 것으로 예상된다. 마찬가지로 구현은 유해한
        콘텐츠를 차단하기 위해 새로운 유형의 오류가 보고될 수 있는 추가 검사를
        제공할 가능성이 있다. 이러한 추가 검사는 이 규격의 향후 버전에 통합될 수
        있다.
      </p>

      <section class="normative">
        <h3>검증</h3>

        <p>
          이 섹션에는 [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]을
          검증할 때 [=적합한 검증자 구현=]이 실행해야 하는 알고리즘이 포함되어
          있다. 이 알고리즘은 미디어 유형([=string=] |inputMediaType|)과 바이트
          시퀀스([=byte sequence=] |inputBytes|) 또는 문서([=map=]
          |inputDocument|) 중 하나와 쌍을 이루는 입력을 받아 다음을 포함하는
          [=map=]을 반환한다:
        </p>

        <ul>
          <li>상태([=boolean=] |status|)</li>
          <li>[=적합한 문서=]([=map=] |document|)</li>
          <li>미디어 유형([=string=] |mediaType|)</li>
          <li>
            보안 메커니즘과 연결된 검증 방법의 컨트롤러([=string=] |controller|)
          </li>
          <li>
            보안 메커니즘을 검증하는 데 사용되는 검증 방법과 연결된 컨트롤러
            문서([=map=] |controllerDocument|)
          </li>
          <li>0개 이상의 경고([=list=] of [=ProblemDetails=] |warnings|)</li>
          <li>0개 이상의 오류([=list=] of [=ProblemDetails=] |errors|)</li>
        </ul>

        <p>검증 알고리즘은 다음과 같다:</p>

        <ol class="algorithm">
          <li>
            보안 메커니즘이 다음 단계를 수행하여 [=적합한 문서=]를 적절히
            보호했는지 확인한다:
            <ol class="algorithm">
              <li>
                |inputMediaType|과 [[[?VC-SPECS]]] [[?VC-SPECS]]의
                <a data-cite="?VC-SPECS#securing-mechanisms">보안 메커니즘</a>
                섹션 또는 구현에 알려진 다른 메커니즘을 사용하여 보안 메커니즘을
                검증할 때 사용할 암호화 스위트를 결정하기 위해 |verifyProof|
                함수를 설정한다. |verifyProof| 함수는 반드시
                <a href="#securing-mechanisms"></a>에 설명된 인터페이스를
                구현해야 한다.
                <div
                  class="issue"
                  title="'결정'을 위한 메커니즘이 상세히 설명되고 있음"
                >
                  현재 작업 그룹은 "결정"을 위한 알고리즘을 보다 공식적으로
                  정의해야 할 수도 있다고 우려하고 있다. 현재 어떤 구현도 사용할
                  적절한 |verifyProof| 알고리즘을 결정하는 데 문제가 없었지만,
                  작업 그룹은 여기에 더 많은 것을 말하는 것이 가치가 있는지
                  확인하려고 시도하고 있다. 구현이 허용 가능한 암호화 스위트의
                  허용 목록을 가질 수 있으며, 이는 검증할 일치하는 증명을 찾기
                  위한 입력으로 사용될 것이라는 추가 예제 언어를 추가할 수 있다.
                </div>
              </li>
              <li>
                |inputBytes|와 |inputMediaType|을 |verifyProof| 함수에 전달한
                결과를 |result|에 설정한다. 호출에 성공하면 |result|에는
                |status|, |document|, |mediaType|, |controller|,
                |controllerDocument|, |warnings| 및 |errors| 속성이 포함된다.
              </li>
              <li>
                |result|.|status|가 `false`로 설정된 경우
                <a href="#CRYPTOGRAPHIC_SECURITY_ERROR"
                  >CRYPTOGRAPHIC_SECURITY_ERROR</a
                >를 |result|.|errors|에 추가한다.
              </li>
            </ol>
          </li>
          <li>
            |result|.|status|가 `true`로 설정된 경우 |result|.|document|가
            [=적합한 문서=]인지 확인한다. 그렇지 않은 경우 |result|.|status|를
            `false`로 설정하고 |result|에서 |document| 속성을 제거하고
            |result|.|errors|에 하나 이상의
            <a href="#MALFORMED_VALUE_ERROR">MALFORMED_VALUE_ERROR</a>를
            추가한다. 디버깅 프로세스를 돕기 위해 다른 경고와 오류가 포함될 수
            있다.
          </li>
          <li>|result|를 반환한다.</li>
        </ol>

        <p>
          보안 메커니즘의 상태를 검증하고 입력 문서가 [=적합한 문서=]인지
          검증하는 단계는 구현이 동일한 잘못된 입력에 대해 오류를 반환하는 한
          위에서 제공한 것과 다른 순서로 수행될 수 있다. 구현은 위에서 설명한
          것과 다른 오류를 생성할 수 있다.
        </p>
      </section>

      <section>
        <h3>문제 세부 정보</h3>

        <p>
          구현이 문서 처리 중 이상을 감지하면 <dfn>ProblemDetails</dfn> 객체를
          사용하여 다른 소프트웨어 시스템에 문제를 보고할 수 있다. 이러한 유형의
          객체에 대한 인터페이스는 [[RFC9457]]을 따라 데이터를 인코딩한다.
          [=ProblemDetails=] 객체는 다음 속성으로 구성된다:
        </p>

        <dl>
          <dt>type</dt>
          <dd>
            `type` [=속성=]은 반드시 있어야 하며, 그 값은 문제의 유형을 식별하는
            [=URL=]이어야 한다.
          </dd>
          <dt>code</dt>
          <dd>
            `code` [=속성=]은 선택 사항이다. 존재하는 경우 그 값은 문제의 유형을
            식별하는 정수여야 한다. 정수 코드는 정수 반환 값만 제공하는
            시스템에서 유용하다.
          </dd>
          <dt>title</dt>
          <dd>
            `title` [=속성=]은 반드시 있어야 하며, 그 값은 문제에 대한 짧지만
            구체적인 사람이 읽을 수 있는 문자열을 제공해야 한다.
          </dd>
          <dt>detail</dt>
          <dd>
            `detail` [=속성=]은 반드시 있어야 하며, 그 값은 문제에 대한 더 긴
            사람이 읽을 수 있는 문자열을 제공해야 한다.
          </dd>
        </dl>

        <p>다음 문제 설명 유형과 코드는 이 규격에서 정의한다:</p>

        <dl>
          <dt id="PARSING_ERROR">
            https://www.w3.org/TR/vc-data-model#PARSING_ERROR (-64)
          </dt>
          <dd>입력 파싱 중 오류가 발생했다.</dd>
          <dt id="CRYPTOGRAPHIC_SECURITY_ERROR">
            https://www.w3.org/TR/vc-data-model#CRYPTOGRAPHIC_SECURITY_ERROR
            (-65)
          </dt>
          <dd>
            문서의 보안 메커니즘이 문서가 생성된 이후 문서 내용의 변경을
            감지했다. 잠재적인 변조가 감지되었다. 섹션
            <a href="#verification"></a>을 참조하라.
          </dd>
          <dt id="MALFORMED_VALUE_ERROR">
            https://www.w3.org/TR/vc-data-model#MALFORMED_VALUE_ERROR (-66)
          </dt>
          <dd>
            특정 [=속성=]과 연결된 값의 형식이 잘못되었다. [=속성=]의 이름과
            속성에 대한 경로를 [=ProblemDetails=] 객체에 제공해야 한다. 섹션
            <a href="#verification"></a>을 참조하라.
          </dd>
          <dt id="RANGE_ERROR">
            https://www.w3.org/TR/vc-data-model#RANGE_ERROR (-67)
          </dt>
          <dd>
            제공된 값이 연결된 값의 예상 범위를 벗어났다. 예를 들어, 배열에 대해
            주어진 인덱스 값이 배열의 현재 크기보다 크다.
          </dd>
        </dl>

        <p>
          구현은 추가 유형, 코드 또는 속성을 지정하여 [=ProblemDetails=] 객체를
          확장할 수 있다. 이 메커니즘 사용에 대한 추가 지침은 [[RFC9457]]의
          <a data-cite="RFC9457#name-extension-members">확장 멤버</a> 섹션을
          참조하라.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2 id="privacy-considerations">개인정보 보호 고려사항</h2>
      <p>
        이 섹션에서는 검증가능한 크리덴셜 데이터 모델을 프로덕션 환경에 배포할
        때의 일반적인 개인정보 보호 고려사항과 구체적인 개인정보 보호 영향에
        대해 자세히 설명한다.
      </p>
      <section class="informative">
        <h3>프라이버시 스펙트럼</h3>
        <p>
          가명에서 강력한 식별에 이르기까지 프라이버시 스펙트럼이 있다는 점을
          인식하는 것이 중요하다. 사용 사례에 따라 사람들은 자신이 기꺼이
          제공하고자 하는 정보와 제공된 정보에서 파생될 수 있는 정보에 대해 서로
          다른 편안함을 느낀다.
        </p>

        <figure>
          <img
            style="margin: auto; display: block; width: 80%"
            src="diagrams/privacy-spectrum.svg"
            alt="Horizontal bar with
            red on the left, orange in the middle, and green on the
            right.  The red has the text 'Highly correlatable (global
            IDs), e.g., government ID, shipping address, credit card
            number'.  The orange has the text 'Correlatable via collusion
            (personally identifiable info), e.g., name, birthday, zip
            code'.  The green has the text 'Non-correlatable
            (pseudonyms), e.g., age over 21'."
          />
          <figcaption style="text-align: center">
            Privacy spectrum ranging from pseudonymous to fully identified.
          </figcaption>
        </figure>

        <p>
          예를 들어, 대부분의 사람들은 술을 구매할 때 익명으로 남고 싶어할
          것이다. 이는 필요한 규제 검사가 오로지 사람이 특정 연령 이상인지
          여부에 기반하기 때문이다. 반대로, 의사가 환자를 위해 작성한 의료
          처방전의 경우, 처방전을 이행하는 약국은 의료 전문가와 환자를 보다
          강력하게 식별해야 한다. 따라서 모든 사용 사례에 적용되는 단일한
          프라이버시 접근 방식은 없다. 프라이버시 솔루션은 사용 사례에 따라
          다르다.
        </p>

        <p class="note">
          술을 구매할 때 익명으로 남고 싶어하는 사람들의 경우에도, 판매자에게
          적절한 확신을 주기 위해 사진이 부착된 신분증이 여전히 필요할 수 있다.
          판매자는 당신의 이름이나 다른 세부 정보(특정 연령 이상이라는 것
          외에)를 알 필요가 없을 수 있지만, 많은 경우 단순히 연령 증명만으로는
          규정을 충족하기에 여전히 불충분할 수 있다.
        </p>

        <p>
          검증가능한 크리덴셜 데이터 모델은 전체 프라이버시 스펙트럼을 지원하기
          위해 노력하며, 특정 거래에 대한 올바른 익명성 수준에 대한 철학적
          입장을 취하지 않는다. 다음 섹션에서는 프라이버시에 적대적인 특정
          시나리오를 피하려는 구현자를 위한 지침을 제공한다.
        </p>
      </section>

      <section class="informative">
        <h3>소프트웨어 신뢰 경계</h3>

        <p>
          <a href="#ecosystem-overview">이 규격에서 설명하는 생태계</a>에는
          다양한 신뢰 관계가 존재한다. 웹 브라우저를 사용하는 개인은
          <a href="https://www.w3.org/TR/UAAG20/#def-user-agent"
            >사용자 에이전트</a
          >라고도 하는 웹 브라우저를 신뢰하여 개인 정보를 데이터 브로커에
          업로드하지 않음으로써 그 신뢰를 유지한다. 마찬가지로 이 규격에서
          설명하는 생태계의 역할을 수행하는 엔티티는 각 역할을 대신하여 작동하는
          소프트웨어를 신뢰한다. 예를 들면 다음과 같다:
        </p>

        <ul>
          <li>
            온라인 교육 플랫폼과 같은 [=발급자=]의
            <a href="https://www.w3.org/TR/UAAG20/#def-user-agent"
              >사용자 에이전트</a
            >(발급자 소프트웨어)는 발급자가 교육 프로그램을 이수했다고 주장하는
            개인에게만 [=검증가능한 크리덴셜=]을 발급할 것으로 예상된다.
          </li>
          <li>
            채용 웹사이트와 같은 [=검증자=]의
            <a href="https://www.w3.org/TR/UAAG20/#def-user-agent"
              >사용자 에이전트</a
            >(검증 소프트웨어)는 해당 개인이 플랫폼에 제공한 [=검증가능한
            크리덴셜=] 및 [=검증가능한 프레젠테이션=]에 대해 유효한 검증 상태를
            가진 개인에게만 액세스를 허용할 것으로 예상된다.
          </li>
          <li>
            디지털 지갑과 같은 [=보유자=]의
            <a href="https://www.w3.org/TR/UAAG20/#def-user-agent"
              >사용자 에이전트</a
            >(보유자 소프트웨어)는 [=보유자=]가 해당 정보의 공개에 동의한
            경우에만 [=검증자=]에게 정보를 공개할 것으로 예상된다.
          </li>
        </ul>

        <p>
          위의 예시들은 모두를 포괄하는 것은 아니며, 이러한 역할의 사용자는 또한
          자신의 목표를 달성하기 위해 사용하는 소프트웨어로부터 다양한 다른
          것들을 기대할 수도 있다. 간단히 말해, 소프트웨어는 사용자의 최선의
          이익에 따라 작동할 것으로 예상되며, 그 기대를 위반하는 것은 신뢰를
          위반하는 것이며 이는 해당 신뢰를 위반하지 않는 다른 것으로
          소프트웨어가 대체되는 결과를 초래할 것이다. 구현자는 그것이 서비스할
          사용자의 신뢰를 위반하지 않는 소프트웨어를 작성하는 것이 강력히
          권고된다. 또한 구현자는 사용자 또는 신뢰할 수 있는 제3자가
          소프트웨어가 실제로 자신의 최선의 이익에 따라 행동하는지 여부를 확인할
          수 있도록 그들이 만드는 소프트웨어에 감사 기능을 제공하는 것이 좋다.
        </p>

        <p>
          독자는 단일 [=검증자=]와 여러 [=보유자=]에게 서비스를 제공하는
          웹사이트와 같은 일부 소프트웨어가 두 역할 모두에 대해
          <a href="https://www.w3.org/TR/UAAG20/#def-user-agent"
            >사용자 에이전트</a
          >로 작동할 수 있지만, 항상 모든 당사자의 최선의 이익을 동시에 추구할
          수 있는 것은 아니라는 점에 유의해야 한다. 예를 들어, 해당 웹사이트가
          여러 [=보유자=] 중 부정한 [=검증가능한 크리덴셜=] 사용 시도를 감지한
          경우, 위반을 저지른 [=보유자=]의 최선의 이익으로 간주되지 않을 수
          있지만 [=검증자=]와 그러한 위반을 저지르지 <em>않은</em> 모든
          [=보유자=]의 최선의 이익이 될 수 있는 [=검증자=]에게 그러한 이상을
          보고할 수 있다. 소프트웨어가 이러한 방식으로 작동할 때는 웹사이트 사용
          정책과 같은 메커니즘을 통해 소프트웨어가 누구의 최선의 이익을 위해
          작동하는지 명확히 하는 것이 강력히 권고된다.
        </p>
      </section>

      <section class="informative">
        <h3>개인 식별 정보</h3>

        <p>
          `credential.credentialSubject` 필드에 저장된 [=검증가능한 크리덴셜=]과
          관련된 데이터는 [=검증자=]와 공유될 때 프라이버시 침해에 취약하다.
          정부 발행 식별자, 배송 주소, 성명과 같은 개인 식별 데이터는
          [=엔티티=]를 쉽게 식별, 추적 및 연관시키는 데 사용될 수 있다.
          생년월일과 우편번호의 조합과 같이 개인 식별이 불가능해 보이는
          정보조차도 매우 강력한 상관관계와 익명성 제거 능력을 가지고 있다.
        </p>

        <p>
          구현자는 이러한 특성을 가진 데이터를 공유할 때 [=보유자=]에게 경고하는
          것이 강력히 권고된다. [=발급자=]는 가능한 경우 프라이버시를 보호하는
          [=검증가능한 크리덴셜=]을 제공하는 것이 강력히 권고된다. 예를 들어,
          [=검증자=]가 [=엔티티=]의 나이가 18세 이상인지 여부를 확인하고자 할 때
          생년월일 [=검증가능한 크리덴셜=] 대신 `ageOver` [=검증가능한
          크리덴셜=]을 발급하는 것이다.
        </p>

        <p>
          [=검증가능한 크리덴셜=]에는 종종 개인 식별 정보(PII)가 포함되어
          있으므로, 구현자는 [=검증가능한 크리덴셜=]을 저장하고 전송하는 동안
          액세스해서는 안 되는 사람들로부터 데이터를 보호하는 메커니즘을
          사용하는 것이 강력히 권고된다. 고려될 수 있는 메커니즘에는 전송 계층
          보안(TLS) 또는 전송 중 데이터를 암호화하는 다른 수단, 그리고
          [=검증가능한 크리덴셜=]의 데이터를 보호하기 위한 암호화 또는 데이터
          액세스 제어 메커니즘 등이 있다.
        </p>
      </section>

      <section class="informative">
        <h3 id="identifier-based-correlation">식별자 기반 연관</h3>

        <p>
          [=검증가능한 크리덴셜=]의 [=주체=]는 `credential.credentialSubject.id`
          필드를 사용하여 식별된다. [=주체=]를 식별하는 데 사용되는 식별자는
          식별자가 장기간 사용되거나 둘 이상의 웹 도메인에서 사용될 때 더 큰
          연관 위험을 초래한다.
        </p>

        <p>
          마찬가지로, [=크리덴셜=] 식별자(`credential.id`)를 공개하면 여러
          [=검증자=] 또는 [=발급자=]와 [=검증자=]가 공모하여 [=보유자=]를
          연관시킬 수 있는 상황으로 이어진다. [=보유자=]가 연관성을 줄이고
          싶다면, [=검증가능한 프레젠테이션=] 중에 식별자를 숨길 수 있는
          [=검증가능한 크리덴셜=] 체계를 사용해야 한다. 이러한 체계는
          [=보유자=]가 식별자를 생성하고 심지어 식별자를 [=검증가능한
          크리덴셜=]에 포함되고 서명된 상태로 유지하면서도 [=발급자=]로부터
          식별자를 숨길 수 있도록 한다.
        </p>

        <p>
          [=검증가능한 크리덴셜=] 시스템에서 강력한 반연관 속성이 요구사항인
          경우, 식별자가 다음 중 하나여야 한다:
        </p>

        <ul>
          <li>단일 출처에 바인딩됨</li>
          <li>일회용</li>
          <li>
            전혀 사용되지 않고 대신 단기적이고 일회용인 Bearer 토큰으로 대체됨.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>서명 기반 연관</h3>

        <p>
          [=크리덴셜=]의 내용은 보안 메커니즘을 사용하여 보호된다. 보안
          메커니즘을 나타내는 데 사용되는 값은 동일한 값이 둘 이상의 세션 또는
          도메인에서 사용되고 값이 변경되지 않을 때 더 큰 연관 위험을 초래한다.
        </p>

        <p>
          강력한 반연관 속성이 요구되는 경우, 서명 값과 메타데이터를 제3자 쌍별
          서명, 영지식 증명 또는 그룹 서명과 같은 기술을 사용하여 매번
          재생성하는 것이 좋다.
        </p>

        <p class="note">
          반연관 서명을 사용하더라도 사용된 암호화의 반연관 속성을 무력화하는
          정보가 여전히 [=검증가능한 크리덴셜=]에 포함될 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>장기 식별자 기반 연관</h3>

        <p>
          [=검증가능한 크리덴셜=]에는 개인을 연관시키는 데 사용될 수 있는 장기
          식별자가 포함될 수 있다. 이러한 유형의 식별자에는 [=주체=] 식별자,
          이메일 주소, 정부 발행 식별자, 조직 발행 식별자, 주소, 의료 필수 정보,
          [=검증가능한 크리덴셜=] 전용 JSON-LD 컨텍스트 및 기타 많은 종류의 장기
          식별자가 포함된다.
        </p>

        <p>
          [=보유자=]에게 소프트웨어를 제공하는 조직은 개인을 연관시키는 데
          사용될 수 있는 정보가 포함된 [=검증가능한 크리덴셜=]의 필드를
          식별하고, 이 정보가 공유될 때 [=보유자=]에게 경고하기 위해 노력해야
          한다.
        </p>
      </section>

      <section class="informative">
        <h3>메타데이터 기반 연관</h3>

        <p>
          <a href="#basic-concepts"></a> 섹션과
          <a href="#advanced-concepts"></a> 섹션에 설명된 다양한 확장점의 사용은
          특정 확장 유형 또는 유형의 조합을 사용하는 [=발급자=]의 수가
          상대적으로 적은 경우 의도하지 않았거나 원하지 않는 연관 메커니즘으로
          작용할 수 있다. 예를 들어, 특정 국가에서만 사용하는 특정 유형의 암호화
          사용, 특정 관할 구역에서 사용하는 폐기 형식 또는 특정 지역에서
          사용하는 크리덴셜 유형은 [=보유자=]가 [=검증자=]에게 정보를 선택적으로
          공개할 때 예상할 수 있는 가명성을 줄이는 메커니즘으로 사용될 수 있다.
        </p>

        <p>
          [=발급자=]는 [=보유자=]의 가명성을 좁히는 데 사용될 수 있는 확장
          유형을 줄임으로써 가명으로 사용될 것으로 예상되는 [=검증가능한
          크리덴셜=]을 발급할 때 메타데이터 기반 연관 가능성을 줄이는 것이 좋다.
          국가적으로 사용되는 것보다 전 세계적으로 사용되는 크리덴셜 유형, 확장
          및 기술 프로필을 사용하는 것이 좋으며, 국가적으로 사용되는 것은
          지역적으로만 사용되는 것보다 선호된다.
        </p>
      </section>

      <section class="informative">
        <h3>장치 추적 및 핑거프린팅</h3>

        <p>
          인터넷과 웹에서 개인을 추적하고 연관시키는 데 사용되는 [=검증가능한
          크리덴셜=] 외부의 메커니즘이 있다. 이러한 메커니즘에는 인터넷
          프로토콜(IP) 주소 추적, 웹 브라우저 핑거프린팅, 에버쿠키, 광고
          네트워크 추적기, 모바일 네트워크 위치 정보, 애플리케이션 내 GPS(Global
          Positioning System) API 등이 있다. [=검증가능한 크리덴셜=]을
          사용한다고 해서 이러한 다른 추적 기술의 사용을 막을 수는 없다. 또한
          이러한 기술이 [=검증가능한 크리덴셜=]과 함께 사용될 때 새로운 연관
          가능한 정보가 발견될 수 있다. 예를 들어, 생일과 GPS 위치를 결합하면
          여러 웹사이트에서 개인을 강력하게 연관시키는 데 사용될 수 있다.
        </p>

        <p>
          프라이버시를 존중하는 시스템은 [=검증가능한 크리덴셜=]이 사용될 때
          이러한 다른 추적 기술의 사용을 방지하는 것이 좋다. 경우에 따라
          [=보유자=]를 대신하여 [=검증가능한 크리덴셜=]을 전송하는 장치에서 추적
          기술을 비활성화해야 할 수도 있다.
        </p>

        <p>
          Oblivious HTTP 프로토콜 [[?OHTTP]]은 [=검증가능한 크리덴셜=] 또는
          [=검증가능한 프레젠테이션=]과 관련된 외부 리소스를 가져올 때 구현자가
          사용을 고려할 수 있는 한 가지 메커니즘이다. Oblivious HTTP를 사용하면
          클라이언트가 원본 서버에 여러 요청을 할 수 있지만 해당 서버는 이러한
          요청을 해당 클라이언트에 연결하거나 심지어 이러한 요청이 단일
          클라이언트에서 온 것으로 식별할 수 없으며, 메시지를 전달하는 데
          사용되는 노드에 대한 제한된 신뢰만 있으면 된다. 따라서 Oblivious
          HTTP는 장치 추적 및 핑거프린팅 가능성을 줄이는 데 사용할 수 있는
          프라이버시 보호 메커니즘 중 하나이다. Oblivious HTTP가 생태계
          참여자에게 어떻게 도움이 될 수 있는지에 대한 구체적인 예시는 아래에
          포함되어 있다.
        </p>

        <ul>
          <li>
            디지털 지갑을 사용하는 [=보유자=]는 디지털 지갑에 저장된
            [=검증가능한 크리덴셜=] 내의 외부 링크에 액세스할 때 제3자에 의해
            추적될 가능성을 줄일 수 있다. 예를 들어, 디지털 지갑은 연결된
            이미지를 가져와 렌더링하거나 외부에 연결된 폐기 목록을 가져와
            [=검증가능한 크리덴셜=]의 유효성을 확인할 수 있다.
          </li>
          <li>
            [=검증자=]는 [=검증자=]가 특정 [=검증가능한 크리덴셜=]을 수신했다는
            신호를 [=발급자=]에게 보내는 것을 줄일 수 있다. 예를 들어,
            [=검증자=]는 [=검증가능한 크리덴셜=]에 대한 상태 검사를 수행하는
            동안 외부에 연결된 폐기 목록을 가져올 수 있다.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>추상적인 클레임 선호</h3>

        <p>
          [=검증가능한 크리덴셜=]의 수신자가 거래에 필요한 것보다 더 많은 PII를
          공개하지 않고 다양한 상황에서 사용할 수 있도록 하기 위해, [=발급자=]는
          [=크리덴셜=]에 게시된 정보를 예상되는 목적에 필요한 최소한의 집합으로
          제한하는 것을 고려해야 한다. [=크리덴셜=]에 PII를 넣지 않는 한 가지
          방법은 [=주체=]에 대한 구체적인 정보를 제공하지 않고 [=검증자=]의
          요구사항을 충족하는 추상적인 [=속성=]을 사용하는 것이다.
        </p>
        <p>
          예를 들어, 이 문서는 훨씬 더 강력한 PII인 특정 생년월일 대신 `ageOver`
          [=속성=]을 사용한다. 특정 시장의 소매업체가 일반적으로 구매자의 연령이
          특정 연령 이상일 것을 요구하는 경우, 해당 시장에서 신뢰받는
          [=발급자=]는 특정 생년월일에 대한 [=클레임=]이 포함된 [=검증가능한
          크리덴셜=]을 제공하는 대신 [=주체=]가 해당 요구사항을 충족했다고
          주장하는 [=검증가능한 크리덴셜=]을 제공하는 것을 선택할 수 있다. 이를
          통해 개별 고객은 특정 PII를 공개하지 않고 구매할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>데이터 최소화 원칙</h3>

        <p>
          한 맥락에서 공개된 정보가 다른 맥락으로 유출될 때 프라이버시 침해가
          발생한다. 이러한 위반을 방지하기 위한 일반적인 모범 사례는 요청하고
          받는 정보를 절대적으로 필요한 최소한으로 제한하는 것이다. 이러한
          데이터 최소화 접근 방식은 미국의 건강보험 이동성 및 책임법(HIPAA)과
          유럽연합의 일반 데이터 보호규정(GDPR)을 포함한 여러 관할 구역의
          규정에서 요구된다.
        </p>

        <p>
          [=검증가능한 크리덴셜=]에서 [=발급자=]의 데이터 최소화는 [=검증가능한
          크리덴셜=]의 내용을 잠재적 [=검증자=]가 예상하는 사용에 필요한
          최소한으로 제한하는 것을 의미한다. [=검증자=]의 경우 데이터 최소화는
          서비스 액세스에 요청되거나 요구되는 정보의 범위를 제한하는 것을
          의미한다.
        </p>

        <p>
          예를 들어, 운전자의 ID 번호, 신장, 체중, 생년월일 및 집 주소가 포함된
          운전면허증은 해당 사람이 특정 연령 이상임을 확인하는 데 필요한
          정보보다 더 많은 정보를 포함하는 [=크리덴셜=]이다.
        </p>

        <p>
          [=발급자=]가 정보를 원자화하거나 [=선택적 공개=]를 허용하는 서명
          체계를 사용하는 것이 모범 사례로 간주된다. 예를 들어, 운전면허증
          [=발급자=]는 운전면허증에 나타나는 모든 속성을 포함하는 [=검증가능한
          크리덴셜=]과 함께 각 [=검증가능한 크리덴셜=]에 생년월일과 같은 단일
          속성만 포함하는 [=검증가능한 크리덴셜=] 집합을 발행할 수 있다. 또한 더
          추상적인 [=검증가능한 크리덴셜=](예: `ageOver` 속성만 포함하는
          [=검증가능한 크리덴셜=])을 발행할 수도 있다. 한 가지 가능한 적응
          방법은 [=발급자=]가 [=검증가능한 크리덴셜=]의 가명 사용을 촉진하는
          일회용 [=Bearer 크리덴셜=]을 검색하기 위한 보안 HTTP 엔드포인트를
          제공하는 것이다. 이것이 비실용적이거나 안전하지 않다고 생각하는
          구현자는 증명 시점에서 [=발급자=]에 대한 의존성을 제거하고
          [=발급자=]로부터의 시간적 상관관계 위험을 줄이는 [=선택적 공개=]
          체계를 사용하는 것을 고려해야 한다.
        </p>

        <p>
          [=검증자=]는 특정 거래가 발생하는 데 절대적으로 필요한 정보만 요청하는
          것이 좋다. 이는 적어도 두 가지 이유로 중요하다:
        </p>

        <ul>
          <li>
            [=검증자=]가 필요하지 않은 매우 민감한 정보를 처리해야 하는 책임을
            줄인다.
          </li>
          <li>
            특정 거래에 필요한 정보만 요청함으로써 개인의 프라이버시를 강화한다.
          </li>
        </ul>

        <p class="note">
          최소 공개 원칙을 실천하는 것이 가능하지만, 단일 세션 또는 여러 세션에
          걸쳐 특정 사용 사례에 대해 개인의 강력한 식별을 피하는 것은 불가능할
          수 있다. 이 문서의 저자들은 실제 시나리오에서 이 원칙을 충족하는 것이
          얼마나 어려운지 강조할 수 없다.
        </p>
      </section>

      <section class="informative">
        <h3>Bearer 크리덴셜</h3>

        <p>
          <dfn data-lt="bearer credentials">Bearer 크리덴셜</dfn>은 콘서트
          티켓과 같이 Bearer 크리덴셜의 [=보유자=]가 [=보유자=]에 대한 민감한
          정보를 공개하지 않고 특정 리소스를 받을 자격이 있는 프라이버시 강화
          정보이다. Bearer 크리덴셜은 종종 Bearer 크리덴셜의 공유가 우려되지
          않거나 큰 경제적 또는 평판 손실을 초래하지 않는 저위험 사용 사례에
          사용된다.
        </p>

        <p>
          [=Bearer 크리덴셜=]인 [=검증가능한 크리덴셜=]은 `credentialSubject`
          [=속성=]에 중첩된 `id` [=속성=]으로 표현되는 [=주체=] 식별자를
          지정하지 않음으로써 가능해진다. 예를 들어, 다음 [=검증가능한
          크리덴셜=]은 [=Bearer 크리덴셜=]이다:
        </p>

        <pre
          class="example nohighlight vc"
          title="Usage of issuer properties"
          data-vc-vm="https://university.example/issuers/14#keys-1"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// note that the 'id' property is not specified for bearer credentials</span>
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          Bearer 크리덴셜은 프라이버시 강화에 도움이 될 수 있지만, Bearer
          크리덴셜의 [=보유자=]가 예상하는 것보다 더 많은 정보를 실수로 누설하지
          않도록 주의 깊게 작성되어야 한다. 예를 들어, 동일한 Bearer 크리덴셜을
          여러 사이트에서 반복적으로 사용하면 이러한 사이트들이 공모하여
          [=보유자=]를 부당하게 추적하거나 연관시킬 수 있다. 마찬가지로,
          생년월일이나 우편번호와 같이 식별이 불가능해 보이는 정보도 동일한
          Bearer 크리덴셜이나 세션에서 함께 사용될 때 통계적으로 개인을 식별하는
          데 사용될 수 있다.
        </p>

        <p>
          Bearer 크리덴셜의 [=발급자=]는 Bearer 크리덴셜이 다음과 같은
          프라이버시 강화 이점을 제공하도록 해야 한다:
        </p>

        <ul>
          <li>가능한 경우 일회용이어야 한다.</li>
          <li>개인 식별 정보를 포함하지 않아야 한다.</li>
          <li>부당하게 연관 가능하지 않아야 한다.</li>
        </ul>

        <p>
          [=보유자=]는 민감한 정보가 포함된 Bearer 크리덴셜이 발급되거나
          요청되는 경우, 또는 하나 이상의 세션에서 두 개 이상의 Bearer
          크리덴셜을 결합할 때 상관관계 위험이 있는 경우 소프트웨어에서 경고를
          받아야 한다. 모든 상관관계 위험을 감지하는 것은 불가능할 수 있지만,
          일부는 분명히 감지될 수 있다.
        </p>

        <p>
          [=검증자=]는 [=보유자=]를 부당하게 연관시키는 데 사용될 수 있는 Bearer
          크리덴셜을 요청해서는 안 된다.
        </p>
      </section>

      <section class="informative">
        <h3 id="validation">유효성 검사</h3>

        <p>
          [=검증가능한 크리덴셜=]을 처리할 때, [=검증자=]는 관련 [=클레임=]에
          의존하기 전에 이를 평가한다. 이 평가는 유효성 검사를 수행하는
          [=검증자=]의 요구사항을 충족하는 한 원하는 방식으로 수행될 수 있다.
          많은 검증자는 부록 <a href="#validation"></a>에 나열된 검사뿐만 아니라
          다음과 같은 다양한 특정 비즈니스 프로세스 검사를 수행할 것이다:
        </p>

        <ul>
          <li>[=보유자=]의 전문 면허 상태.</li>
          <li>면허 갱신 또는 폐지 날짜.</li>
          <li>개인의 하위 자격.</li>
          <li>
            [=보유자=]와 [=보유자=]가 상호 작용하려는 [=엔티티=] 사이에 관계가
            존재하는지 여부.
          </li>
          <li>[=보유자=]와 관련된 지리적 위치 정보.</li>
        </ul>

        <p>
          이러한 검사를 수행하는 과정에서 [=보유자=]의 프라이버시 침해로 이어질
          수 있는 정보 유출이 발생할 수 있다. 예를 들어, 부적절하게 구성된 폐기
          목록을 확인하는 것과 같은 간단한 작업으로 인해 특정 비즈니스가
          [=보유자=]와 상호 작용할 가능성이 있음을 [=발급자=]에게 알릴 수 있다.
          이로 인해 [=발급자=]가 개인들의 동의 없이 연관시키기 위해 공모할 수
          있다.
        </p>

        <p>
          [=발급자=]는 [=검증=] 프로세스 중에 프라이버시 침해로 이어질 수 있는
          [=크리덴셜=]마다 고유한 [=크리덴셜=] 폐기 목록과 같은 메커니즘을
          사용하지 않도록 해야 한다. [=보유자=]에게 소프트웨어를 제공하는 조직은
          검증 프로세스 중에 프라이버시 침해로 이어질 수 있는 정보가
          [=크리덴셜=]에 포함된 경우 경고해야 한다. [=검증자=]는 프라이버시
          침해를 유발하거나 잘못된 프라이버시 관행을 가능하게 하는
          [=크리덴셜=]을 거부하는 것을 고려해야 한다.
        </p>
      </section>

      <section class="informative">
        <h3>저장 제공자와 데이터 마이닝</h3>

        <p>
          [=보유자=]가 [=발급자=]로부터 [=검증가능한 크리덴셜=]을 받으면
          [=검증가능한 크리덴셜=]은 어딘가에 저장되어야 한다(예: [=크리덴셜=]
          리포지토리에). [=보유자=]는 [=검증가능한 크리덴셜=]의 정보가
          본질적으로 민감하고 개별화되어 있어 데이터 마이닝의 주요 대상이 된다는
          점에 주의해야 한다. [=검증가능한 크리덴셜=]의 무료 저장을 광고하는
          서비스는 실제로는 개인 데이터를 마이닝하여 개인과 조직에 대한 개별
          프로필을 구축하려는 조직에 판매할 수 있다.
        </p>

        <p>
          [=보유자=]는 [=크리덴셜=] 리포지토리의 서비스 약관, 특히 서비스
          제공자에게 [=검증가능한 크리덴셜=]을 저장하는 사람들을 위한 상관관계
          및 데이터 마이닝 보호를 인식해야 한다.
        </p>

        <p>
          데이터 마이닝 및 프로파일링을 효과적으로 완화하는 방법에는 다음과 같은
          것들이 있다:
        </p>

        <ul>
          <li>정보를 제3자에게 판매하지 않는 서비스 제공자 사용.</li>
          <li>
            서비스 제공자가 [=크리덴셜=]의 내용을 볼 수 없도록 [=검증가능한
            크리덴셜=]을 암호화하는 소프트웨어 사용.
          </li>
          <li>
            사용자가 제어하는 장치에 [=검증가능한 크리덴셜=]을 로컬로 저장하고
            사용자의 기대를 넘어 정보를 업로드하거나 분석하지 않는 소프트웨어
            사용.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>크리덴셜 집합화</h3>

        <p>
          동일한 [=주체=]에 대한 두 가지 정보를 보유하는 것은 정보가 서로 다른
          채널을 통해 전달되는 경우에도 거의 항상 두 정보의 합보다 [=주체=]에
          대해 더 많은 것을 드러낸다. [=검증가능한 크리덴셜=]의 집합화는
          프라이버시 위험이며, 생태계의 모든 참여자는 데이터 집합화의 위험을
          인식해야 한다.
        </p>

        <p>
          예를 들어, 이메일 주소에 대한 하나의 [=Bearer 크리덴셜=]과
          [=보유자=]가 21세 이상임을 명시하는 또 다른 [=Bearer 크리덴셜=]이 여러
          세션에 걸쳐 제공되는 경우, 정보의 [=검증자=]는 이제 해당 개인에 대한
          고유 식별자와 연령 관련 정보를 모두 가지게 된다. 이제 [=보유자=]에
          대한 프로필을 쉽게 생성하고 구축할 수 있어 시간이 지남에 따라 점점 더
          많은 정보가 유출된다. [=크리덴셜=]의 집합화는 서로 공모하는 여러
          사이트에서도 수행될 수 있으며, 이는 프라이버시 침해로 이어진다.
        </p>

        <p>
          기술적 관점에서 정보의 집합화를 방지하는 것은 해결하기 매우 어려운
          프라이버시 문제이다. 영지식 증명과 같은 새로운 암호화 기술이 집합화 및
          상관관계 문제에 대한 해결책으로 제안되고 있지만, 장기 식별자와
          브라우저 추적 기술의 존재는 가장 현대적인 암호화 기술조차도
          무력화시킨다.
        </p>

        <p>
          상관관계 또는 집합화의 프라이버시 영향에 대한 해결책은 기술적인 성격이
          아니라 정책적인 성격일 경향이 있다. 따라서 [=보유자=]가 자신에 대한
          정보가 집합화되는 것을 원하지 않는다면, 그들은 전송하는 [=검증가능한
          프레젠테이션=]에서 이를 표현해야 한다.
        </p>
      </section>

      <section class="informative">
        <h3 id="usage-patterns">사용 패턴</h3>

        <p>
          프라이버시를 보장하기 위한 최선의 노력에도 불구하고, 실제로
          [=검증가능한 크리덴셜=]을 사용하면 익명성 침해와 프라이버시 손실이
          발생할 수 있다. 이러한 상관관계는 다음과 같은 경우에 발생할 수 있다:
        </p>

        <ul>
          <li>
            동일한 [=검증가능한 크리덴셜=]이 동일한 [=검증자=]에게 두 번 이상
            제시된 경우. [=검증자=]는 [=보유자=]가 동일한 개인이라고 추론할 수
            있다.
          </li>
          <li>
            동일한 [=검증가능한 크리덴셜=]이 서로 다른 [=검증자=]에게 제시되고,
            해당 [=검증자=]들이 공모하거나 제3자가 두 [=검증자=]의 거래 기록에
            액세스할 수 있는 경우. 주의 깊은 당사자는 [=검증가능한 크리덴셜=]을
            제시하는 개인이 두 서비스에서 동일한 사람이라고 추론할 수 있다. 즉,
            계정이 동일한 사람에 의해 제어된다.
          </li>
          <li>
            [=크리덴셜=]의 [=주체=] 식별자가 여러 [=프레젠테이션=] 또는
            [=검증자=]에 걸쳐 동일한 [=주체=]를 참조하는 경우. 서로 다른
            [=크리덴셜=]이 제시되더라도 [=주체=] 식별자가 동일하다면
            [=검증자=](및 [=검증자=] 로그에 액세스할 수 있는 사람)는
            [=크리덴셜=]의 [=보유자=]가 동일한 사람이라고 추론할 수 있다.
          </li>
          <li>
            [=크리덴셜=]의 기본 정보를 사용하여 서비스 전체에서 개인을 식별할 수
            있는 경우. 이 경우 다른 출처의 정보([=보유자=]가 직접 제공한 정보
            포함)를 사용하여 [=검증자=]는 [=크리덴셜=] 내부의 정보를 사용하여
            개인을 기존 프로필과 연관시킬 수 있다. 예를 들어, [=보유자=]가
            우편번호, 나이, 성별 등을 포함하는 [=크리덴셜=]을 제시하면
            [=검증자=]는 해당 [=크리덴셜=]의 [=주체=]를 기존 프로필과 잠재적으로
            연관시킬 수 있다. 자세한 내용은 [[DEMOGRAPHICS]]를 참조하시오.
          </li>
          <li>
            [=크리덴셜=]의 식별자를 중앙 집중식 폐기 서버로 전달하는 경우. 중앙
            집중식 서버는 상호 작용에 걸쳐 [=크리덴셜=] 사용을 연관시킬 수 있다.
            예를 들어, [=크리덴셜=]이 이러한 방식으로 연령 증명에 사용되는 경우,
            중앙 집중식 서비스는 해당 [=크리덴셜=]이 제시된 모든 곳(모든 주류
            판매점, 바, 성인 상점, 복권 구매 등)을 알 수 있다.
          </li>
        </ul>

        <p>
          부분적으로는 다음과 같은 방법으로 이러한 익명성 침해와 프라이버시
          손실을 완화할 수 있다:
        </p>

        <ul>
          <li>
            주어진 [=크리덴셜=]에 대해 전역적으로 고유한 식별자를 [=주체=]로
            사용하고 해당 [=크리덴셜=]을 재사용하지 않는다.
          </li>
          <li>
            [=크리덴셜=]이 폐기를 지원하는 경우, 폐기를 위해 전역적으로 분산된
            서비스를 사용한다.
          </li>
          <li>
            [=크리덴셜=]의 ID 제출에 의존하지 않는 폐기 API를 설계한다. 예를
            들어, 쿼리 대신 폐기 목록을 사용한다.
          </li>
          <li>
            개인 식별 정보를 특정 장기 [=주체=] 식별자와 연결하는 것을 피한다.
          </li>
        </ul>

        <p>
          이러한 완화 기술이 항상 실용적이거나 심지어 필요한 사용과 호환되는
          것은 아니라는 점을 이해해야 한다. 때로는 상관관계가 요구사항이 된다.
        </p>

        <p>
          예를 들어, 일부 처방약 모니터링 프로그램에서는 사용량 모니터링이
          요구사항이다. 집행 기관은 개인이 통제 물질에 대한 여러 처방전을 얻기
          위해 시스템을 속이지 않았음을 확인할 수 있어야 한다. 이러한 법적 또는
          규제적 필요성은 개인 프라이버시 우려보다 우선한다.
        </p>

        <p>
          [=검증가능한 크리덴셜=]은 또한 서비스 전체에서 개인을 의도적으로
          연관시키는 데 사용될 것이다. 예를 들어, 여러 서비스에 로그인할 때 공통
          페르소나를 사용하여 각 서비스의 모든 활동이 의도적으로 동일한 개인과
          연결되도록 한다. 각 서비스가 기대한 방식으로 상관관계를 사용하는 한
          이는 프라이버시 문제가 되지 않는다.
        </p>

        <p>
          [=크리덴셜=] 사용의 프라이버시 위험은 [=크리덴셜=]의 제시로 인해
          의도하지 않았거나 예상하지 못한 상관관계가 발생할 때 발생한다.
        </p>
      </section>

      <section class="informative">
        <h3>잘못된 당사자와 정보 공유</h3>

        <p>
          [=보유자=]가 [=검증자=]와 정보를 공유하기로 선택할 때, [=검증자=]가
          악의적으로 행동하고 [=보유자=]에게 해를 끼치는 데 사용될 수 있는
          정보를 요청하는 경우가 있을 수 있다. 예를 들어, [=검증자=]는
          [=보유자=] 또는 은행을 속이기 위해 다른 정보와 함께 사용될 수 있는
          은행 계좌 번호를 요청할 수 있다.
        </p>

        <p>
          [=발급자=]는 [=보유자=]가 실수로 [=크리덴셜=]을 잘못된 [=검증자=]에게
          전송하더라도 상황이 심각하지 않도록 가능한 한 많은 정보를 토큰화하기
          위해 노력해야 한다.
        </p>

        <p>
          예를 들어, 개인의 은행 잔고를 확인하기 위해 은행 계좌 번호를 포함하는
          대신, [=검증자=]가 잔액이 특정 금액 이상인지 확인할 수 있는 토큰을
          제공한다. 이 경우, 은행은 [=보유자=]에게 잔액 확인 토큰이 포함된
          [=검증가능한 크리덴셜=]을 발행할 수 있다. 그러면 [=보유자=]는
          [=검증가능한 프레젠테이션=]에 [=검증가능한 크리덴셜=]을 포함하고
          디지털 서명을 사용하여 토큰을 신용 조회 기관에 바인딩한다. 그런 다음
          [=검증자=]는 [=검증가능한 프레젠테이션=]을 자신의 디지털 서명으로
          감싸서 발급자에게 다시 전달하여 동적으로 계좌 잔액을 확인할 수 있다.
        </p>

        <p>
          이 방법을 사용하면 [=보유자=]가 잘못된 당사자와 계좌 잔액 토큰을
          공유하더라도 공격자는 은행 계좌 번호나 계좌의 정확한 금액을 알아낼 수
          없다. 그리고 역서명의 유효 기간을 감안할 때, 몇 분 이상 토큰에 접근할
          수 없다.
        </p>
      </section>

      <section class="informative">
        <h3>데이터 도난</h3>

        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]에 표현된
          데이터는 [=발급자=]와 같은 신뢰할 수 있는 제3자 또는 [=보유자=]나
          [=주체=]와 같은 개인이 만든 진술을 포함하므로 가치가 있다. 이 데이터를
          저장하면 공격자가 금전적 이득을 위해 데이터를 획득하고 교환하기 위해
          침입하려는 동기를 갖게 되는 민감한 데이터의 허니팟을 만들 수 있다.
        </p>

        <p>
          [=발급자=]는 [=보유자=]에게 [=검증가능한 크리덴셜=]을 발급하고 해당
          크리덴셜의 상태와 폐기를 관리하는 데 필요한 최소한의 데이터만 보유하는
          것이 좋다.
        </p>

        <p>
          [=보유자=]는 전송 중과 저장 시 모두 데이터를 적절히 암호화하고,
          하드웨어 장치에서 쉽게 추출할 수 없는 방식으로 민감한 자료(암호화 비밀
          등)를 보호하는 구현을 사용하는 것이 좋다. 또한 [=보유자=]는 데이터에
          대한 공격 가능성을 줄이고 공격이 성공할 경우 대규모 도난을 방지하기
          위해 중앙 집중식 시스템에서 멀리 떨어진 자신이 제어하는 장치에서만
          데이터를 저장하고 조작하는 것이 좋다.
        </p>

        <p>
          [=검증자=]는 특정 거래에 필요한 데이터만 요청하고 특정 거래의 필요성을
          넘어 데이터를 보유하지 않는 것이 좋다.
        </p>

        <p>
          규제 당국은 유사한 수준의 집행 및 감사 기능을 달성하기 위해 더 많은
          프라이버시 보호 메커니즘을 사용할 수 있도록 감사 요구 사항을 재고하는
          것이 좋다. 예를 들어, 개인 식별 정보의 수집과 장기 보유를 고집하는
          감사 중심 규정은 동일한 정보가 손상되어 공격자가 액세스할 경우 개인과
          조직에 해를 끼칠 수 있다. 이 규격에서 설명하는 기술을 통해
          [=보유자=]는 자신과 다른 사람에 대한 속성을 더 쉽게 증명할 수 있어
          [=검증자=]가 장기간 데이터를 보유할 필요성이 줄어든다. 대안으로는
          정보가 수집되고 확인되었음을 기록하고, 규정 준수 체제가 예상대로
          작동하고 있는지 확인하기 위해 무작위 테스트를 수행하는 것 등이 있다.
        </p>
      </section>

      <section class="informative">
        <h3>클레임 발급 빈도</h3>

        <p>
          <a href="#usage-patterns"></a> 섹션에서 자세히 설명한 바와 같이, 사용
          패턴은 특정 유형의 행동과 상관관계가 있을 수 있다. 이러한 상관관계의
          일부는 [=보유자=]가 [=발급자=]의 동의 없이 [=검증가능한 크리덴셜=]을
          사용할 때 완화된다. 그러나 [=발급자=]는 [=검증가능한 크리덴셜=]의 유효
          기간을 매우 짧게 하고 갱신을 자동화함으로써 이러한 보호를 무력화할 수
          있다.
        </p>

        <p>
          예를 들어, `ageOver` [=검증가능한 크리덴셜=]은 술집 출입에 유용하다.
          [=발급자=]가 이러한 [=검증가능한 크리덴셜=]을 매우 짧은 유효 기간과
          자동 갱신 메커니즘으로 발급하면 [=발급자=]는 [=보유자=]에게 부정적인
          영향을 미치는 방식으로 [=보유자=]의 행동을 연관시킬 수 있다.
        </p>

        <p>
          [=보유자=]에게 소프트웨어를 제공하는 조직은 수명이 짧은 [=크리덴셜=]을
          반복적으로 사용하면 행동 상관관계가 발생할 수 있음을 경고해야 한다.
          [=발급자=]는 사용 패턴을 연관시킬 수 있는 방식으로 [=크리덴셜=]을
          발급하는 것을 피해야 한다.
        </p>
      </section>

      <section class="informative">
        <h3>일회용 크리덴셜 선호</h3>

        <p>
          이상적인 프라이버시 존중 시스템에서는 [=검증자=]와의 상호 작용에
          필요한 정보만 [=보유자=]가 공개하도록 요구할 것이다. 그런 다음
          [=검증자=]는 공개 요구사항이 충족되었음을 기록하고 공개된 민감한
          정보를 잊어버릴 것이다. 많은 경우, 규제 부담과 같은 상충되는
          우선순위로 인해 이러한 이상적인 시스템을 채택하지 못하고 있다. 다른
          경우에는 장기 식별자가 일회용을 방지한다. 그러나 모든 [=검증가능한
          크리덴셜=] 생태계의 설계는 가능한 한 일회용 [=검증가능한 크리덴셜=]을
          선호함으로써 가능한 한 프라이버시를 존중하도록 노력해야 한다.
        </p>

        <p>
          일회용 [=검증가능한 크리덴셜=]을 사용하면 여러 가지 이점이 있다. 첫
          번째 이점은 [=검증가능한 크리덴셜=]의 데이터가 새로운 것임을 확신할 수
          있는 [=검증자=]에게 있다. 두 번째 이점은 [=검증가능한 크리덴셜=]에
          장기 식별자가 없다면 [=검증가능한 크리덴셜=] 자체를 사용하여
          온라인에서 추적하거나 연관시킬 수 없다는 것을 아는 [=보유자=]에게
          있다. 마지막으로, 공격자가 훔칠 것이 없어 전체 생태계가 더 안전하게
          운영될 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>프라이빗 브라우징</h3>

        <p>
          이상적인 프라이빗 브라우징 시나리오에서는 PII가 전혀 공개되지 않는다.
          많은 [=크리덴셜=]에 PII가 포함되어 있기 때문에 [=보유자=]에게
          소프트웨어를 제공하는 조직은 프라이빗 브라우징 모드에서 [=크리덴셜=]과
          [=프레젠테이션=]을 사용하려는 경우 이 정보가 공개될 가능성에 대해
          경고해야 한다. 각 브라우저 공급업체가 프라이빗 브라우징을 다르게
          처리하고 일부 브라우저에는 이 기능이 전혀 없을 수 있으므로 구현자는
          이러한 차이점을 인식하고 그에 따라 솔루션을 구현하는 것이 중요하다.
        </p>
      </section>

      <section class="informative">
        <h3>발급자 협력이 프라이버시에 미치는 영향</h3>

        <p>
          [=검증가능한 크리덴셜=]은 [=발급자=]에 대한 높은 수준의 신뢰에
          의존한다는 점을 지나치게 강조할 수 없다. [=보유자=]가 가능한
          프라이버시 보호 기능을 활용할 수 있는 정도는 종종 [=발급자=]가 그러한
          기능을 지원하는 정도에 크게 의존한다. 많은 경우, 영지식 증명, 데이터
          최소화 기술, Bearer 크리덴셜, 추상 클레임 및 서명 기반 연관 방지를
          사용하는 프라이버시 보호 기능은 [=발급자=]가 그러한 기능을 적극적으로
          지원하고 발급하는 [=검증가능한 크리덴셜=]에 통합할 것을 요구한다.
        </p>

        <p>
          또한 [=보유자=]와 [=주체=]의 프라이버시 보호에 도움이 되는
          [=검증가능한 크리덴셜=] 기능을 제공하기 위해 [=발급자=]의 참여에
          의존하는 것 외에도, [=보유자=]는 [=발급자=]가 프라이버시 보호를
          의도적으로 훼손하지 않을 것이라고 믿는다는 점에 유의해야 한다. 예를
          들어, [=발급자=]는 서명 기반 연관을 방지하는 서명 체계를 사용하여
          [=검증가능한 크리덴셜=]에 서명할 수 있다. 이는 [=검증자=] 간에 공유될
          때 서명 값에 의해 연관되는 것으로부터 [=보유자=]를 보호할 것이다.
          그러나 [=발급자=]가 발급된 각 [=크리덴셜=]에 대해 고유한 키를 생성하는
          경우, [=검증자=]가 그렇게 할 수 없더라도 [=발급자=]가 [=크리덴셜=]의
          [=프레젠테이션=]을 추적할 수 있다.
        </p>

        <p>
          [=발급자=]가 사용할 수 있는 이전에 설명한 프라이버시 보호 기능 외에도,
          [=발급자=]는 [=크리덴셜=]을 발급할 때 사용하는 식별자 및 클레임 유형과
          관련하여 유출되는 데이터를 인식해야 한다. 이에 대한 한 가지 예는
          [=발급자=]가 관할권이 있는 위치와 [=주체=]의 거주지를 모두 공개하는
          운전면허증을 발급하는 경우이다. [=검증자=]는 [=주체=]가 운전 면허를
          받았는지 확인하기 위해 [=크리덴셜=]을 요청하는 것처럼 보이지만
          실제로는 크리덴셜을 발급한 [=발급자=]와 같은 크리덴셜에
          <em>대한</em> 메타데이터와 [=발급자=]에 의해 유출되었을 수 있는 주체의
          집 주소와 같은 부수적인 정보에 관심이 있는 것일 수 있다. 이러한 유출을
          완화하기 위해 [=발급자=]는 카운티, 시, 타운 또는 기타 더 작은 지방
          자치 단체 수준 대신 주 또는 국가 수준에서 공유 발급자 식별자를
          사용하는 등 특정 위치 정보 또는 기타 민감한 메타데이터를 마스킹하기
          위해 공통 식별자를 사용하는 것을 선택할 수 있다. 또한 [=보유자=] 증명
          메커니즘은 정확한 [=발급자=]를 공개할 필요 없이 [=발급자=]가 신뢰할 수
          있는 엔티티 집합에 존재한다는 증명을 제공함으로써 [=검증자=]가
          프라이버시를 보호하는 데 사용될 수 있다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>보안 고려사항</h2>

      <p>
        이 규격에서 설명하는 데이터를 처리할 때 [=발급자=], [=보유자=],
        [=검증자=]가 인식해야 할 많은 보안 고려사항이 있다. 이 섹션의 내용을
        무시하거나 이해하지 못하면 보안 취약점이 발생할 수 있다.
      </p>
      <p>
        이 섹션에서는 광범위한 보안 고려사항을 강조하려고 하지만, 이것이 전부는
        아니다. 구현자는 이 규격에 설명된 기술을 사용하여 미션 크리티컬 시스템을
        구현할 때 보안 및 암호화 전문가의 조언을 구하는 것이 좋다.
      </p>

      <section class="informative">
        <h3>암호 제품군 및 라이브러리</h3>

        <p>
          이 규격에 설명된 데이터 모델의 일부 측면은 암호화를 사용하여 보호될 수
          있다. 구현자가 [=크리덴셜=]과 [=프레젠테이션=]을 생성하고 처리하는 데
          사용되는 암호 제품군과 라이브러리를 이해하는 것이 중요하다. 암호화
          시스템의 구현 및 감사에는 일반적으로 상당한 경험이 필요하다. 효과적인
          <a href="https://en.wikipedia.org/wiki/Red_team">레드 팀</a>도 보안
          검토에서 편향을 제거하는 데 도움이 될 수 있다.
        </p>
        <p>
          암호 제품군과 라이브러리에는 수명이 있으며 결국 새로운 공격과 기술
          발전에 의해 무너진다. 프로덕션 품질 시스템은 이를 고려하여 만료되거나
          손상된 암호 제품군과 라이브러리를 쉽고 사전 예방적으로 업그레이드하고,
          기존 [=크리덴셜=]을 무효화하고 교체할 수 있는 메커니즘이 존재하는지
          확인해야 한다. [=크리덴셜=]을 처리하는 시스템의 장기적인 생존력을
          보장하기 위해서는 정기적인 모니터링이 중요하다.
        </p>
      </section>

      <section class="informative">
        <h3>키 관리</h3>

        <p>
          [=검증가능한 크리덴셜=]과 [=검증가능한 프레젠테이션=]을 보호하는 데
          사용되는 대부분의 디지털 서명 알고리즘의 보안성은
          <em>개인 서명 키</em>의 품질과 보호에 달려 있다. 암호화 키 관리에 대한
          지침은 큰 주제이며, 독자는 보다 광범위한 권장사항과 논의를 위해
          [[NIST-SP-800-57-Part-1]]을 참조해야 한다. [[FIPS-186-5]]와
          [[NIST-SP-800-57-Part-1]] 모두에서 강력히 권장하는 바와 같이, 개인
          서명 키는 여러 목적으로 사용되어서는 안 된다. 예를 들어, 개인 서명
          키는 서명뿐만 아니라 암호화에도 사용되어서는 안 된다.
        </p>

        <p>
          [[NIST-SP-800-57-Part-1]]은 개인 서명 키와 <em>공개 검증 키</em>의
          <em>암호화 기간</em>을 제한할 것을 강력히 권고하고 있다. 여기서
          <em>암호화 기간</em>은 "합법적인 엔티티가 특정 키를 사용하도록 승인된
          시간 범위 또는 주어진 시스템의 키가 유효할 시간 범위"를 말한다.
          [[NIST-SP-800-57-Part-1]]은 서로 다른 상황에서 서로 다른 키 유형에
          대한 암호화 기간에 대해 광범위한 지침을 제공하며, 일반적으로 개인 서명
          키에 대해 1-3년의 암호화 기간을 권장한다.
        </p>

        <p>
          잠재적인 개인 키 침해에 대처하기 위해 [[NIST-SP-800-57-Part-1]]은 보호
          조치, 피해 감소 및 폐기에 대한 권장사항을 제공한다. 이 섹션은 주로
          개인 서명 키의 보안에 초점을 맞추고 있지만,
          [[NIST-SP-800-57-Part-1]]은 또한 모든 [=검증 자료=]를 사용하기 전에 그
          유효성을 확인할 것을 강력히 권장한다.
        </p>
      </section>

      <section class="informative">
        <h3>콘텐츠 무결성 보호</h3>
        <p>
          [=검증가능한 크리덴셜=]에는 종종 [=검증가능한 크리덴셜=] 자체 외부에
          있는 데이터에 대한 URL이 포함되어 있다. 이미지, JSON-LD 컨텍스트, JSON
          스키마 및 기타 기계 판독 가능한 데이터와 같이 [=검증가능한 크리덴셜=]
          외부에 존재하는 연결된 콘텐츠는 [=검증가능한 크리덴셜=]의
          <a href="#securing-mechanisms">보안 메커니즘</a> 보호 밖에 있기 때문에
          변조로부터 보호되지 않는 경우가 많다. 예를 들어, 다음 강조 표시된
          링크를 역참조하여 검색할 수 있는 콘텐츠는 무결성이 보호되지 않지만,
          아마도 그래야 할 것이다:
        </p>

        <pre
          class="example nohighlight"
          title="Non-content-integrity protected links"
        >
{
  "@context": [
    <span class="highlight">"https://www.w3.org/ns/credentials/v2"</span>,
    <span class="highlight">"https://www.w3.org/ns/credentials/examples/v2"</span>
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://university.example/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
          이 규격은 특정한 콘텐츠 무결성 보호를 권장하지 않지만, 콘텐츠에 대한
          링크의 무결성을 보장하고자 하는 문서 작성자는 콘텐츠 무결성을 강제하는
          URL 스킴을 사용하는 것이 좋다.
        </p>

        <pre
          class="example nohighlight"
          title="Content-integrity protection for links to external data"
        >
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/ns/credentials/examples/v2<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.com/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p class="note">
          프로덕션 구현에서는 중요한 JSON-LD 컨텍스트의 정적 사본과 함께 제공될
          것으로 예상되므로, 위의 JSON-LD 컨텍스트에 보호가 필요한지 여부는
          논란의 여지가 있다.
        </p>
        <p>
          위의 예는 콘텐츠 무결성 보호를 달성하는 한 가지 방법이지만, 특정
          애플리케이션에 더 적합할 수 있는 다른 솔루션들이 있다. 구현자는 콘텐츠
          무결성이 보호되지 않은 외부 기계 판독 가능 콘텐츠에 대한 링크가 어떻게
          자신의 애플리케이션에 대한 성공적인 공격으로 이어질 수 있는지 이해해야
          한다.
        </p>
      </section>

      <section class="informative">
        <h3>서명되지 않은 클레임</h3>

        <p>
          이 규격은 어떤 종류의 서명이나 증명으로도 보호되지 않는 [=크리덴셜=]을
          생성할 수 있게 한다. 이러한 유형의 [=크리덴셜=]은 종종 중간 저장소나
          웹 페이지에서 양식을 작성하는 것과 유사한 자가 주장 정보에 유용하다.
          구현자는 이러한 유형의 [=크리덴셜=]은 작성자가 알려지지 않았거나
          신뢰할 수 없기 때문에 [=검증 가능=]하지 않다는 점을 알아야 한다.
        </p>
      </section>

      <section class="informative">
        <h3>중간자 (MITM), 리플레이, and 복제 공격</h3>

        <p>
          데이터 모델은 본질적으로
          <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack"
            >중간자 공격(MITM)</a
          >,
          <a href="https://en.wikipedia.org/wiki/Replay_attack">리플레이 공격</a
          >,
          <a href="https://en.wikipedia.org/wiki/Spoofing_attack">스푸핑 공격</a
          >을 방지하지 않는다. 온라인과 오프라인 사용 사례 모두 공격자가 전송
          또는 저장 중에 [=검증가능한 크리덴셜=] 데이터를 가로채고, 수정하고,
          재사용 및/또는 복제하는 이러한 유형의 공격에 취약할 수 있다.
        </p>
        <h4>중간자(MITM) 공격</h4>

        <p>
          [=검증자=]는 자신이 [=검증가능한 프레젠테이션=]의 의도된 수신자이며
          <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack"
            >중간자 공격</a
          >의 타겟이 아닌지 확인해야 할 수 있다. [[VC-JOSE-COSE]] 또는
          [[VC-DATA-INTEGRITY]]와 같은 일부
          <a href="#securing-mechanisms">보안 메커니즘</a>은 [=프레젠테이션=]의
          의도된 청중 또는 도메인을 지정하는 옵션을 제공하므로 이 위험을 줄이는
          데 도움이 될 수 있다.
        </p>
        <p>
          [=검증가능한 프레젠테이션=]에 대한 요청을 응답에 연결하는 토큰
          바인딩[[RFC8471]]과 같은 대체 접근 방식은 프로토콜을 보호할 수 있다.
          보안되지 않은 프로토콜은 중간자 공격에 취약하다.
        </p>
        <h4>리플레이 공격</h4>
        <p>
          [=검증자=]는 [=검증가능한 프레젠테이션=]이 특정 횟수 이상 사용되지
          않도록 하고 싶을 수 있다. 예를 들어, 이벤트 티켓을 나타내는
          [=검증가능한 크리덴셜=]은 여러 번 제시되면 여러 개인의 입장을 허용할
          수 있어 발행자 관점에서 티켓의 목적을 훼손할 수 있다. 이러한 공격을
          방지하기 위해 [=보유자=]는 프레젠테이션 중에
          <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a
          >를 포함하거나 공격 창을 줄이기 위해 만료 타임스탬프를 추가하는 등의
          기술을 사용할 수 있다.
        </p>
        <h4>스푸핑 공격</h4>
        <p>
          [=검증자=]는 [=보유자=]가 [=검증가능한 프레젠테이션=] 내부의 클레임을
          제시할 권한이 있다는 것을 아는 데 이해관계가 있다. 데이터 모델은
          [=검증가능한 크리덴셜=]에 필요한 구조와 데이터 요소를 간략히
          설명하지만, 제시된 [=크리덴셜=]의 권한을 확인하는 메커니즘은 포함하지
          않는다. 이러한 우려를 해결하기 위해 구현자는 [=검증가능한 크리덴셜=]을
          강력한 인증 메커니즘에 바인딩하거나 [=검증가능한 프레젠테이션=]의 추가
          속성을 사용하여 제어 증명을 가능하게 하는 등의 보완 방법을 탐구해야 할
          수 있다.
        </p>
      </section>
      <section class="informative">
        <h3>의존적 클레임 번들링</h3>
        <p>
          [=발급자=]가 [=크리덴셜=]의 정보를 원자화하거나 선택적 공개를 허용하는
          서명 체계를 사용하는 것이 모범 사례로 간주된다. 원자화의 경우,
          [=발급자=]에 의해 안전하게 수행되지 않으면 [=보유자=]가 [=발급자=]가
          의도하지 않은 방식으로 서로 다른 [=크리덴셜=]을 함께 번들링할 수 있다.
        </p>
        <p>
          예를 들어, 대학은 한 사람에게 각각 두 개의 [=속성=]을 포함하는 두 개의
          [=검증가능한 크리덴셜=]을 발급할 수 있는데, 이는 "컴퓨팅 학과"의
          "직원" 또는 "경제학과"의 "대학원생"과 같이 주어진 "학과"에서 그 사람의
          "역할"을 지정하기 위해 함께 취해져야 한다. 이러한 [=검증가능한
          크리덴셜=]이 이러한 [=속성=] 중 하나만 각 [=크리덴셜=]에 넣도록
          원자화되면, 대학은 그 사람에게 "직원", "대학원생", "컴퓨팅 학과",
          "경제학과" 중 하나의 지정을 포함하는 네 개의 [=크리덴셜=]을 발급할
          것이다. 그러면 [=보유자=]는 "직원"과 "경제학과"의 [=검증가능한
          크리덴셜=]을 [=검증자=]에게 전송할 수 있으며, 이는 함께 거짓
          [=클레임=]을 구성할 것이다.
        </p>
      </section>

      <section class="informative">
        <h3>고도로 동적인 정보</h3>
        <p>
          고도로 동적인 정보에 대해 [=검증가능한 크리덴셜=]이 발급되는 경우,
          구현자는 유효 기간을 적절하게 설정해야 한다. [=검증가능한 크리덴셜=]이
          사용하기 위한 시간 범위보다 더 긴 유효 기간은 악용 가능한 보안
          취약점을 만들 수 있다. [=검증가능한 크리덴셜=]로 표현된 정보가 사용될
          것으로 예상되는 시간 범위보다 더 짧은 유효 기간은 [=보유자=]와
          [=검증자=]에게 부담을 준다. 따라서 [=검증가능한 크리덴셜=]에 포함된
          정보의 사용 사례와 예상 수명에 적합한 [=검증가능한 크리덴셜=]의 유효
          기간을 설정하는 것이 중요하다.
        </p>
      </section>

      <section class="informative">
        <h3>장치 도난 및 사칭</h3>
        <p>
          [=검증가능한 크리덴셜=]이 장치에 저장되어 있고 해당 장치를 분실하거나
          도난당한 경우, 공격자가 피해자의 [=검증가능한 크리덴셜=]을 사용하여
          시스템에 액세스할 수 있다. 이러한 유형의 공격을 완화하는 방법은 다음과
          같다:
        </p>
        <ul>
          <li>
            장치에서 비밀번호, PIN, 패턴 또는 생체 인식 화면 잠금 해제 보호
            사용.
          </li>
          <li>
            [=크리덴셜=] [=리포지토리=]에 대해 비밀번호, 생체 인식 또는 다중
            요소 인증 사용.
          </li>
          <li>
            암호화 키에 액세스할 때 비밀번호, 생체 인식 또는 다중 요소 인증
            사용.
          </li>
          <li>별도의 하드웨어 기반 서명 장치 사용.</li>
          <li>위의 모든 것 또는 조합.</li>
        </ul>
        <p>
          또한 사칭의 사례는 [=엔티티=]가 자신의 행동을 부인하려고 하는 상황을
          포함하여 다양한 형태로 나타날 수 있다. [=검증가능한 크리덴셜=] 영역
          내에서 신뢰와 보안 수준을 높이는 것은 단순히 사칭을 방지하는 것 이상을
          수반한다. 그것은 부인 방지 메커니즘의 구현을 포함하다. 이러한
          메커니즘은 [=엔티티=]의 행동이나 거래에 대한 책임을 강화함으로써
          책임성을 강화하고 악의적인 행동을 억제합니다. 부인 방지의 달성은
          신뢰와 신뢰성을 육성하도록 설계된 다양한 프로토콜에서
          <a href="#securing-mechanisms">보안 메커니즘</a>, 소유 증명, 인증
          체계에 이르는 다양한 기술을 포괄하는 다면적인 노력이다.
        </p>
      </section>
      <section class="informative">
        <h3>허용 가능한 사용</h3>
        <p>
          [=프레젠테이션=]과 같은 [=엔티티=]의 행동과 그러한 행동의 의도된 목적
          사이에 일치가 있는지 확인하는 것이 중요하다. 여기에는 [=검증가능한
          크리덴셜=]을 사용할 수 있는 권한뿐만 아니라 [=크리덴셜=]을 지정된
          범위와 목적에 부합하는 방식으로 사용하는 것이 포함된다. 이 맥락에서
          발생하는 두 가지 중요한 측면은 <i>무단 사용</i>과
          <i>부적절한 사용</i>이다.
        </p>
        <h4>무단 사용</h4>
        <p>
          엔티티가 의도된 용도 외에 [=검증가능한 크리덴셜=]과 [=검증가능한
          프레젠테이션=]을 사용하려는 모든 시도는 무단 사용으로 간주될 수 있다.
          무단 사용의 한 유형은 <i>기밀성 위반</i>이다. [=보유자=]가 나이와 거주
          상태를 입증하기 위해 [=검증자=]와 [=검증가능한 프레젠테이션=]을
          공유하는 예를 고려해 봐라. 만약 [=검증자=]가 데이터를 데이터 브로커에
          판매하는 등 적절한 동의 없이 [=보유자=]의 데이터를 악용한다면, 그것은
          데이터의 무단 사용이며 [=보유자=]가 거래에서 가질 수 있는 프라이버시
          기대를 위반하는 것이다.
        </p>
        <p>
          마찬가지로, [=발급자=]는 <a href="#terms-of-use">termsOfUse</a> 속성을
          사용하여 크리덴셜을 사용할 수 있는 방법과 시기를 규정할 수 있다.
          `termsOfUse`에 정의된 범위 외에서 크리덴셜을 사용하는 [=보유자=]는
          무단 사용으로 간주된다.
        </p>
        <p class="note">
          [=보유자=]가 [=프레젠테이션=] 후에 자신의 데이터의 허가된 사용을
          주장하고 강제할 수 있는 방법을 결정하려면 추가 연구가 필요하다.
        </p>
        <h4>부적절한 사용</h4>
        <p>
          유효한 암호화 서명과 상태 확인의 성공은 [=크리덴셜=]의 신뢰성을
          나타내지만, 모든 [=크리덴셜=]이 모든 맥락에서 상호 교환 가능하다는
          것을 의미하지는 않는다. [=검증자=]는 클레임의 출처와 성격뿐만 아니라
          크리덴셜이 제시되는 특권이나 서비스를 고려하여 관련될 수 있는 모든
          클레임을 <a href="#validation">검증</a>하는 것이 중요하다.
        </p>
        <p>
          예를 들어, 공인된 의학적 진단이 필요한 시나리오에서는 권위 있는 의료
          출처의 유효성이 부족하기 때문에 필요한 데이터를 포함하는 자가 주장
          [=크리덴셜=]로는 충분하지 않을 수 있다. [=크리덴셜=] 사용의 적절성을
          보장하기 위해 이해 관계자는 의도한 애플리케이션의 특정 맥락 내에서
          <a href="#dfn-credential">크리덴셜</a>의 관련성과 권한을 평가해야
          한다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>접근성 고려사항</h2>

      <p>
        구현자가 이 규격에 설명된 데이터를 처리할 때 알고 있어야 할 몇 가지
        접근성 고려사항이 있다. 모든 웹 표준이나 프로토콜의 구현과 마찬가지로,
        접근성 문제를 무시하면 인구의 상당 부분이 이 정보를 사용할 수 없게
        됩니다. 모든 사람이 능력에 관계없이 이 데이터를 사용할 수 있도록 하려면
        [[WCAG21]]과 같은 접근성 지침과 표준을 따르는 것이 중요하다. 이는 특히
        역사적으로 보조 기술에 문제를 야기해 온 암호화를 활용하는 시스템을
        구축할 때 특히 중요하다.
      </p>

      <p>
        이 섹션에서는 이 데이터 모델을 활용할 때 고려해야 할 일반적인 접근성
        고려사항에 대해 자세히 설명한다.
      </p>

      <section class="informative">
        <h3>데이터 우선 접근법</h3>

        <p>
          정부 신분증과 같이 오늘날 사용되는 많은 물리적 [=크리덴셜=]은 작은
          인쇄, 작고 고해상도 이미지에 대한 의존, 시각 장애인을 위한 편의 시설
          부족 등을 포함한 열악한 접근성 특성을 가지고 있다.
        </p>

        <p>
          이 데이터 모델을 활용하여 [=검증가능한 크리덴셜=]을 만들 때, 데이터
          모델 설계자는 <em>데이터 우선</em> 접근 방식을 사용하는 것이 좋다.
          예를 들어, [=크리덴셜=]을 표현하기 위해 데이터나 그래픽 이미지를
          사용하는 선택권이 주어진 경우, 설계자는 기관명이나 전문 [=크리덴셜=]과
          같은 이미지의 모든 요소를 뷰어의 이미지 해석에 의존하는 대신 기계 판독
          가능한 방식으로 표현해야 한다. 데이터 우선 접근 방식을 사용하는 것이
          선호되는 이유는 다양한 능력을 가진 사람들을 위한 다양한 인터페이스를
          구축하는 기본 요소를 제공하기 때문이다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2 id="internationalization-considerations">국제화 고려사항</h2>

      <p>
        구현자는 이 규격에 설명된 데이터를 게시할 때 고려해야 할 여러 국제화
        사항에 유의해야 한다. 모든 웹 표준 또는 프로토콜 구현과 마찬가지로,
        국제화를 무시하면 서로 다른 언어와 사회에서 데이터를 생성하고 사용하기
        어려워지므로 규격의 적용 가능성이 제한되고 표준으로서의 가치가 크게
        감소한다.
      </p>

      <p>
        구현자는 W3C 국제화 활동에서 발행한
        <em>웹에서의 문자열: 언어 및 방향 메타데이터</em> 문서 [[STRING-META]]를
        읽어볼 것을 강력히 권장한다. 이 문서는 국제화를 지원하기 위해 텍스트에
        대한 신뢰할 수 있는 메타데이터를 제공해야 할 필요성에 대해 자세히
        설명한다. 구현자는 최신 국제화 고려사항에 대한 정보를 얻기 위해
        검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를 읽어볼 것을
        권장한다.
      </p>

      <p>
        이 섹션에서는 이 데이터 모델을 활용할 때 고려해야 할 일반적인 국제화
        고려사항을 간략히 설명하며, 구현자가 관심 있어 할
        <em>웹에서의 문자열: 언어 및 방향 메타데이터</em> 문서 [[STRING-META]]의
        특정 부분을 강조하기 위한 것이다.
      </p>

      <section>
        <h3 id="language-and-base-direction">언어와 기본 방향</h3>

        <p>
          데이터 게시자는 [[JSON-LD11]], [[JSON]], CBOR [[?RFC7049]]와 같은 여러
          표현 구문에서 언어 및
          <dfn
            data-cite="i18n-glossary#base-direction"
            data-lt="base-direction|기본 방향"
            >기본 방향</dfn
          >
          정보의 표현이 가능하도록 하기 위해
          <em>웹에서의 문자열: 언어 및 방향 메타데이터</em> 문서
          [[STRING-META]]의 교차 구문 표현 섹션을 읽는 것이 좋다.
        </p>

        <p>
          일반적인 설계 패턴은 언어 및 선택적으로 특정 기본 방향으로 태그된
          텍스트 문자열을 표현할 때 다음 마크업 템플릿을 사용하는 것이다.
        </p>

        <pre
          class="example nohighlight"
          title="Design pattern for natural language strings"
        >
"myProperty": {
  "@value": "<span class="highlight">The string value</span>",
  "@language": "LANGUAGE"
  "@direction": "DIRECTION"
}
        </pre>

        <p>
          언어 값 객체가 문자열 값 대신 사용되는 경우, 객체는 값이 문자열인
          `@value` 속성을 반드시 포함해야 하고, 값이 [[BCP47]]에 정의된 잘
          구성된 `Language-Tag`를 포함하는 문자열인 `@language` 속성을 포함해야
          하며, 값이 [[JSON-LD11]]의 `@direction` 속성에 의해 정의된 [=기본
          방향=] 문자열인 `@direction` 속성을 포함할 수 있다. 언어 값 객체는
          `@value`, `@language`, `@direction` 외에 다른 키를 포함해서는 안 된다.
        </p>

        <p>
          위의 설계 패턴을 사용하여 다음 예제는 텍스트 지시를 지정하지 않고
          영어로 된 책의 제목을 표현한다.
        </p>

        <pre
          class="example nohighlight"
          title="Expressing natural language text as English"
        >
"title": {
  "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
  "@language": "en"
}
        </pre>

        <p>
          The next example uses a similar title expressed in the Arabic language
          with a base direction of right-to-left.
        </p>

        <pre
          class="example nohighlight"
          title="Arabic text with a base direction of right-to-left"
        >
"title": {
  "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "@language": "ar",
  "@direction": "rtl"
}
        </pre>

        <p class="note">
          많은 시스템이 텍스트 문자열의 첫 번째 문자를 사용하여 [=기본 방향=]을
          결정하기 때문에, 위의 텍스트는 언어와 방향을 명시적으로 표현하지
          않으면 왼쪽에서 오른쪽으로 잘못 렌더링될 가능성이 높다.
        </p>

        <p>여러 언어 값 객체를 속성의 배열 값으로 제공할 수 있다:</p>

        <pre
          class="example nohighlight"
          title="Multiple language texts provided for title"
        >
"title": [
  {
    "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
    "@language": "en"
  },
  {
    "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
    "@language": "ar",
    "@direction": "rtl"
  }
]
        </pre>
      </section>

      <section class="substantive">
        <h3>기본 언어와 지시 제공하기</h3>

        <p>
          각 자연어 문자열 속성 값의 언어와 기본 방향는 각 속성 값에 대한 언어
          값 구조를 통해 또는 전체 크리덴셜의 모든 값에 대한 기본 언어와 기본
          방향을 통해 제공되어야 한다. 값 단위 언어 값 구조를 사용하는 것이
          선호되는데, 이는 문서 기본값을 사용하면 다운스트림 프로세서가 JSON-LD
          확장 기반 변환을 수행해야 하는 요구사항이 발생할 수 있기 때문이다.
          자세한 정보는 [[JSON-LD11]] 규격의
          <a data-cite="JSON-LD11#string-internationalization">문자열 국제화</a>
          섹션을 참조하라. 언어가 연결되지 않은 자연어 문자열 값은 언어 값이
          `undefined`(언어 태그 "`und`")인 것처럼 처리해야 한다. 기본 방향가
          연결되지 않은 자연어 문자열 값은 지시 값이 "`auto`"인 것처럼 처리해야
          한다.
        </p>
      </section>

      <section class="informative">
        <h3>복잡한 언어 마크업</h3>

        <p>
          단일 자연어 문자열에 여러 언어나 주석이 포함된 경우, 문자열의 내용을
          올바르게 표시하려면 추가 구조나 마크업이 필요할 수 있다. HTML과 같은
          마크업 언어를 사용하여 서로 다른 언어의 텍스트 범위에 레이블을
          지정하거나
          <dfn
            data-cite="i18n-glossary#bidirectional-text"
            data-lt="양방향 테스트"
            >양방향 테스트</dfn
          >를 올바르게 표시하는 데 필요한 문자열 내부 마크업을 제공할 수 있다.
          또한 `rdf:HTML` 데이터 유형을 사용하여 이러한 값을 JSON-LD에서
          정확하게 인코딩할 수 있다.
        </p>

        <p>
          HTML로 정보를 인코딩할 수 있음에도 불구하고 구현자는 다음과 같은
          이유로 이렇게 하지 않는 것이 좋다:
        </p>

        <ul>
          <li>
            일종의 HTML 프로세서가 필요하므로 언어 및 기본 방향 정보 처리 부담이
            증가한다.
          </li>
          <li>
            무분별하게 HTML을 처리하면 데이터 생성 과정의 어느 시점에서 공격자가
            주입한 `script` 태그를 실행하여 이 데이터 모델을 사용할 때 보안 공격
            표면이 증가한다.
          </li>
        </ul>

        <p>
          구현자가 특정 사용 사례를 해결하기 위해 실행 가능한 스크립트를 포함할
          수 있는 HTML이나 기타 마크업 언어를 사용해야 한다고 생각하는 경우,
          공격자가 마크업을 사용하여 마크업 소비자에 대한 주입 공격을 수행하는
          방법을 분석한 다음 식별된 공격에 대한 완화책을 배포하는 것이 좋다.
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2 id="verification">검증</h2>

      <p>
        이 규격은 [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]의
        [=검증=] 프로세스에 대한 적합성 기준을 제공하지 않지만, 독자는
        [=검증자=]가 [=검증=] 프로세스 중에 이 데이터 모델의 정보를 어떻게
        활용할 것으로 예상되는지 궁금할 수 있다. 이 섹션에서는 [=검증자=]가 이
        규격의 데이터 필드를 사용할 것으로 예상되는 방식과 관련하여 작업 그룹이
        나눈 대화 중 일부를 다룬다.
      </p>

      <section class="informative">
        <h3>Credential Type</h3>

        <p>
          [=검증자=]가 [=보유자=]에게 하나 이상의 [=검증가능한 크리덴셜=]을
          요청할 때, 받고 싶은 크리덴셜의 <a href="#types">타입</a>을 지정할 수
          있다. 크리덴셜 유형과 각 유형 및 해당 [=클레임=]에 대한 검증 스키마는
          규격 작성자에 의해 정의되며 [[[VC-SPECS]]]와 같은 곳에 게시된다.
        </p>

        <p>
          크리덴셜의 유형은 <a href="#types">type</a> 속성을 통해 표현된다. 특정
          유형의 [=검증가능한 크리덴셜=]은 [=검증자=]가 실행하는 일련의 처리
          규칙을 [=프레젠테이션=]이 충족하는지 여부를 결정하는 데 사용될 수 있는
          특정 [=속성=](깊게 중첩될 수 있음)을 포함할 것으로 예상된다. 특정
          `type`의 [=검증가능한 크리덴셜=]을 요청함으로써 [=검증자=]는 각
          [=검증가능한 크리덴셜=]의 [=발급자=]에서 시작되어 [=보유자=]로부터
          특정 정보를 수집할 수 있으며, 이를 통해 [=검증자=]는 [=보유자=]와의
          상호 작용의 다음 단계를 결정할 수 있다.
        </p>

        <p>
          [=검증자=]가 특정 유형의 [=검증가능한 크리덴셜=]을 요청하면 해당
          유형과 연결된 필수 및 선택적 [=클레임=] 집합이 있을 것이다.
          [=검증자=]의 [=검증가능한 크리덴셜=] 검증은 필수 [=클레임=]이 포함되지
          않으면 실패할 것으로 예상되며, 특정 유형과 연결되지 않은 모든
          [=클레임=]은 무시될 것이다. 즉, [=검증자=]는 수신한 [=검증가능한
          크리덴셜=]에 대해 입력 검증을 수행하고 크리덴셜 유형 규격에 따라
          잘못된 입력을 거부한다.
        </p>
      </section>

      <section class="informative">
        <h3>Credential Subject</h3>

        <p>
          [=보유자=]가 제시한 [=검증가능한 크리덴셜=]에서 각
          `credentialSubject`의 `id` [=속성=]과 연결된 값은 [=검증자=]에게
          [=주체=]를 식별할 것으로 예상된다. [=보유자=]가 [=주체=]이기도 한
          경우, [=검증자=]가 [=보유자=]와 관련된 [=검증=] 메타데이터를 가지고
          있다면 [=보유자=]를 인증할 수 있다. 그런 다음 [=검증자=]는
          [=검증가능한 프레젠테이션=]에 포함된 [=보유자=]가 생성한 서명을
          사용하여 [=보유자=]를 인증할 수 있다. `id` [=속성=]은 선택 사항이다.
          [=검증자=]는 [=검증가능한 크리덴셜=]의 다른 [=속성=]을 사용하여
          [=주체=]를 고유하게 식별할 수 있다.
        </p>

        <p class="note">
          [=검증가능한 크리덴셜=]에서 인증 및 WebAuthn이 어떻게 작동하는지에
          대한 정보는 검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를
          참조하라.
        </p>
      </section>

      <section class="informative">
        <h3>Issuer</h3>

        <p>
          `issuer` [=속성=]과 연결된 값은 [=검증자=]에게 알려지고 신뢰할 수 있는
          [=발급자=]를 식별할 것으로 예상된다.
        </p>

        <p>
          `issuer` [=속성=]과 관련된 메타데이터는 섹션
          <a href="#verification"></a>에 정의된
          <a href="#verification">검증 알고리즘</a>을 통해 [=검증자=]에게
          제공된다. 이 메타데이터에는 각 [=검증가능한 크리덴셜=] 또는
          [=검증가능한 프레젠테이션=]을 보호하기 위해 보안 메커니즘에서 사용하는
          검증 방법의 검증된 컨트롤러 식별이 포함되며, 컨트롤러는 일반적으로
          각각 `issuer` 또는 `holder`이다.
        </p>

        <p>
          일부 생태계에서는 [=발급자=]와 검증 방법의 컨트롤러 간에 더 복잡한
          관계가 있을 수 있으며, 위에 설명된 매핑 외에 또는 대신 검증된 발급자
          목록을 사용할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h4>Holder</h4>
        <p>
          `holder` [=속성=]과 연결된 값은 [=검증자=]에게 [=보유자=]를 식별하는
          데 사용할 수 있을 것으로 예상된다.
        </p>

        <p>
          `holder` [=속성=]의 값으로 식별되는 [=보유자=]에 대한 관련
          메타데이터는 종종 [=검증자=]에게 제공되거나 [=검증자=]가 검색할 수
          있다. 예를 들어, [=보유자=]는 [=검증가능한 프레젠테이션=]을 보호하는
          데 사용되는 [=검증 자료=]를 포함하는 정보를 게시할 수 있다. 이
          메타데이터는 [=검증가능한 프레젠테이션=]의 증명을 확인할 때 사용될
          것으로 예상된다. 일부 암호화 식별자는 식별자 자체에 모든 필요한
          메타데이터를 포함한다. 이러한 경우에는 추가 메타데이터가 필요하지
          않다. 다른 식별자는 [=보유자=]의 추가 작업 없이 [=검증자=]가 사용할 수
          있도록 해당 메타데이터가 자동으로 게시되는 검증가능한 데이터
          레지스트리를 사용한다.
        </p>

        <p>
          [=주체=] 및 [=보유자=]와 관련된 추가 예는
          <a data-cite="VC-IMP-GUIDE/#subject-holder-relationships"></a> 및
          <a data-cite="VC-USE-CASES#user-tasks"></a>를 참조하라.
        </p>

        <p class="note">
          검증은 검증자가 [=검증가능한 크리덴셜=]의 특정 사용의 적절성을
          평가하기 위해 비즈니스 규칙을 적용하는 프로세스이다.
        </p>

        <ul>
          <li></li>
        </ul>

        <p>
          [=검증자=]는 복잡한 비즈니스 규칙에 대해 주어진 [=검증가능한
          프레젠테이션=]을 검증해야 할 수 있다. 예를 들어, 검증자는 [=보유자=]가
          [=검증가능한 크리덴셜=]의 [=주체=]와 동일한 엔티티라는 확신이 필요할
          수 있다. 이러한 상황에서 다음 요소는 [=검증자=]에게 포함된
          [=검증가능한 크리덴셜=]에서 해당 식별자와 관련하여 표현된 클레임이
          실제로 현재 프레젠터에 대한 것이라는 합리적인 확신을 제공할 수 있다:
        </p>

        <ul>
          <li>
            [=검증가능한 프레젠테이션=]은 [=검증자=]가 콘텐츠의 무결성을
            보호하기 위해 신뢰하는 메커니즘을 사용하여 보호된다.
          </li>
          <li>
            [=검증가능한 프레젠테이션=]에는 [=검증자=]가 콘텐츠의 무결성을
            보호하기 위해 신뢰하는 메커니즘을 사용하여 보호되는 하나 이상의
            [=검증가능한 크리덴셜=]이 포함된다.
          </li>
          <li>
            [=검증가능한 프레젠테이션=]의 `holder` 속성의 식별자와
            `credentialSubject` 배열의 최소 하나의 객체의 최소 하나의 식별자
            속성이 동일하다.
          </li>
          <li>
            해당 공통 식별자는 해당 [=검증가능한 프레젠테이션=]의 무결성을
            검증하는 데 사용되는 검증 자료를 발견하거나 파생하는 데 사용될 수
            있다.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Issuance Date</h3>

        <p>
          `validFrom`은 [=검증자=]에게 예상되는 범위 내에 있을 것으로 예상된다.
          예를 들어, [=검증자=]는 [=검증가능한 크리덴셜=]의 유효 기간 시작이
          미래가 아닌지 확인할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>Proofs (Signatures)</h3>

        <p>
          [=검증가능한 크리덴셜=] 또는 [=검증가능한 프레젠테이션=]의 정보가
          변조되지 않았음을 증명하는 데 사용되는 보안 메커니즘을
          <em>암호학적 증명</em>이라고 한다. 디지털 서명 및 영지식 증명을
          포함하되 이에 국한되지 않는 많은 유형의 암호학적 증명이 있다.
          일반적으로 암호학적 증명을 검증할 때 구현은 다음을 보장해야 한다:
        </p>

        <ul>
          <li>
            암호학적 증명은 알려진 암호 스위트에 의해 정의된 형식으로 제공된다.
          </li>
          <li>필요한 모든 암호학적 증명 [=속성=]이 존재한다.</li>
          <li>
            데이터에 적용할 때 암호학적 증명 [=검증=] 알고리즘이 허용된 암호학적
            증명으로 귀결된다.
          </li>
        </ul>

        <p>일반적으로 디지털 서명을 검증할 때 구현은 다음을 보장해야 한다:</p>

        <ul>
          <li>
            서명과 관련된 [=검증 자료=]에 대한 허용 가능한 최신 메타데이터를
            사용할 수 있다. 예를 들어, [=검증 자료=]가 공개 키인 경우
            메타데이터에는 유효 기간, 컨트롤러 또는 인증이나 암호화와 같은 공개
            키의 허가된 목적과 관련된 [=속성=]이 포함될 수 있다.
          </li>
          <li>공개 키가 일시 중지, 해지 또는 만료되지 않았다.</li>
          <li>디지털 서명은 검증될 것으로 예상된다.</li>
          <li>보안 메커니즘에 의해 정의된 추가 요구사항이 충족된다.</li>
        </ul>
      </section>

      <section class="informative">
        <h3>Validity Periods</h3>

        <p>
          [=검증자=]는 `validFrom` 및 `validUntil` 속성이 특정 범위 내에 있을
          것으로 예상한다. 예를 들어, [=검증자=]는 [=검증가능한 크리덴셜=]의
          유효 기간 끝이 과거가 아닌지 확인할 수 있다. 일부 크리덴셜은 원래 유효
          기간이 만료되었더라도 보조 목적으로 유용할 수 있기 때문에 `validFrom`
          및 `validUntil` 속성을 사용하여 표현되는 유효 기간은 항상 검증 후에
          수행되는 검증의 구성 요소로 간주된다.
        </p>
      </section>

      <section class="informative">
        <h3>Status</h3>

        <p>
          `credentialStatus` 속성이 사용 가능한 경우, [=검증가능한 크리덴셜=]의
          상태는 [=검증가능한 크리덴셜=]의 `credentialStatus` [=타입=] 정의와
          [=검증자=] 자신의 상태 평가 기준에 따라 [=검증자=]에 의해 평가될
          것으로 예상된다. 예를 들어, [=검증자=]는 [=검증가능한 크리덴셜=]의
          상태가 "[=발급자=]에 의해 취소되지 않았음"을 확인할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>Schema</h3>

        <p>
          `credentialSchema` 속성이 사용 가능한 경우, [=검증가능한 크리덴셜=]의
          스키마는 [=검증가능한 크리덴셜=]의 `credentialSchema` [=타입=] 정의와
          [=검증자=] 자신의 스키마 평가 기준에 따라 [=검증자=]에 의해 평가될
          것으로 예상된다. 예를 들어, `credentialSchema`의 `type` 값이
          [[?VC-JSON-SCHEMA]]인 경우, [=검증자=]는 크리덴셜의 데이터가 주어진
          JSON 스키마에 대해 유효한지 확인할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>Fitness for Purpose</h3>

        <p>
          목적 적합성은 [=검증가능한 크리덴셜=]의 사용자 지정 [=속성=]이
          [=검증자=]의 목적에 적합한지 여부에 관한 것이다. 예를 들어,
          [=검증자=]가 [=주체=]의 나이가 21세 이상인지 확인해야 하는 경우, 특정
          `birthdate` [=속성=] 또는 `ageOver`와 같은 보다 추상적인 [=속성=]에
          의존할 수 있다.
        </p>

        <p>
          [=발급자=]는 [=검증자=]에 의해 현재의 [=클레임=]을 만들 수 있는 것으로
          신뢰된다. 예를 들어, 프랜차이즈 패스트푸드 레스토랑 지점은 프랜차이즈
          본사에서 만든 할인 쿠폰 [=클레임=]을 신뢰한다. [=검증가능한
          크리덴셜=]에서 [=발급자=]가 표현한 정책 정보는 [=보유자=]와
          [=검증자=]가 정책을 무시함으로써 발생하는 책임을 감수하지 않는 한
          [=보유자=]와 [=검증자=]에 의해 존중되어야 한다.
        </p>
      </section>
    </section>

    <section class="appendix">
      <h2>Contexts, Vocabularies, Types, and Credential Schemas</h2>

      <section class="normative">
        <h3>Base Context</h3>

        <p
          class="issue"
          title="(AT RISK) Hash values might change during Candidate Recommendation"
        >
          This section lists cryptographic hash values that might change during
          the Candidate Recommendation phase based on implementer feedback that
          requires the referenced files to be modified.
          <br /><br />
          The Working Group is expecting all of the terms and URLs supplied in
          the JSON-LD Context to be either stabilized, or removed, before the
          publication of this specification as a Proposed Recommendation. While
          that means that this specification could be delayed if dependencies
          such as [[?VC-DATA-INTEGRITY]], [[?VC-JOSE-COSE]], SD-JWT,
          [[?VC-JSON-SCHEMA]], or status list do not enter the Proposed
          Recommendation phase around the same time frame, the Working Group is
          prepared to remove the dependencies if an undue burden is placed on
          transitioning to the Recommendation phase. This is a calculated risk
          that the Working Group is taking and has a mitigation strategy in
          place to ensure the timely transition of this specification to a
          Recommendation.
        </p>
        <p>
          Implementations MUST treat the base context value, located at
          `https://www.w3.org/ns/credentials/v2`, as already retrieved; the
          following value is the SHA-384 digest of the resource computed and
          encoded according to the [[SRI]] definition of `digest`:
          <strong
            >`vxRgTREj3/ZmDabpiTX+Au4UXY8GDhyCSFNw+UQtdtISDyO/znDUY+FTg8rNsGXJ`</strong
          >. It is strongly advised that all JSON-LD Context URLs used by an
          application utilize the same mechanism, or a functionally equivalent
          mechanism, to ensure end-to-end security. Implementations are expected
          to throw errors if a cryptographic hash value for a resource does not
          match the expected hash value.
        </p>
        <p>
          Implementations that apply the base context above, as well as other
          contexts and values in any `@context` property, during operations such
          as
          <a href="https://www.w3.org/TR/json-ld11-api/#expansion-algorithm">
            JSON-LD Expansion</a
          >
          or
          <a
            href="https://www.w3.org/TR/json-ld11/#serializing-deserializing-rdf"
          >
            transformation to RDF</a
          >, are expected to do so without experiencing any errors. If such
          operations are performed and result in an error, the [=verifiable
          credential=] or [=verifiable presentation=] MUST result in a
          verification failure.
        </p>
        <p>
          It is possible to confirm the SHA-384 digest above by running the
          following command from a modern Unix command interface line: `curl -s
          https://www.w3.org/ns/credentials/v2 | openssl dgst -sha384 -binary |
          openssl base64 -A`
        </p>
        <p>
          More details regarding this hash encoding method can be found in the
          <a href="https://www.w3.org/TR/SRI/#integrity-metadata"
            >integrity metadata</a
          >
          section of [[SRI]].
        </p>
        <p class="note" title="See errata if hash value changes are detected">
          It is extremely unlikely that the files that have associated
          cryptographic hash values in this specification will change. However,
          if critical errata are found in the specification and corrections are
          required to ensure ecosystem stability the cryptographic hash values
          might change. As such, the HTTP cache times for the files are not set
          to infinity and implementers are advised to check for errata if a
          cryptographic hash value change is detected.
        </p>
        <p>
          This section serves as a reminder of the importance of ensuring that,
          when verifying [=verifiable credentials=] and [=verifiable
          presentations=], the [=verifier=] has information that is consistent
          with what the [=issuer=] or [=holder=] had when securing the
          [=credential=] or [=presentation=]. This information might include at
          least:
        </p>
        <ol>
          <li>
            The contents of the credential itself, which is secured in
            [=verifiable credentials=] and [=verifiable presentations=] by using
            mechanisms such as [[VC-JOSE-COSE]] and [[VC-DATA-INTEGRITY]].
          </li>
          <li>
            The content in a credential whose meaning depends on a link to an
            external URL, such as a JSON-LD Context, which can be secured by
            using a local static copy or a cryptographic digest of the file.
          </li>
        </ol>
        <p>
          Verifiers are warned that other data that is referenced from within a
          credential, such as resources that are linked to via URLs, are not
          cryptographically protected by default. It is considered a best
          practice to ensure that the same sorts of protections are provided for
          any URL that is critical to the security of the [=verifiable
          credential=] through the use of permanently cached files and/or
          cryptographic hashes. See the
          <a data-cite="?vc-imp-guide/#content-integrity">Content Integrity</a>
          section of the Verifiable Credential Implementation Guide for further
          information. Ultimately, knowing the cryptographic digest of any
          linked external content enables a [=verifier=] to confirm that the
          content is the same as what the [=issuer=] or [=holder=] intended.
        </p>
      </section>

      <section class="normative">
        <h3>Vocabularies</h3>

        <p
          class="issue"
          title="(AT RISK) URL values might change during Candidate Recommendation"
        >
          This section lists URL values that might change during the Candidate
          Recommendation phase based on migration of documents to time-stamped
          locations, migration of documents to the W3C Technical Reports
          namespace, and/or implementer feedback that requires the referenced
          URLs to be modified.
        </p>

        <p>
          Implementations that depend on RDF vocabulary processing MUST ensure
          that the following vocabulary URLs used in the base context ultimately
          resolve to the following files when loading the JSON-LD
          serializations, which are normative. Other semantically equivalent
          serializations of the vocabulary files MAY be used by implementations.
          Cryptographic hashes are provided for all the JSON-LD content to
          ensure that developers can verify that the content of each file is
          correct.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>URL</th>
              <th>JSON-LD Content and Hashes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>https://www.w3.org/2018/credentials#</td>
              <td>
                https://www.w3.org/2018/credentials/index.jsonld<br /><br />
                sha256: `z52TgKqh2nqTCuACI8lCvhRdjwxQjeVmuOMCDCEijq4=`<br /><br />
                sha3-512:
                <code
                  >m8Ss+jgZiyL2Ws/ICJcWjHFd9PccJWsXPvMatBOhrH<wbr />
                  h0qCBrzfgO2zO1OQQbTL7zoPgLseIbcxJJpunD2bkoRA==</code
                >
              </td>
            </tr>
            <tr>
              <td>https://w3id.org/security#</td>
              <td>
                https://w3c.github.io/vc-data-integrity/vocab/security/vocabulary.jsonld<br /><br />
                sha256: `LEaoTyf796eTaSlYWjfPe3Yb+poCW9TjWYTbFDmC0tc=`<br /><br />
                sha3-512:
                <code
                  >f4DhJ3xhT8nT+GZ8UUZi4QC+HT//wXE2fRTgUP4UNw<wbr />
                  e4kvel2PFfd6jcofHBm9BjwEiGzVFGv4K+fFTKXRD2NA==</code
                >
              </td>
            </tr>
          </tbody>
        </table>

        <p>
          It is possible to confirm the cryptographic digests listed above by
          running a command like the following (replacing `&lt;DOCUMENT_URL>`
          and `&lt;DIGEST_ALGORITHM>` with appropriate values) through a modern
          UNIX-like OS command line interface: `curl -sL -H "Accept:
          application/ld+json" &lt;DOCUMENT_URL> | openssl dgst
          -&lt;DIGEST_ALGORITHM> -binary | openssl base64 -nopad -a`
        </p>

        <p
          class="note"
          title="schema.org changes regularly, but is considered stable"
        >
          Implementers and document authors might note that cryptographic
          digests for `schema.org` are not provided. This is because the
          `schema.org` vocabulary undergoes regular changes; any digest provided
          would be out of date within weeks of publication. The Working Group
          discussed this concern and concluded that the vocabulary terms from
          `schema.org`, that are used by this specification, have been stable
          for years and are highly unlikely to change in their semantic meaning.
        </p>

        <p>
          The following base classes are defined in this specification for
          processors and other specifications that benefit from such
          definitions:
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>Base Class</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr id="bc-credential-evidence">
              <td>`CredentialEvidence`</td>
              <td>
                Serves as a superclass for specific evidence types that are
                placed into the
                <a href="#evidence">evidence</a> property.
                <span class="issue atrisk"
                  >This superclass is at risk and will be removed if at least
                  two independent implementations for the superclass are not
                  identified by the end of the Candidate Recommendation
                  phase.</span
                >
              </td>
            </tr>
            <tr id="bc-credential-schema">
              <td>`CredentialSchema`</td>
              <td>
                Serves as a superclass for specific schema types that are placed
                into the
                <a href="#data-schemas">credentialSchema</a> property.
              </td>
            </tr>
            <tr id="bc-credential-status">
              <td>`CredentialStatus`</td>
              <td>
                Serves as a superclass for specific credential status types that
                are placed into the
                <a href="#status">credentialStatus</a> property.
              </td>
            </tr>
            <tr id="bc-confidence-method">
              <td>`ConfidenceMethod`</td>
              <td>
                Serves as a superclass for specific confidence method types that
                are placed into the `confidenceMethod` property.
                <span class="issue atrisk"
                  >This superclass is at risk and will be removed if at least
                  two independent implementations for the superclass are not
                  identified by the end of the Candidate Recommendation phase.
                </span>
              </td>
            </tr>
            <tr id="bc-refresh-service">
              <td>`RefreshService`</td>
              <td>
                Serves as a superclass for specific refresh service types that
                are placed into the
                <a href="#refreshing">credentialRefresh</a> property.
                <span class="issue atrisk"
                  >This superclass is at risk and will be removed if at least
                  two independent implementations for the superclass are not
                  identified by the end of the Candidate Recommendation phase.
                </span>
              </td>
            </tr>
            <tr id="bc-render-method">
              <td>`RenderMethod`</td>
              <td>
                Serves as a superclass for specific render method types that are
                placed into the `renderMethod` property.
                <span class="issue atrisk"
                  >This superclass is at risk and will be removed if at least
                  two independent implementations for the superclass are not
                  identified by the end of the Candidate Recommendation phase.
                </span>
              </td>
            </tr>
            <tr id="bc-terms-of-use">
              <td>`TermsOfUse`</td>
              <td>
                Serves as a superclass for specific terms of use types that are
                placed into the <a href="#terms-of-use">termsOfUse</a> property.
                <span class="issue atrisk"
                  >This superclass is at risk and will be removed if at least
                  two independent implementations for the superclass are not
                  identified by the end of the Candidate Recommendation phase.
                </span>
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section>
        <h3>Datatypes</h3>
        <p>
          This section defines datatypes that are used by this specification.
        </p>

        <section>
          <h4>The `sriString` Datatype</h4>

          <p>
            The string provides the integrity information for a resource using
            the method specified in the [[SRI]] specification.
          </p>

          <p>The `sriString` datatype is defined as follows:</p>

          <dl>
            <dt>The URL denoting this datatype</dt>
            <dd>`https://www.w3.org/2018/credentials#sriString`</dd>
            <dt>The lexical space</dt>
            <dd>
              See the
              <a href="https://www.w3.org/TR/SRI/#the-integrity-attribute"
                >ABNF grammar</a
              >, defining the `integrity` attribute in the [[SRI]]
              specification, for the restrictions on the string format.
            </dd>
            <dt>The value space</dt>
            <dd>
              A (possibly empty) list of <i>(alg,val)</i> pairs, where
              <i>alg</i> identifies a hash function, and <i>val</i> is an
              integer as a standard mathematical concept.
            </dd>
            <dt>The lexical-to-value mapping</dt>
            <dd>
              Any element of the lexical space is mapped to the value space by
              following the
              <a href="https://www.w3.org/TR/SRI/#parse-metadata"
                >parse metadata algorithm</a
              >
              based on the
              <a href="https://www.w3.org/TR/SRI/#the-integrity-attribute"
                >ABNF grammar</a
              >
              in the [[SRI]] specification.
            </dd>
            <dt>The canonical mapping</dt>
            <dd>
              The canonical mapping consists of the lexical-to-value mapping.
            </dd>
          </dl>
        </section>
      </section>

      <section class="informative">
        <h3>Differences between Contexts, Types, and CredentialSchemas</h3>

        <p>
          The [=verifiable credential=] and [=verifiable presentation=] data
          models leverage a variety of underlying technologies including
          [[JSON-LD11]] and [[?VC-JSON-SCHEMA]]. This section will provide a
          comparison of the `@context`, `type`, and `credentialSchema`
          properties, and cover some of the more specific use cases where it is
          possible to use these features of the data model.
        </p>

        <p>
          The `type` property is used to uniquely identify the type of the
          [=verifiable credential=] in which it appears, i.e., to indicate which
          set of claims the [=verifiable credential=] contains. This property,
          and the value `VerifiableCredential` within the set of its values, are
          mandatory. Whilst it is good practice to include one additional value
          depicting the unique subtype of this [=verifiable credential=], it is
          permitted to either omit or include additional type values in the
          array. Many verifiers will request a [=verifiable credential=] of a
          specific subtype, then omitting the subtype value could make it more
          difficult for verifiers to inform the holder which [=verifiable
          credential=] they require. When a [=verifiable credential=] has
          multiple subtypes, listing all of them in the `type` property is
          sensible. The usage of the `type` property in a [[JSON-LD11]]
          representation of a [=verifiable credential=] enables to enforce the
          semantics of the [=verifiable credential=] because the machine is able
          to check the semantics. With [[JSON-LD11]], the technology is not only
          describing the categorization of the set of claims, the technology is
          also conveying the structure and semantics of the sub-graph of the
          properties in the graph. In [[JSON-LD11]], this represents the type of
          the node in the graph which is why some [[JSON-LD11]] representations
          of a [=verifiable credential=] will use the `type` property on many
          objects in the [=verifiable credential=].
        </p>

        <p>
          The primary purpose of the `@context` property, from a [[JSON-LD11]]
          perspective, is to convey the meaning of the data and term definitions
          of the data in a [=verifiable credential=], in a machine readable way.
          The `@context` property is used to map the globally unique URLs for
          properties in [=verifiable credentials=] and [=verifiable
          presentations=] into short-form alias names, making [[JSON-LD11]]
          representations more human-friendly to read. From a [[JSON-LD11]]
          perspective, this mapping also allows the data in a [=credential=] to
          be modeled in a network of machine-readable data, by enhancing how the
          data in the [=verifiable credential=] or [=verifiable presentation=]
          relates to a larger machine-readable data graph. This is useful for
          telling machines how to relate the meaning of data to other data in an
          ecosystem where parties are unable to coordinate. This property, with
          the first value in the set being
          `https://www.w3.org/ns/credentials/v2`, is mandatory.
        </p>

        <p>
          Since the `@context` property is used to map data to a graph data
          model, and the `type` property in [[JSON-LD11]] is used to describe
          nodes within the graph, the `type` property becomes even more
          important when using the two properties in combination. For example,
          if the `type` property is not included within the resolved `@context`
          resource using [[JSON-LD11]], it could lead to claims being dropped
          and/or their integrity no longer being protected during production and
          consumption of the [=verifiable credential=]. Alternatively, it could
          lead to errors being raised during production or consumption of a
          [=verifiable credential=]. This will depend on the design choices of
          the implementation and both paths are used in implementations today,
          so it's important to pay attention to these properties when using a
          [[JSON-LD11]] representation of a [=verifiable credential=] or
          [=verifiable presentation=].
        </p>

        <p>
          The primary purpose of the `credentialSchema` property is to define
          the structure of the [=verifiable credential=], and the datatypes for
          the values of each property that appears. A `credentialSchema` is
          useful for defining the contents and structure of a set of claims in a
          [=verifiable credential=], whereas [[JSON-LD11]] and a `@context` in a
          [=verifiable credential=] are best used only for conveying the
          semantics and term definitions of the data, and can be used to define
          the structure of the [=verifiable credential=] as well.
        </p>

        <p>
          While it is possible to use some [[JSON-LD11]] features to allude to
          the contents of the [=verifiable credential=], it's not generally
          suggested to use `@context` to constrain the data types of the data
          model. For example, `"@type": "@json"` is useful for leaving the
          semantics open-ended and not strictly defined. This can be dangerous
          if the implementer is looking to constrain the data type of the claims
          in the [=credential=], and is expected not to be used.
        </p>

        <p>
          When the `credentialSchema` and `@context` properties are used in
          combination, both producers and consumers can be more confident about
          the expected contents and data types of the [=verifiable credential=]
          and [=verifiable presentation=].
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2>IANA Considerations</h2>

      <p>
        This section will be submitted to the Internet Engineering Steering
        Group (IESG) for review, approval, and registration with IANA.
      </p>

      <section id="vc-ld-media-type">
        <h2>application/vc+ld+json</h2>
        <p>
          This specification registers the `application/vc+ld+json` Media Type
          specifically for identifying documents conforming to the Verifiable
          Credentials format.
        </p>
        <table>
          <tr>
            <td>Type name:</td>
            <td>application</td>
          </tr>
          <tr>
            <td>Subtype name:</td>
            <td>vc+ld+json</td>
          </tr>
          <tr>
            <td>Required parameters:</td>
            <td>None</td>
          </tr>
          <tr>
            <td>Encoding considerations:</td>
            <td>
              Resources that use the "`application/vc+ld+json`" Media Type are
              required to conform to all of the requirements for the
              "`application/ld+json`" Media Type and are therefore subject to
              the same encoding considerations specified in Section 11 of
              [[RFC7159]].
            </td>
          </tr>
          <tr>
            <td>Security considerations:</td>
            <td>As defined in this specification.</td>
          </tr>
          <tr>
            <td>Contact:</td>
            <td>
              W3C Verifiable Credentials Working Group
              <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
            </td>
          </tr>
        </table>

        <p>
          Note that while the Verifiable Credentials format uses JSON-LD
          conventions, there are a number of constraints and additional
          requirements for Verifiable Credential implementations that justify
          the use of a specific media type.
        </p>

        <p>
          This media type can be used for credentials secured using an
          [=enveloping proof=].
        </p>
        <p>
          A [[JSON-LD11]] context is expected to be present in the body of the
          document, and as indicated by the presence of `ld+json` in the media
          type, the credential is expected to be a valid
          <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document"
            >JSON-LD document</a
          >.
        </p>
      </section>

      <section id="vp-ld-media-type">
        <h2>application/vp+ld+json</h2>
        <p>
          This specification registers the `application/vp+ld+json` Media Type
          specifically for identifying documents conforming to the Verifiable
          Presentations format.
        </p>
        <table>
          <tr>
            <td>Type name:</td>
            <td>application</td>
          </tr>
          <tr>
            <td>Subtype name:</td>
            <td>vp+ld+json</td>
          </tr>
          <tr>
            <td>Required parameters:</td>
            <td>None</td>
          </tr>
          <tr>
            <td>Encoding considerations:</td>
            <td>
              Resources that use the "`application/vp+ld+json`" Media Type are
              required to conform to all of the requirements for the
              "`application/ld+json`" Media Type and are therefore subject to
              the same encoding considerations specified in Section 11 of
              [[RFC7159]].
            </td>
          </tr>
          <tr>
            <td>Security considerations:</td>
            <td>As defined in this specification.</td>
          </tr>
          <tr>
            <td>Contact:</td>
            <td>
              W3C Verifiable Credentials Working Group
              <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
            </td>
          </tr>
        </table>

        <p>
          Note that while the Verifiable Credentials format uses JSON-LD
          conventions, there are a number of constraints and additional
          requirements for Verifiable Credential implementations that justify
          the use of a specific media type.
        </p>

        <p>
          This media type can be used for presentations secured using an
          [=enveloping proof=].
        </p>
        <p>
          A [[JSON-LD11]] context is expected to be present in the body of the
          document, and as indicated by the presence of `ld+json` in the media
          type, the credential is expected to be a valid
          <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document"
            >JSON-LD document</a
          >.
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2>Additional Diagrams for Verifiable Presentations</h2>

      <p>
        <a href="#info-graph-vp-mult-creds"></a> below is a variant of
        <a href="#info-graph-vp"></a>: a [=verifiable presentation=] referring
        to two [=verifiable credentials=], and using [=embedded proofs=] based
        on [[?VC-DATA-INTEGRITY]]. Each [=verifiable credential graph=] is
        connected to its own separate [=proof graph=]; the
        `verifiableCredential` property is used to connect the [=verifiable
        presentation=] to the [=verifiable credential graphs=]. The
        [=presentation=] [=proof graph=] represents the digital signature of the
        [=verifiable presentation graph=], both [=verifiable credential
        graphs=], and the [=proof graphs=] linked from the [=verifiable
        credential graphs=]. The complete [=verifiable presentation=] consists,
        in this case, of six information [=graphs=].
      </p>

      <figure id="info-graph-vp-mult-creds">
        <img
          style="margin: auto; display: block; width: 100%"
          src="diagrams/vp-graph-mult-creds.svg"
          alt="
Diagram with a 'verifiable presentation graph' on top, connected via a
'proof' to a 'verifiable presentation proof graph' on the bottom. The
verifiable presentation graph has an object, 'Presentation ABC', with 3
properties: 'type' with value 'VerifiablePresentation'; 'termsOfUse' with
value 'Do Not Archive'; and two instances of 'verifiableCredential',
detailed below. This graph is annotated with a parenthetical remark, '(the
default graph)'. This graph is connected, through 'verifiableCredential',
to the part of the figure that consists two variants of Figure 6 (one is
identical; the other has minor differences in the labels referring to
validity dates, the name of the person, and the values for the nonce and
the signature), except that these verifiable credential graphs are
annotated to be named graphs instead of a default graph. The verifiable
presentation proof graph has an object labeled 'Signature 8920' with 5
properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod'
with value 'Example Presenter Public Key 11'; 'created' with value
'2024-01-02T12:43:56Z'; 'nonce' with value 'hasdkyruod87j'; and
'proofValue' with value 'zpewJHoan87='. This graph is annotated with the
parenthetical remark '(a named graph)'
            "
        />
        <figcaption style="text-align: center">
          A variant of <a href="#info-graph-vp"></a>: information [=graphs=]
          associated with a [=verifiable presentation=] referring to two
          verifiable credentials, using an [=embedded proof=] based on
          [[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]].
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vp-jwt-mult-creds"></a> below shows the same
        [=verifiable presentation=] as <a href="#info-graph-vp-mult-creds"></a>,
        but using an [=enveloping proof=] based on [[?VC-JOSE-COSE]]. Each
        [=verifiable credential graph=] contains a single
        <a href="#defn-EnvelopedVerifiableCredential"
          >`EnvelopedVerifiableCredential`</a
        >
        instance, referring, via a `data:` URL [[RFC2397]], to a verifiable
        credential secured via an [=enveloping proof=].
      </p>

      <figure id="info-graph-vp-jwt-mult-creds">
        <img
          style="margin: auto; display: block; width: 100%"
          src="diagrams/vp-jwt-mult-creds.svg"
          alt="
Diagram with, on the left, a box, labeled as 'JWT (Decoded)', and with
three textual labels stacked vertically, namely 'Header', 'Payload', and
'Signature'. The 'Header' label is connected, with an arrow, to a
separate rectangle on the right hand side containing six text fields:
'kid: aB8J-_Z', 'alg: ES384', and 'cty: vc+ld+json', iss:
https://example.com, iat: 1704690029, and typ: vp+ld+json+sd-jwt The
'Payload' label of the left side is connected, with an arrow, to a
separate rectangle, consisting of three related graphs (stacked
vertically) connected by two arrows labeled 'verifiableCredential'
starting from the top graph and connecting it to the two other graphs,
respectively. The top graph has a label 'verifiable presentation graph
(serialized in JSON)'; the other two are both labeled by 'verifiable
credential graph (serialized in JSON)'. The top graph in the rectangle
has and object 'Presentation ABC' with 3 properties: 'type' of value
VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. One of
the the bottom graphs includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`. The
last bottom graph is identical other, except for the subject which is
labeled as 'data:application/vc+ld+json+sd-jwt;RkOyT...KjOl'. Finally,
the 'Signature' label on the left side is connected, with an arrow, to a
separate rectangle, containing a single text field:
'cYjaSdfIoJH45NIqw3MYnasGIba...'.
        "
        />
        <figcaption style="text-align: center">
          A variant of <a href="#info-graph-vp-jwt"></a>: information [=graphs=]
          associated with a [=verifiable presentation=] referring to two
          verifiable credentials using [=enveloping proofs=] based on JOSE
          [[?VC-JOSE-COSE]].
        </figcaption>
      </figure>
    </section>

    <section>
      <h2>Revision History</h2>

      <p>
        This section contains the substantive changes that have been made to
        this specification over time.
      </p>

      <p>
        Changes since the
        <a href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/">
          v1.1 Recommendation</a
        >:
      </p>
      <ul>
        <li>
          Many editorial updates and fixes to modernize the specification and
          make it easier to understand particular concepts.
        </li>
        <li>
          Remove duplicated statements regarding `proof` between Data Integrity
          and this specification.
        </li>
        <li>Clarify how issuer validation occurs.</li>
        <li>Clarify requirements for securing mechanism extension points.</li>
        <li>Add dependency on [[?INFRA]] for algorithm section.</li>
        <li>Add requirements for securing mechanism specifications.</li>
        <li>Clarify how to perform type-specific credential processing.</li>
        <li>
          Add mechanism to embed enveloped verifiable credentials in verifiable
          presentations.
        </li>
        <li>
          Add verification algorithm, interface to securing mechanisms, and
          ProblemDetails objects.
        </li>
        <li>Fine tune allowable values for `issuer` property.</li>
        <li>
          Provide more concrete guidance on how to express language information
          as well as default language and direction.
        </li>
        <li>
          Add new conformance classes for issuer and verifier implementations.
        </li>
        <li>Add new Security Considerations regarding key management.</li>
        <li>
          Add new Privacy Considerations for trust boundaries, metadata-based
          correlation, data theft, and use of Oblivious HTTP.
        </li>
        <li>Formally define base classes and properties for vocabulary.</li>
        <li>
          Provide warnings around not using advanced JSON-LD features in order
          to maximize interoperability.
        </li>
        <li>Provide more explicit guidance around sets and arrays.</li>
        <li>
          Add support for `name` and `description` fields for issuers and
          credentials.
        </li>
        <li>
          Add security considerations around interception, replay, and spoofing
          attacks.
        </li>
        <li>Add JWT and SD-JWT claims to base JSON-LD Context.</li>
        <li>
          Clarify the difference between a "credential" and a "verifiable
          credential".
        </li>
        <li>Add section on how to ensure ecosystem compatibility.</li>
        <li>Add section on type-specific credential processing.</li>
        <li>Add section on validation and relevance to holders.</li>
        <li>Add section on media type precision and interpretation.</li>
        <li>
          Ensure that `dateTimeStamp` is used for time values. Provide further
          guidance on proper usage of time values and timezones.
        </li>
        <li>Make `validFrom` optional.</li>
        <li>Add `relatedResource` feature.</li>
        <li>
          Make base context and vocabularies normative and provide cryptographic
          hashes for their content.
        </li>
        <li>
          Add `renderMethod` and `confidenceMethod` to list of reserved
          properties.
        </li>
        <li>Modernize examples in the specification.</li>
        <li>Add "Getting Started" section.</li>
        <li>
          Add table of reserved properties for properties that are not yet
          standardized or are at risk for removal.
        </li>
        <li>
          Restrict data model serialization to JSON-LD in compacted document
          form.
        </li>
        <li>Update ZKP section to remove older content.</li>
        <li>Add `termsOfUse` to presentations in v2 context.</li>
        <li>Add default vocabulary for undefined terms to v2 context.</li>
        <li>
          Add media types for `application/vc+ld+json` and
          `application/vp+ld+json`.
        </li>
        <li>
          Provide guidance on converting to and from conforming documents from
          other digital credential formats.
        </li>
        <li>Change reference to URI/IRI to use WHATWG URL specification.</li>
        <li>
          Add normative dependency on Data Integrity and JOSE/COSE securing
          mechanisms.
        </li>
        <li>
          Rename `issuanceDate`/`expirationDate` to `validFrom`/`validUntil`.
        </li>
        <li>Add JSON Schema support and update examples to use new format.</li>
        <li>Clarify that `credentialSubject` values cannot be strings.</li>
        <li>
          Create more formal vocabulary document that refers to this
          specification.
        </li>
        <li>Define v2.0 JSON-LD Context.</li>
        <li>Migrate VC-JWT section to separate securing specification.</li>
        <li>
          Move Subject-Holder relationships to Verifiable Credential
          implementation guide.
        </li>
        <li>
          Increment version number to v2.0 and remove prior REC-track comments.
        </li>
        <li>
          Add normative dependency on Verifiable Credential Data Integrity
          specification [[VC-DATA-INTEGRITY]].
        </li>
        <li>
          The section on
          <a
            href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/#disputes"
            >Disputes</a
          >
          was removed due to lack of implementations in v1.0 and v1.1.
        </li>
      </ul>

      <p>
        Changes since the
        <a href="https://www.w3.org/TR/2019/REC-vc-data-model-20191119/">
          v1.0 Recommendation</a
        >:
      </p>
      <ul>
        <li>Add this revision history section.</li>

        <li>
          Update previous normative references that pointed to RFC3339 for
          datetime details to now normatively reference the datetime details
          described in XMLSCHEMA11-2 which more accurately reflects the usage in
          examples and libraries.
        </li>

        <li>
          Loosen the requirement to allow [=URLs=] that cannot be dereferenced
          in the `id` property of the `credentialStatus` and `refreshService`
          sections of the data model.
        </li>

        <li>
          Loosen normative statements in the zero-knowledge proofs section to
          enable compliance of new zero-knowledge proof schemes, such as BBS+,
          that have been created since the v1.0 specification was published as a
          Recommendation.
        </li>

        <li>
          Update all references to point to the latest version of the referenced
          specifications. Fix broken links to papers that have become
          unavailable to updated locations where the papers are available.
        </li>

        <li>Increase accessibility of SVG diagrams.</li>

        <li>
          Fix editorial bugs in a few examples related to `issuer`,
          `issuanceDate`, `credentialStatus`, dates, dead links, and minor
          syntax errors.
        </li>

        <li>
          Move acknowledgements from Status of the Document section into the
          Acknowledgements appendix.
        </li>
      </ul>
    </section>

    <section class="appendix informative">
      <h2>Acknowledgements</h2>

      <p>
        The Working Group thanks the following individuals not only for their
        contributions toward the content of this document, but also for yeoman's
        work in this standards community that drove changes, discussion, and
        consensus among a sea of varied opinions: Matt Stone, Gregg Kellogg, Ted
        Thibodeau Jr, Oliver Terbu, Joe Andrieu, David I. Lehn, Matthew Collier,
        and Adrian Gropper.
      </p>

      <p>
        Work on this specification has been supported by the Rebooting the Web
        of Trust community facilitated by Christopher Allen, Shannon Appelcline,
        Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young, Manu Sporny,
        Drummond Reed, Joe Andrieu, Heather Vescent, Kim Hamilton Duffy,
        Samantha Chase, and Andrew Hughes. The participants in the Internet
        Identity Workshop, facilitated by Phil Windley, Kaliya Young, Doc
        Searls, and Heidi Nobantu Saul, also supported the refinement of this
        work through numerous working sessions designed to educate about, debate
        on, and improve this specification.
      </p>

      <p>
        The Working Group also thanks our Chairs, Dan Burnett, Matt Stone, Brent
        Zundel, Wayne Chang, and Kristina Yasuda as well as our W3C Staff
        Contacts, Kazuyuki Ashimura and Ivan Herman, for their expert management
        and steady guidance of the group through the W3C standardization
        process.
      </p>

      <p>
        Portions of the work on this specification have been funded by the
        United States Department of Homeland Security's Science and Technology
        Directorate under contract HSHQDC-17-C-00019. The content of this
        specification does not necessarily reflect the position or the policy of
        the U.S. Government and no official endorsement should be inferred.
      </p>

      <p>
        The Working Group would like to thank the following individuals for
        reviewing and providing feedback on the specification (in alphabetical
        order):
      </p>

      <p>
        Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
        Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
        Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
        Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
        Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
        Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
        Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
        David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
        Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
        David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
        Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
        Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
        O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric
        Prud'hommeaux, Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens,
        Justin Richer, Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley,
        Markus Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu
        Sporny, Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John
        Tibbetts, Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer
        Webber, Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent
        Zundel.
      </p>
    </section>
  </body>
</html>
