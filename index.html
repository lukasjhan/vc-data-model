<!DOCTYPE html>
<html>
  <head>
    <title>
      검증가능한 크리덴셜 데이터 모델(Verifiable Credentials Data Model v1.1)
    </title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script
      class="remove"
      src="https://unpkg.com/browse/jquery/dist/jquery.min.js"
    ></script>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
    ></script>
    <script src="./common.js" class="remove"></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        group: 'vc',

        // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: 'REC',

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: 'vc-data-model',

        // subtitle for the spec
        subtitle: 'Expressing verifiable information on the Web',

        // if you wish the publication date to be other than today, set this
        publishDate: '2021-11-09',
        //crEnd: "2019-08-21",
        //prEnd: "2019-10-01",
        implementationReportURI:
          'https://w3c.github.io/vc-test-suite/implementations/',
        errata: 'https://w3c.github.io/vc-data-model/errata.html',
        previousMaturity: 'REC',
        previousPublishDate: '2019-11-19',

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: vcwg.localBiblio,
        doJsonLd: true,

        // Uncomment these to use the respec extension that generates a list of
        //   normative statements:
        preProcess: [
          /*prepare_reqlist*/
        ],
        postProcess: [, /*add_reqlist_button*/ restrictRefs],

        github: 'https://github.com/w3c/vc-data-model/',
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: 'https://w3c.github.io/vc-data-model/',

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          {
            name: 'Manu Sporny',
            url: 'https://www.linkedin.com/in/manusporny/',
            company: 'Digital Bazaar',
            companyURL: 'http://digitalbazaar.com/',
            note: 'v1.0, v1.1',
          },
          {
            name: 'Grant Noble',
            url: 'https://www.linkedin.com/in/grant-noble-8253994a/',
            company: 'ConsenSys',
            companyURL: 'https://consensys.net/',
            note: 'v1.0',
          },
          {
            name: 'Dave Longley',
            url: 'https://github.com/dlongley',
            company: 'Digital Bazaar',
            companyURL: 'http://digitalbazaar.com/',
            note: 'v1.0',
          },
          {
            name: 'Daniel C. Burnett',
            url: 'https://www.linkedin.com/in/daburnett/',
            company: 'ConsenSys',
            companyURL: 'https://consensys.net/',
            note: 'v1.0',
          },
          {
            name: 'Brent Zundel',
            url: 'https://www.linkedin.com/in/bzundel/',
            company: 'Evernym',
            companyURL: 'https://www.evernym.com/',
            note: 'v1.0',
          },
          {
            name: 'Kyle Den Hartog',
            url: 'https://www.linkedin.com/in/kyledenhartog/',
            company: 'MATTR',
            companyURL: 'https://mattr.global/',
            note: 'v1.1',
          },
        ],
        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors: [
          {
            name: 'Manu Sporny',
            url: 'http://digitalbazaar.com/',
            company: 'Digital Bazaar',
            companyURL: 'http://digitalbazaar.com/',
          },
          {
            name: 'Dave Longley',
            url: 'http://digitalbazaar.com/',
            company: 'Digital Bazaar',
            companyURL: 'http://digitalbazaar.com/',
          },
          {
            name: 'David Chadwick',
            url: 'https://www.linkedin.com/in/david-chadwick-36816395/',
            company: 'University of Kent',
            companyURL: 'https://www.kent.ac.uk/',
          },
        ],

        maxTocLevel: 2,
        inlineCSS: true,
      };
    </script>
    <style>
      pre .highlight {
        font-weight: bold;
        color: Green;
      }
      pre .subject {
        font-weight: bold;
        color: RoyalBlue;
      }
      pre .property {
        font-weight: bold;
        color: DarkGoldenrod;
      }
      pre .comment {
        font-weight: bold;
        color: SteelBlue;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      .color-text {
        font-weight: bold;
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        <a>크리덴셜</a>은 우리 일상생활의 한 부분이다. 운전면허증은 우리가
        자동차를 운전할 수 있는 능력이 있음을 주장하는 데 사용되고, 대학 학위는
        우리의 교육 수준을 주장하는 데 사용될 수 있으며, 정부에서 발급한 여권은
        우리가 국가 간에 여행할 수 있게 해준다. 이 규격은 이러한 종류의
        <a>크리덴셜</a>을 암호학적으로 안전하고, 프라이버시를 존중하며,
        기계적으로 검증 가능한 방식으로 웹에서 표현할 수 있는 메커니즘을
        제공한다.
      </p>
    </section>

    <section id="sotd">
      <p>
        Comments regarding this document by the W3C Advisory Committee are
        welcome before January 14th 2021, but readers should be aware that the
        comment period regarding the rest of this document has ended and the
        Working Group is unlikley to make substantive modifications to the
        specification at this stage. Please file issues directly on
        <a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>, or
        send them to
        <a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
        (<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe"
          >subscribe</a
        >,
        <a href="https://lists.w3.org/Archives/Public/public-vc-comments/"
          >archives</a
        >).
      </p>

      <p>
        The Working Group has received implementation feedback showing that
        there are at least two implementations for each normative feature in the
        specification. The group has obtained reports from fourteen (14)
        implementations. For details, see the
        <a href="https://github.com/w3c/vc-test-suite/">test suite</a> and
        <a href="https://w3c.github.io/vc-test-suite/implementations/"
          >implementation report</a
        >.
      </p>
    </section>

    <section class="informative">
      <h2>소개</h2>

      <p>
        <a>크리덴셜</a>은 우리 일상생활의 한 부분이다. 운전면허증은 우리가
        자동차를 운전할 수 있는 능력이 있음을 주장하는 데 사용되고, 대학 학위는
        우리의 교육 수준을 주장하는 데 사용될 수 있으며, 정부에서 발급한 여권은
        우리가 국가 간에 여행할 수 있게 해준다. 이러한 <a>크리덴셜</a>은 물리적
        세계에서 사용될 때 우리에게 이점을 제공하지만, 웹에서의 사용은 여전히
        난해한 상태이다.
      </p>

      <p>
        현재 웹에서 교육 자격, 의료 데이터, 금융 계좌 세부 정보 및 기타 종류의
        제3자 <a>검증</a>된 기계 판독 가능한 개인 정보를 표현하는 것은 어렵다.
        웹에서 디지털 <a>크리덴셜</a>을 표현하는 것이 어렵기 때문에 물리적
        <a>크리덴셜</a>이 물리적 세계에서 우리에게 제공하는 것과 동일한 이점을
        웹을 통해 받는 것이 어려워진다.
      </p>

      <p>
        이 규격은 <a>크리덴셜</a>을 암호학적으로 안전하고, 프라이버시를
        존중하며, 기계적으로 검증 가능한 방식으로 웹에서 표현할 수 있는 표준
        방법을 제공한다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>과 관련된 개념에 익숙하지 않은 사람들을 위해
        다음 섹션에서는 다음에 대한 개요를 제공한다:
      </p>

      <ul>
        <li><a>검증가능한 크리덴셜</a>을 구성하는 컴포넌트</li>
        <li><a>검증가능한 프레젠테이션</a>을 구성하는 컴포넌트</li>
        <li>
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>이 유용할
          것으로 예상되는 생태계
        </li>
        <li>이 규격에 영향을 준 사용 사례와 요구사항</li>
      </ul>

      <section class="informative">
        <h3>검증가능한 크리덴셜이란 무엇인가?</h3>

        <p>물리적 세계에서 <a>크리덴셜</a>은 다음으로 구성될 수 있다:</p>

        <ul>
          <li>
            <a>크리덴셜</a>의 <a>주체</a>를 식별하는 것과 관련된 정보 (예: 사진,
            이름 또는 식별 번호)
          </li>
          <li>
            발급 기관과 관련된 정보 (예: 시 정부, 국가 기관 또는 인증 기관)
          </li>
          <li>
            이것이 어떤 유형의 <a>크리덴셜</a>인지에 대한 정보 (예: 네덜란드
            여권, 미국 운전면허증 또는 건강보험증)
          </li>
          <li>
            발급 기관이 <a>주체</a>에 대해 주장하는 특정 속성이나 속성에 관련된
            정보 (예: 국적, 운전 가능한 차량 등급 또는 생년월일)
          </li>
          <li><a>크리덴셜</a>이 어떻게 파생되었는지에 대한 증거</li>
          <li>
            크리덴셜에 대한 제약 조건에 관련된 정보 (예: 만료 날짜 또는 사용
            약관).
          </li>
        </ul>

        <p>
          <a>검증가능한 크리덴셜</a>은 물리적 <a>크리덴셜</a>이 나타내는 모든
          정보를 표현할 수 있다. 디지털 서명과 같은 기술의 추가로 인해
          <a>검증가능한 크리덴셜</a>은 물리적인 크리덴셜보다 변조가 더 어렵고
          신뢰할 수 있게 된다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>의 <a>보유자</a>는
          <a>검증가능한 프레젠테이션</a>을 생성한 다음 이러한
          <a>검증가능한 프레젠테이션</a>을 <a>검증자</a>와 공유하여 특정 특성을
          가진 <a>검증가능한 크리덴셜</a>을 소유하고 있음을 증명할 수 있다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a> 모두
          빠르게 전송될 수 있어, 원격으로 신뢰를 구축하려고 할 때 물리적인
          크리덴셜보다 더 편리하다.
        </p>

        <p>
          이 규격은 디지털 <a>크리덴셜</a>을 쉽게 표현할 수 있도록 하는 동시에,
          이 목표를 다수의 프라이버시 보호 목표와 균형을 맞추려고 시도한다.
          디지털 정보의 지속성과 이질적인 디지털 데이터 출처를 쉽게 수집하고
          연관시킬 수 있다는 점은 <a>검증 가능</a>하고 쉽게 기계 판독이 가능한
          <a>크리덴셜</a>의 사용으로 인해 악화될 수 있는 프라이버시 문제이다. 이
          문서는 <a href="#privacy-considerations"></a> 섹션에서 이러한 문제들을
          설명하고 해결하려고 시도한다. 영지식 증명과 같은 프라이버시 강화
          기술을 사용하여 이 데이터 모델을 사용하는 방법의 예시도 이 문서 전반에
          걸쳐 제공된다.
        </p>
      </section>

      <section class="informative">
        <h3 id="ecosystem-overview">생태계 개요</h3>

        <p>
          이 섹션에서는 <a>검증가능한 크리덴셜</a>이 유용할 것으로 예상되는
          생태계에서 핵심 참여자의 역할과 그들 간의 관계에 대해 설명한다. 역할은
          다양한 방식으로 구현될 수 있는 추상적인 개념이다. 역할의 분리는
          표준화를 위한 인터페이스와 프로토콜을 제안한다. 이 규격에서는 다음과
          같은 역할을 소개한다:
        </p>

        <dl>
          <dt><a>보유자</a></dt>
          <dd>
            하나 이상의 <a>검증가능한 크리덴셜</a>을 소유하고 이로부터
            <a>검증가능한 프레젠테이션</a>을 생성함으로써 <a>엔티티</a>가 수행할
            수 있는 역할. 보유자의 예로는 학생, 직원 및 고객이 있다.
          </dd>
          <dt><a>발급자</a></dt>
          <dd>
            하나 이상의 <a>주체</a>에 대한 <a>클레임</a>을 주장하고, 이러한
            <a>클레임</a>으로부터 <a>검증가능한 크리덴셜</a>을 만들고,
            <a>검증가능한 크리덴셜</a>을 <a>보유자</a>에게 전송함으로써
            <a>엔티티</a>가 수행하는 역할. 발급자의 예로는 기업, 비영리 단체,
            무역 협회, 정부 및 개인이 있다.
          </dd>
          <dt><a>주체</a></dt>
          <dd>
            <a>클레임</a>이 만들어지는 대상인 <a>엔티티</a>. 주체의 예로는 인간,
            동물 및 사물이 있다. 대부분의 경우 <a>검증가능한 크리덴셜</a>의
            <a>보유자</a>가 주체이지만, 특정 경우에는 그렇지 않다. 예를 들어,
            부모(<a>보유자</a>)가 자녀(<a>주체</a>)의
            <a>검증가능한 크리덴셜</a>을 보유하거나, 애완동물
            주인(<a>보유자</a>)이 애완동물(<a>주체</a>)의
            <a>검증가능한 크리덴셜</a>을 보유할 수 있다. 이러한 특수한 경우에
            대한 자세한 내용은 부록
            <a href="#subject-holder-relationships"></a>을 참조하시오.
          </dd>
          <dt><a>검증자</a></dt>
          <dd>
            처리를 위해 하나 이상의 <a>검증가능한 크리덴셜</a>을 선택적으로
            <a>검증가능한 프레젠테이션</a> 내에서 수신함으로써 <a>엔티티</a>가
            수행하는 역할. 검증자의 예로는 고용주, 보안 담당자 및 웹사이트 등이
            있다.
          </dd>
          <dt><a>검증가능한 데이터 레지스트리</a></dt>
          <dd>
            <a>검증가능한 크리덴셜</a> 사용에 필요할 수 있는 식별자, 키 및 기타
            관련 데이터(예: <a>검증가능한 크리덴셜</a> 스키마, 폐기 레지스트리,
            발급자 공개 키 등)의 생성 및 <a>검증</a>을 중재함으로써 시스템이
            수행할 수 있는 역할. 일부 구성에서는 <a>주체</a>에 대한 상관관계가
            있는 식별자가 필요할 수 있다. 검증가능한 데이터 레지스트리의 예로는
            신뢰할 수 있는 데이터베이스, 탈중앙화된 데이터베이스, 정부 ID
            데이터베이스 및 분산 원장 등이 있다. 종종 생태계에서는 두 가지
            이상의 유형의 검증가능한 데이터 레지스트리가 활용된다.
          </dd>
        </dl>

        <figure id="roles">
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/ecosystem.svg"
            alt="diagram showing how
	       credentials flow from issuer to holder and
	       presentations flow from holder to verifier where all
	       three parties can use information from a logical
	       verifiable data registry"
          />
          <figcaption style="text-align: center">
            The roles and information flows forming the basis for this
            specification.
          </figcaption>
        </figure>

        <p class="note">
          <a href="#roles"></a> above provides an example ecosystem in which to
          ground the rest of the concepts in this specification. Other
          ecosystems exist, such as protected environments or proprietary
          systems, where <a>verifiable credentials</a> also provide benefit.
        </p>
      </section>

      <section class="informative">
        <h3>사용 사례 및 요구사항</h3>

        <p>
          검증가능한 크리덴셜 사용 사례 문서 [[VC-USE-CASES]]는 독자에게 유용할
          수 있는 여러 가지 주요 주제를 간략히 설명하고 있다:
        </p>

        <ul>
          <li>
            위에서 소개한
            <a href="https://www.w3.org/TR/vc-use-cases/#user-roles">역할</a>에
            대한 보다 철저한 설명
          </li>
          <li>
            교육, 금융, 의료, 소매, 전문 면허 및 정부와 같은 수직 시장에서
            식별된
            <a href="https://www.w3.org/TR/vc-use-cases/#user-needs"
              >요구사항</a
            >
          </li>
          <li>
            생태계의 역할이 수행하는 공통
            <a href="https://www.w3.org/TR/vc-use-cases/#user-tasks">작업</a> 및
            관련 요구 사항
          </li>
          <li>
            작업 그룹에서 식별한 공통
            <a href="https://www.w3.org/TR/vc-use-cases/#user-sequences"
              >시퀀스 및 흐름</a
            >
          </li>
        </ul>

        <p>
          사용 사례 문서의 문서화 및 분석 결과, 이 규격에 대해 다음과 같은
          바람직한 생태계 특성이 식별되었다:
        </p>

        <ul>
          <li><a>크리덴셜</a>은 <a>발급자</a>가 만든 진술을 나타낸다.</li>
          <li>
            <a>검증가능한 크리덴셜</a>은 <a>발급자</a>가 변조 방지 및 프라이버시
            존중 방식으로 만든 진술을 나타낸다.
          </li>
          <li>
            <a>보유자</a>는 다른 <a>발급자</a>의 <a>크리덴셜</a> 및/또는
            <a>검증가능한 크리덴셜</a> 컬렉션을 단일 아티팩트인
            <a>프레젠테이션</a>으로 조합한다.
          </li>
          <li>
            보유자는 <a>프레젠테이션</a>을 <a>검증가능한 프레젠테이션</a>으로
            변환하여 변조 방지를 구현한다.
          </li>
          <li>
            <a>발급자</a>는 모든 <a>주체</a>에 대해 <a>검증가능한 크리덴셜</a>을
            발급할 수 있다.
          </li>
          <li>
            <a>발급자</a>, <a>보유자</a> 또는 <a>검증자</a>로서 행동하려면 어떤
            기관에 등록하거나 승인받을 필요가 없다. 관련 신뢰는 당사자 간에
            양방향으로 이루어진다.
          </li>
          <li>
            <a>검증가능한 프레젠테이션</a>은 모든 <a>검증자</a>가 모든
            <a>발급자</a>의 <a>검증가능한 크리덴셜</a>의 진위를 <a>검증</a>할 수
            있게 한다.
          </li>
          <li>
            <a>보유자</a>는 누구에게서든 <a>검증가능한 크리덴셜</a>을 받을 수
            있다.
          </li>
          <li>
            <a>보유자</a>는 모든 사용자 에이전트를 통해 모든 <a>발급자</a> 및
            모든 <a>검증자</a>와 상호 작용할 수 있다.
          </li>
          <li>
            <a>보유자</a>는 <a>검증가능한 프레젠테이션</a>을 공유할 수 있으며,
            이는 <a>발급자</a>에게 <a>검증자</a>의 신원을 밝히지 않고
            <a>검증</a>될 수 있다.
          </li>
          <li>
            <a>보유자</a>는 <a>검증가능한 크리덴셜</a>을 어느 위치에나 저장할 수
            있으며, 이는 <a>검증 가능성</a>에 영향을 미치지 않고 <a>발급자</a>가
            크리덴셜이 저장된 위치나 접근 시기에 대해 알 필요가 없다.
          </li>
          <li>
            <a>보유자</a>는 <a>검증가능한 프레젠테이션</a>을 모든
            <a>검증자</a>에게 제시할 수 있으며, 이는 클레임의 진위성에 영향을
            미치지 않고 <a>발급자</a>에게 그 행위를 밝히지 않는다.
          </li>
          <li>
            <a>검증자</a>는 모든 <a>보유자</a>의
            <a>검증가능한 프레젠테이션</a>을 <a>검증</a>할 수 있으며, 이는 모든
            <a>발급자</a>의 <a>클레임</a> 증명을 포함한다.
          </li>
          <li>
            <a>검증</a>은 <a>발급자</a>와 <a>검증자</a> 간의 직접적인 상호
            작용에 의존해서는 안 된다.
          </li>
          <li>
            <a>검증</a>은 <a>검증자</a>의 신원을 <a>발급자</a>에게 공개해서는 안
            된다.
          </li>
          <li>
            이 규격은 모든 적합한 소프트웨어가 해당 기능을 지원하도록 요구하지
            않고 <a>발급자</a>가 선택적 공개를 지원하는
            <a>검증가능한 크리덴셜</a>을 발급할 수 있는 수단을 제공해야 한다.
          </li>
          <li>
            <a>발급자</a>는 선택적 공개를 지원하는 <a>검증가능한 크리덴셜</a>을
            발급할 수 있다.
          </li>
          <li>
            단일 <a>검증가능한 크리덴셜</a>이 선택적 공개를 지원하는 경우,
            <a>보유자</a>는 전체 <a>검증가능한 크리덴셜</a>을 공개하지 않고
            <a>클레임</a> 증명을 제시할 수 있다.
          </li>
          <li>
            <a>검증가능한 프레젠테이션</a>은 <a>검증가능한 크리덴셜</a>의 속성을
            공개하거나 <a>검증자</a>가 요청한 <a>파생 술어</a>를 만족시킬 수
            있다. <a>파생 술어</a>는 크거나 같음, 작거나 같음, 같음, 집합에 속함
            등과 같은 부울 조건이다.
          </li>
          <li>
            <a>발급자</a>는 폐기 가능한 <a>검증가능한 크리덴셜</a>을 발급할 수
            있다.
          </li>
          <li>
            <a>크리덴셜</a>과 <a>프레젠테이션</a>을 암호화로 보호하고
            <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>을
            검증하는 프로세스는 결정론적이고 양방향이며 손실이 없어야 한다.
            <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의
            모든 검증은 결정론적 프로세스에서 이 문서에 정의된 일반 데이터
            모델로 변환 가능해야 하며, 결과적으로 생성되는 <a>크리덴셜</a> 또는
            <a>프레젠테이션</a>은 원래 구성과 의미적으로 그리고 구문적으로
            동등해야 하므로 상호운용 가능한 방식으로 처리될 수 있다.
          </li>
          <li>
            <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>은 하나
            이상의 기계 판독 가능한 데이터 형식으로 직렬화할 수 있어야 한다.
            직렬화 및/또는 역직렬화 프로세스는 결정론적이고 양방향이며 손실이
            없어야 한다. <a>검증가능한 크리덴셜</a> 또는
            <a>검증가능한 프레젠테이션</a>의 모든 직렬화는 결정론적 프로세스에서
            이 문서에 정의된 일반 데이터 모델로 변환 가능해야 하며, 결과적으로
            생성되는 <a>검증가능한 크리덴셜</a>은 상호운용 가능한 방식으로
            처리될 수 있다. 또한 직렬화된 형식은 데이터 또는 내용 손실 없이
            데이터 모델에서 생성할 수 있어야 한다.
          </li>
          <li>데이터 모델과 직렬화는 최소한의 조정으로 확장 가능해야 한다.</li>
          <li>
            <a>발급자</a>에 의한 폐기는 <a>주체</a>, <a>보유자</a>, 특정
            <a>검증가능한 크리덴셜</a> 또는 <a>검증자</a>에 대한 식별 정보를
            공개해서는 안 된다.
          </li>
          <li><a>발급자</a>는 폐기 사유를 공개할 수 있다.</li>
          <li>
            <a>검증가능한 크리덴셜</a>을 폐기하는 <a>발급자</a>는 암호화
            무결성(예: 서명 키 손상)에 대한 폐기와 상태 변경(예: 운전면허증
            정지)에 대한 폐기를 구분해야 한다.
          </li>
          <li>
            <a>발급자</a>는 <a>검증가능한 크리덴셜</a>을 새로 고치기 위한
            서비스를 제공할 수 있다.
          </li>
        </ul>
      </section>

      <section id="conformance" class="normative">
        <p>
          <dfn>적합한 문서</dfn>는 이 규격의 규범적 진술을 준수하는 데이터
          모델의 모든 구체적인 표현이다. 구체적으로, 이 문서의
          <a href="#basic-concepts"></a>, <a href="#advanced-concepts"></a> 및
          <a href="#syntaxes"></a> 섹션의 모든 관련 규범적 진술은 반드시
          시행되어야 한다. 적합한 문서의 직렬화 형식은
          <a href="#syntaxes"></a> 섹션에 설명된 대로 결정론적이고 양방향이며
          무손실이어야 한다. <a>적합한 문서</a>는 그러한 모든 직렬화 형식으로
          전송되거나 저장될 수 있다.
        </p>

        <p>
          <dfn>적합한 프로세서</dfn>는 <a>적합한 문서</a>를 생성하거나 사용하는
          소프트웨어 및/또는 하드웨어로 실현된 모든 알고리즘이다. 적합한
          프로세서는 부적합한 문서가 사용될 때 오류를 생성해야 한다.
        </p>

        <p>
          이 규격은 <a>발급자</a>, <a>보유자</a> 또는 <a>검증자</a>와 같은
          생태계의 역할 적합성에 대해 규범적인 진술을 하지 않는다. 생태계 역할의
          적합성은 애플리케이션, 사용 사례 및 시장 수직 분야에 매우 특화되어
          있기 때문이다.
        </p>

        <p>
          디지털 서명의 하위 집합인 디지털 증명 메커니즘은
          <a>검증가능한 크리덴셜</a>의 보호를 보장하는 데 필요하다. 증명을
          보유하고 유효성 검사하는 것은 증명의 구문에 따라 달라질 수 있으며(예:
          키 보유자 증명을 위해 JSON Web Token의 JSON Web Signature 사용),
          <a>검증가능한 크리덴셜</a>을 처리하는 데 필수적인 부분이다. 출판
          시점에, 작업 그룹 구성원들은 최소한 세 가지 증명 메커니즘을 사용하여
          <a>검증가능한 크리덴셜</a>을 구현했다:
        </p>

        <ul>
          <li>
            JSON Web Signature \[\[RFC7515\]\]로 보호된 JSON Web Tokens
            \[\[RFC7519\]\]
          </li>
          <li>Linked Data Proofs \[\[?LD-PROOFS\]\]</li>
          <li>
            Camenisch-Lysyanskaya Zero-Knowledge Proofs \[\[?CL-SIGNATURES\]\].
          </li>
        </ul>

        <p>
          구현자는 이 규격의 출판 날짜를 기준으로 모든 증명 메커니즘이
          표준화되지는 않았음에 유의해야 한다. 그룹은 이러한 메커니즘 중 일부와
          새로운 메커니즘이 독립적으로 성숙하여 시간이 지남에 따라 표준화될
          것으로 기대한다. 여러 유효한 증명 메커니즘이 있기 때문에 이 규격은
          단일 디지털 서명 메커니즘을 표준화하지 않는다. 이 규격의 목표 중
          하나는 다양한 현재 및 미래의 디지털 증명 메커니즘으로 보호할 수 있는
          데이터 모델을 제공하는 것이다. 이 규격을 준수하는 것은 특정 증명
          메커니즘의 세부 사항에 의존하지 않으며, <a>검증가능한 크리덴셜</a>이
          사용하는 메커니즘을 명확하게 식별할 것을 요구한다.
        </p>

        <p>
          이 문서에는 또한 JSON 및 JSON-LD 콘텐츠가 포함된 예제가 포함되어 있다.
          이러한 예제 중 일부에는 인라인 주석(<code>//</code>) 및 예제에 거의
          가치를 더하지 않는 정보를 표시하기 위한 줄임표(<code>...</code>)
          사용과 같이 잘못된 JSON 문자가 포함되어 있다. 구현자는 정보를 유효한
          JSON 또는 JSON-LD로 사용하려면 이 내용을 제거하는 것이 좋다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Terminology</h2>

      <div data-include="./terms.html"></div>
    </section>

    <section class="informative">
      <h2 id="core-data-model">핵심 데이터 모델</h2>

      <p>
        다음 섹션에서는 이 규격의 기반을 형성하는 <a>클레임</a>,
        <a>크리덴셜</a>, <a>프레젠테이션</a>과 같은 핵심 데이터 모델 개념에 대해
        설명한다.
      </p>

      <section class="informative">
        <h3>클레임</h3>

        <p>
          <a>클레임</a>은 <a>주체</a>에 대한 진술이다. <a>주체</a>는
          <a>클레임</a>이 만들어질 수 있는 대상이다. <a>클레임</a>은
          <strong><em>주체</em></strong
          >-<dfn data-lt="property|properties">속성</dfn>-<dfn>값</dfn> 관계를
          사용하여 표현된다.
        </p>

        <figure id="basic-structure">
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/claim.svg"
            alt="주체는 값을 갖는 속성을 가지고 있다"
          />
          <figcaption style="text-align: center">
            클레임의 기본 구조.
          </figcaption>
        </figure>

        <p>
          위의 <a href="#basic-structure"></a>에 설명된 <a>클레임</a>의 데이터
          모델은 강력하며 다양한 진술을 표현하는 데 사용될 수 있다. 예를 들어,
          누군가가 특정 대학을 졸업했는지 여부는 아래
          <a href="#basic-example"></a>와 같이 표현될 수 있다.
        </p>

        <figure id="basic-example">
          <img
            style="margin: auto; display: block; width: 60%"
            src="diagrams/claim-example.svg"
            alt="Pat은 Example University라는 값을 가진 alumniOf 속성을 가지고 있다"
          />
          <figcaption style="text-align: center">
            Pat이 "Example University"의 동문임을 나타내는 기본 클레임.
          </figcaption>
        </figure>

        <p>
          개별 <a>클레임</a>은 <a>주체</a>에 대한 정보의 <a>그래프</a>를
          표현하기 위해 결합될 수 있다. 아래 <a href="#multiple-claims"></a>에
          표시된 예는 Pat이 Sam을 알고 있으며 Sam이 교수로 고용되어 있다는
          <a>클레임</a>을 추가하여 이전 <a>클레임</a>을 확장한 것이다.
        </p>

        <figure id="multiple-claims">
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/claim-extended.svg"
            alt="extends previous
            diagram with another property called knows whose value is
            Sam, and Sam has a property jobTitle whose value is Professor"
          />
          <figcaption style="text-align: center">
            Multiple claims can be combined to express a graph of information.
          </figcaption>
        </figure>

        <p>
          이 시점에서 <a>클레임</a>과 정보의 <a>그래프</a> 개념이 소개되었다.
          <a>클레임</a>을 신뢰할 수 있으려면 그래프에 더 많은 정보가 추가될
          것으로 예상된다.
        </p>
      </section>

      <section class="informative">
        <h3>크리덴셜</h3>

        <p>
          <a>크리덴셜</a>은 동일한 <a>엔티티</a>에 의해 만들어진 하나 이상의
          <a>클레임</a> 집합이다. <a>크리덴셜</a>에는 <a>발급자</a>, 만료 날짜
          및 시간, 대표 이미지, <a>검증</a>을 위해 사용할 공개 키, 폐기 메커니즘
          등과 같은 <a>크리덴셜</a>의 속성을 설명하는 식별자와 메타데이터도
          포함될 수 있다. 메타데이터에는 <a>발급자</a>의 서명이 포함될 수 있다.
          <a>검증가능한 크리덴셜</a>은 변조 방지 <a>클레임</a>과 메타데이터
          집합으로, 누가 발급했는지를 암호학적으로 증명한다.
        </p>

        <figure id="basic-vc">
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/credential.svg"
            alt="검증가능한 크리덴셜은 크리덴셜 메타데이터, 클레임, 증명을 포함한다"
          />
          <figcaption style="text-align: center">
            검증가능한 크리덴셜의 기본 구성 요소.
          </figcaption>
        </figure>

        <p>
          <a>검증가능한 크리덴셜</a>의 예로는 디지털 직원 신분증, 디지털
          출생증명서, 디지털 교육 증명서 등이 있다.
        </p>

        <p class="note">
          <a>크리덴셜</a> 식별자는 종종 <a>크리덴셜</a>의 특정 인스턴스를
          식별하는 데 사용된다. 이러한 식별자는 상관관계에도 사용될 수 있다.
          상관관계를 최소화하려는 <a>보유자</a>는 <a>크리덴셜</a> 식별자를
          공개하지 않는 선택적 공개 체계를 사용하는 것이 좋다.
        </p>

        <p>
          위의 <a href="#basic-vc"></a>는 <a>검증가능한 크리덴셜</a>의 기본 구성
          요소를 보여주지만, <a>클레임</a>이 정보 <a>그래프</a>로 구성되는
          방법과 이러한 정보 <a>그래프</a>가 <a>검증가능한 크리덴셜</a>로
          구성되는 방법에 대한 세부 사항은 추상화한다. 아래
          <a href="#info-graph-vc"></a>는 일반적으로 적어도 두 개의 정보
          <a>그래프</a>로 구성되는 <a>검증가능한 크리덴셜</a>의 보다 완전한
          묘사를 보여준다. 첫 번째 <a>그래프</a>는
          <span class="color-text" style="color: #d5a6bd"
            >크리덴셜 메타데이터</span
          >와 <span class="color-text" style="color: #ffe599">클레임</span>을
          포함하는 <a>검증가능한 크리덴셜</a> 자체를 표현한다. 두 번째
          <a>그래프</a>는 일반적으로 디지털 서명인
          <span class="color-text" style="color: #b6d7a8">디지털 증명</span>을
          표현한다.
        </p>

        <figure id="info-graph-vc">
          <img
            style="margin: auto; display: block; width: 100%"
            src="diagrams/credential-graph.svg"
            alt="diagram with a
	       Credential Graph on top connected via a proof to a
	       Proof Graph on the bottom.  The Credental Graph has
	       Credential 123 with 4 properties: 'type' of value
	       AlumniCredential, 'issuer' of Example University,
	       'issuanceDate' of 2010-01-01T19:23:24Z, and
	       credentialSubject of Pat, who has an alumniOf property
	       with value of Example University.  The Proof Graph has
	       Signature 456 with 5 properties: 'type' of
	       RsaSignature2018, 'verificationMethod' of Example University
	       Public Key 7, 'created' of 2017-06-18T21:19:10Z, and 'jws'
         of 'BavEll0...3JT24='"
          />
          <figcaption style="text-align: center">
            Information graphs associated with a basic verifiable credential.
          </figcaption>
        </figure>

        <p class="note">
          결혼 증명서와 같이 서로 관련이 없어도 되는 다른 <a>주체</a>에 대한
          여러 <a>클레임</a>을 포함하는 <a>크리덴셜</a>을 가질 수 있다.
        </p>

        <p class="note">
          <a>크리덴셜</a>이 발급된 <a>엔티티</a>에 대한 <a>클레임</a>을 전혀
          포함하지 않는 <a>크리덴셜</a>을 가질 수 있다. 예를 들어, 특정 개에
          대한 <a>클레임</a>만 포함하지만 개의 주인에게 발급되는
          <a>크리덴셜</a>이 있다.
        </p>
      </section>

      <section class="informative">
        <h3>프레젠테이션</h3>

        <p>
          프라이버시 향상은 이 규격의 핵심 설계 기능이다. 따라서 이 기술을
          사용하는 <a>엔티티</a>가 특정 상황에 적합한 페르소나의 일부분만 표현할
          수 있는 것이 중요하다. 페르소나의 일부를 표현하는 것을
          <a>검증가능한 프레젠테이션</a>이라고 한다. 서로 다른 페르소나의 예로는
          한 사람의 직업상 페르소나, 온라인 게임 페르소나, 가족 페르소나 또는
          익명 페르소나 등이 있다.
        </p>

        <p>
          <a>검증가능한 프레젠테이션</a>은 하나 이상의
          <a>검증가능한 크리덴셜</a>의 데이터를 표현하며, 데이터의 저작권을
          <a>검증</a>할 수 있는 방식으로 패키징된다.
          <a>검증가능한 크리덴셜</a>이 직접 제시되면
          <a>검증가능한 프레젠테이션</a>이 된다. <a>검증가능한 크리덴셜</a>에서
          파생되었지만 그 자체로는 <a>검증가능한 크리덴셜</a>을 포함하지 않는
          암호학적으로 <a>검증 가능한</a> 데이터 형식도
          <a>검증가능한 프레젠테이션</a>일 수 있다.
        </p>

        <p>
          <a>프레젠테이션</a>의 데이터는 종종 동일한 <a>주체</a>에 관한
          것이지만, 여러 <a>발급자</a>에 의해 발급되었을 수 있다. 이 정보의
          집합은 일반적으로 사람, 조직 또는 <a>엔티티</a>의 한 측면을 표현한다.
        </p>

        <figure id="basic-vp">
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/presentation.svg"
            alt="검증가능한 프레젠테이션은 프레젠테이션 메타데이터, 검증가능한 크리덴셜, 증명을 포함한다"
          />
          <figcaption style="text-align: center">
            검증가능한 프레젠테이션의 기본 구성 요소.
          </figcaption>
        </figure>

        <p>
          위의 <a href="#basic-vp"></a>는 <a>검증가능한 프레젠테이션</a>의 구성
          요소를 보여주지만, <a>검증가능한 크리덴셜</a>이 정보 <a>그래프</a>로
          구성되고 이러한 정보 <a>그래프</a>가
          <a>검증가능한 프레젠테이션</a>으로 구성되는 방법에 대한 세부 사항은
          추상화한다.
        </p>

        <p>
          아래 <a href="#info-graph-vp"></a>는 일반적으로 적어도 네 개의 정보
          <a>그래프</a>로 구성되는 <a>검증가능한 프레젠테이션</a>의 보다 완전한
          묘사를 보여준다. 첫 번째 정보 <a>그래프</a>인 프레젠테이션
          <a>그래프</a>는 프레젠테이션 메타데이터를 포함하는
          <a>검증가능한 프레젠테이션</a> 자체를 표현한다. 프레젠테이션
          <a>그래프</a>의 <code>verifiableCredential</code> 속성은 하나 이상의
          <a>검증가능한 크리덴셜</a>을 참조하며, 각각은 두 번째 정보
          <a>그래프</a>, 즉 크리덴셜 메타데이터와 클레임을 포함하는 자체 포함된
          크리덴셜 <a>그래프</a>이다. 세 번째 정보 <a>그래프</a>인 크리덴셜 증명
          <a>그래프</a>는 일반적으로 디지털 서명인 크리덴셜 그래프 증명을
          표현한다. 네 번째 정보 <a>그래프</a>인 프레젠테이션 증명
          <a>그래프</a>는 일반적으로 디지털 서명인 프레젠테이션 그래프 증명을
          표현한다.
        </p>

        <figure id="info-graph-vp">
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/presentation-graph.svg"
            alt="상단에 프레젠테이션 그래프가 있고 하단에 프레젠테이션 증명 그래프가 증명으로 연결된 다이어그램. 프레젠테이션 그래프에는 값이 VerifiablePresentation인 'type', 값이 Do Not Archive인 'termsOfUse', 값이 Figure 6인 'verifiableCredential'의 3가지 속성을 가진 프레젠테이션 ABC가 있다. 프레젠테이션 증명 그래프에는 RsaSignature2018인 'type', Example Presenter Public Key 11인 'verificationMethod', 2018-01-15T12:43:56Z인 'created', d28348djsj3239인 'challenge', 'p2KaZ...8Fj3K='인 'jws'의 5가지 속성을 가진 시그니처 8910이 있다."
          />
          <figcaption style="text-align: center">
            기본 검증가능한 프레젠테이션과 관련된 정보 그래프.
          </figcaption>
        </figure>

        <p class="note">
          비즈니스 페르소나와 같이 종종 관련이 있지만 반드시 그럴 필요는 없는
          여러 <a>주체</a>에 대한 여러 <a>크리덴셜</a>을 사용하는
          <a>프레젠테이션</a>을 가질 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>구체적인 라이프사이클 예시</h3>

        <p>
          이전 섹션에서는 그래픽 묘사를 사용하여 <a>클레임</a>,
          <a>검증가능한 크리덴셜</a>, <a>검증가능한 프레젠테이션</a>의 개념을
          소개했다. 이 섹션에서는 이 규격에서 지원하는 구체적인 구문 중 하나로
          표현된 데이터 모델의 간단하지만 완전한 라이프사이클 예시를 제공한다.
          <a href="#ecosystem-overview">검증가능한 크리덴셜 생태계</a>에서
          <a>크리덴셜</a>과 <a>프레젠테이션</a>의 라이프사이클은 일반적으로
          다음과 같은 공통 경로를 거친다:
        </p>

        <ol>
          <li>하나 이상의 <a>검증가능한 크리덴셜</a> 발급.</li>
          <li>
            <a>검증가능한 크리덴셜</a>을 (디지털 지갑과 같은)
            <a>크리덴셜 리포지토리</a>에 저장.
          </li>
          <li>
            <a>검증자</a>를 위해 <a>검증가능한 크리덴셜</a>을
            <a>검증가능한 프레젠테이션</a>으로 구성.
          </li>
          <li>
            <a>검증자</a>에 의한 <a>검증가능한 프레젠테이션</a>의 <a>검증</a>.
          </li>
        </ol>

        <p>
          이 라이프사이클을 설명하기 위해, 대학에서 동문 할인을 받는 예시를
          사용할 것이다. 아래 예시에서 Pat은 대학에서 동문
          <a>검증가능한 크리덴셜</a>을 받고, Pat은 <a>검증가능한 크리덴셜</a>을
          디지털 지갑에 저장한다.
        </p>

        <pre
          class="example nohighlight"
          title="A simple example of a verifiable credential"
        >
{
  <span class='comment'>// set the context, which establishes the special terms we will be using
  // such as 'issuer' and 'alumniOf'.</span>
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  <span class='comment'>// specify the identifier for the credential</span>
  "id": "http://example.edu/credentials/1872",
  <span class='comment'>// the credential types, which declare what data to expect in the credential</span>
  "type": ["VerifiableCredential", "AlumniCredential"],
  <span class='comment'>// the entity that issued the credential</span>
  "issuer": "https://example.edu/issuers/565049",
  <span class='comment'>// when the credential was issued</span>
  "issuanceDate": "2010-01-01T19:23:24Z",
  <span class='comment'>// claims about the subjects of the credential</span>
  "credentialSubject": {
    <span class='comment'>// identifier for the only subject of the credential</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// assertion about the only subject of the credential</span>
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  <span class='comment'>// digital proof that makes the credential tamper-evident</span>
  <span class='comment'>// see the NOTE at end of this section for more detail</span>
  "proof": {
    <span class='comment'>// the cryptographic signature suite that was used to generate the signature</span>
    "type": "RsaSignature2018",
    <span class='comment'>// the date the signature was created</span>
    "created": "2017-06-18T21:19:10Z",
    <span class='comment'>// purpose of this proof</span>
    "proofPurpose": "assertionMethod",
    <span class='comment'>// the identifier of the public key that can verify the signature</span>
    "verificationMethod": "https://example.edu/issuers/565049/keys/1",
    <span class='comment'>// the digital signature value</span>
    "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5X
      sITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUc
      X16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtj
      PAYuNzVBAh4vGHSrQyHUdBBPM"
  }
}
        </pre>

        <p>
          그런 다음 Pat은 동문 할인을 받으려고 시도한다. 티켓 판매 시스템인
          <a>검증자</a>는 "Example University"의 동문은 스포츠 이벤트 시즌 티켓
          구매 시 할인을 받을 수 있다고 명시한다. Pat은 모바일 기기를 사용하여
          시즌 티켓 구매 프로세스를 시작한다. 이 프로세스의 한 단계에서 동문
          <a>검증가능한 크리덴셜</a>을 요청하고, 이 요청은 Pat의 디지털 지갑으로
          전달된다. 디지털 지갑은 Pat에게 이전에 발급받은
          <a>검증가능한 크리덴셜</a>을 제공할지 묻는다. Pat은 동문
          <a>검증가능한 크리덴셜</a>을 선택하고, 이는
          <a>검증가능한 프레젠테이션</a>으로 구성된다.
          <a>검증가능한 프레젠테이션</a>은 <a>검증자</a>에게 전송되고
          <a>검증</a>된다.
        </p>
        <pre
          class="example nohighlight"
          title="A simple example of a verifiable presentation"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// the verifiable credential issued in the previous example</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "id": "http://example.edu/credentials/1872",
    "type": ["VerifiableCredential", "AlumniCredential"],
    "issuer": "https://example.edu/issuers/565049",
    "issuanceDate": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": [{
          "value": "Example University",
          "lang": "en"
        }, {
          "value": "Exemple d'Université",
          "lang": "fr"
        }]
      }
    },
    "proof": {
      "type": "RsaSignature2018",
      "created": "2017-06-18T21:19:10Z",
      "proofPurpose": "assertionMethod",
      "verificationMethod": "https://example.edu/issuers/565049/keys/1",
      "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5X
        sITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUc
        X16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtj
        PAYuNzVBAh4vGHSrQyHUdBBPM"
    }
  }],
  <span class='comment'>// digital signature by Pat on the presentation
  // protects against replay attacks</span>
  "proof": {
    "type": "RsaSignature2018",
    "created": "2018-09-14T21:19:10Z",
    "proofPurpose": "authentication",
    "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1",
    <span class='comment'>// 'challenge' and 'domain' protect against replay attacks</span>
    "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
    "domain": "4jt78h47fh47",
    "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kTCYt5
      XsITJX1CxPCT8yAV-TVIw5WEuts01mq-pQy7UJiN5mgREEMGlv50aqzpqh4Qq_PbChOMqs
      LfRoPsnsgxD-WUcX16dUOqV0G_zS245-kronKb78cPktb3rk-BuQy72IFLN25DYuNzVBAh
      4vGHSrQyHUGlcTwLtjPAnKb78"
  }
}
        </pre>

        <p class="note">
          위에 사용된 <code>proof</code> 메커니즘에 대해 더 이해하고 싶은
          구현자는 <a href="#proofs-signatures"></a> 섹션과 다음 규격을 읽어보면
          더 많은 것을 배울 수 있다: Linked Data Proofs \[\[?LD-PROOFS\]\],
          Linked Data Cryptographic Suites Registry\[\[?LDP-REGISTRY\]\], JSON
          Web Signature (JWS) Unencoded Payload Option \[\[RFC7797\]\]. 증명
          메커니즘 목록은 검증가능한 크리덴셜 확장 레지스트리
          \[\[VC-EXTENSION-REGISTRY\]\]에서 확인할 수 있다.
        </p>
      </section>
    </section>

    <section class="normative">
      <h2 id="basic-concepts">기본 개념</h2>

      <p>
        이 섹션에서는 문서 뒷부분의 <a href="#advanced-concepts"></a> 섹션을
        준비하기 위해 이 규격의 몇 가지 기본 개념을 소개한다.
      </p>

      <section>
        <h3>컨텍스트</h3>

        <p>
          두 소프트웨어 시스템이 데이터를 교환해야 할 때, 두 시스템이 모두
          이해하는 용어를 사용해야 한다. 비유하자면, 두 사람이 어떻게
          의사소통하는지 생각해보자. 두 사람은 동일한 언어를 사용해야 하고
          사용하는 단어는 서로에게 동일한 의미를 가져야 한다. 이를
          <em>대화의 맥락</em>이라고 부를 수 있다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>에는
          \[\[RFC3986\]\]에 정의된 <a>URI</a>로 식별되는 많은 속성과 값이 있다.
          그러나 이러한 <a>URI</a>은 길고 사람이 친숙하지 않을 수 있다. 이런
          경우 짧은 형식의 사람에게 친숙한 별칭이 더 도움이 될 수 있다. 이
          규격은 <code>@context</code> <a>속성</a>을 사용하여 이러한 짧은 형식의
          별칭을 특정 <a>검증가능한 크리덴셜</a>과
          <a>검증가능한 프레젠테이션</a>에 필요한 <a>URI</a>에 매핑한다.
        </p>

        <p class="note">
          JSON-LD에서 <code>@context</code> <a>속성</a>은 데이터 타입 정보, 언어
          정보, 변환 규칙 등 이 규격의 요구사항을 넘어서지만 향후 또는 관련
          작업에 유용할 수 있는 다른 세부사항을 전달하는 데에도 사용될 수 있다.
          자세한 내용은 \[\[JSON-LD\]\] 규격의
          <a href="https://www.w3.org/TR/json-ld11/#the-context"
            >Section 3.1: 컨텍스트</a
          >를 참조하시오.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>은 반드시
          <code>@context</code> <a>속성</a>을 포함해야 한다.
        </p>

        <dl>
          <dt><dfn>@context</dfn></dt>
          <dd>
            <code>@context</code> <a>속성</a>의 값은 반드시 정렬된 집합이어야
            하며, 첫 번째 항목은 값이
            <code>https://www.w3.org/2018/credentials/v1</code>인
            <a>URI</a>이어야 한다. 참고로, 기본 컨텍스트의 사본은 부록
            <a href="#base-context"></a>에 제공된다. 배열의 후속 항목은 반드시
            컨텍스트 정보를 표현해야 하며 <a>URI</a> 및/또는 객체의 조합으로
            구성되어야 한다. <code>@context</code>의 각 <a>URI</a>은 역참조될
            경우 <code>@context</code>에 대한 기계 판독 가능한 정보가 포함된
            문서를 반환하는 것이 권장된다(RECOMMENDED).
          </dd>
        </dl>

        <p class="note">
          이 규격은 <code>@context</code> <a>속성</a>이 존재할 것을 요구하지만,
          <code>@context</code> <a>속성</a>의 값이 반드시 JSON-LD를 사용하여
          처리될 것을 요구하지는 않는다. 이는 <a>검증가능한 크리덴셜</a>이 JWT로
          인코딩될 때 사용될 수 있는 일반 JSON 라이브러리와 같은 라이브러리를
          사용한 처리를 지원하기 위한 것이다. 모든 라이브러리 또는 프로세서는
          <code>@context</code> <a>속성</a>의 값 순서가 특정 애플리케이션에
          예상되는 것과 동일한지 확인해야 한다. JSON-LD를 지원하는 라이브러리
          또는 프로세서는 예상대로 전체 JSON-LD 처리를 사용하여
          <code>@context</code> <a>속성</a>을 처리할 수 있다.
        </p>
        <pre class="example nohighlight" title="Usage of the @context property">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ]</span>,
  "id": "http://example.edu/credentials/58473",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "issuer": "https://example.edu/issuers/565049",
  "issuanceDate": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 예시는 대화가 <a>검증가능한 크리덴셜</a>에 관한 것임을 나타내기
          위해 기본 컨텍스트
          <a>URI</a>(<code>https://www.w3.org/2018/credentials/v1</code>)를
          사용한다. 두 번째
          <a>URI</a
          >(<code>https://www.w3.org/2018/credentials/examples/v1</code>)는
          대화가 예시에 관한 것임을 나타낸다.
        </p>

        <p class="note">
          이 문서는 예시를 보여주기 위해 예시 컨텍스트
          <a>URI</a
          >(<code>https://www.w3.org/2018/credentials/examples/v1</code>)를
          사용한다. 구현에서는 이 <a>URI</a>를 파일럿 또는 프로덕션 시스템과
          같은 다른 목적으로 사용하지 않을 것으로 예상된다.
        </p>

        <p>
          <code>https://www.w3.org/2018/credentials/v1</code>에서 사용 가능한
          데이터는 절대 업데이트되지 않는 정적 문서이며, 다운로드하여 캐시해야
          한다(SHOULD). 검증가능한 크리덴셜 데이터 모델과 관련된 사람이 읽을 수
          있는 어휘 문서는
          <a href="https://www.w3.org/2018/credentials/"
            >https://www.w3.org/2018/credentials/</a
          >에서 확인할 수 있다. 이 개념은 <a href="#extensibility"></a> 섹션에서
          더 자세히 설명된다.
        </p>
      </section>

      <section>
        <h3 id="identifiers">식별자</h3>

        <p>
          사람, 제품 또는 조직과 같은 특정 사물에 대한 진술을 표현할 때, 다른
          사람이 동일한 사물에 대한 진술을 표현할 수 있도록 일종의 식별자를
          사용하는 것이 종종 유용하다. 이 규격은 그러한 식별자를 위해 선택적인
          <code>id</code> <a>속성</a>을 정의한다. <code>id</code> <a>속성</a>은
          사람, 제품 또는 조직과 같은 객체를 모호하지 않게 참조하기 위한 것이다.
          <code>id</code> <a>속성</a>을 사용하면 <a>검증가능한 크리덴셜</a>에서
          특정 사물에 대한 진술을 표현할 수 있다.
        </p>

        <p><em>만약</em> <code>id</code> <a>속성</a>이 존재한다면:</p>

        <ul>
          <li>
            <code>id</code> <a>속성</a>은 반드시 다른 사람이 해당 식별자로
            식별되는 특정 사물에 대한 진술을 표현할 때 사용할 것으로 예상되는
            식별자를 표현해야 한다.
          </li>
          <li>
            <code>id</code> <a>속성</a>은 반드시 하나 이상의 값을 가져서는 안
            된다.
          </li>
          <li>
            <code>id</code> <a>속성</a>의 값은 반드시 <a>URI</a>이어야 한다.
          </li>
        </ul>

        <p class="note">
          개발자는 가명성이 필요한 시나리오에서 식별자가 유해할 수 있음을
          기억해야 한다. 개발자는 그러한 시나리오를 고려할 때
          <a href="#identifier-based-correlation"></a> 섹션을 주의 깊게 읽을
          것을 권장한다. <a href="#privacy-considerations"></a> 섹션에 문서화된
          다른 유형의 상관관계 메커니즘도 프라이버시 문제를 일으킨다.
          프라이버시가 중요한 고려사항인 경우 <code>id</code> <a>속성</a>은
          생략될 수 있다.
        </p>

        <dl>
          <dt><dfn>id</dfn></dt>
          <dd>
            <code>id</code> <a>속성</a>의 값은 반드시 단일 <a>URI</a>이어야
            한다. <code>id</code>의 <a>URI</a>는 역참조될 경우 <code>id</code>에
            대한 기계 판독 가능한 정보가 포함된 문서를 반환하는 것이
            좋다(RECOMMENDED).
          </dd>
        </dl>

        <pre class="example nohighlight" title="Usage of the id property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  <span class="highlight">"id": "http://example.edu/credentials/3732"</span>,
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/565049",
  "issuanceDate": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 예시는 두 가지 유형의 식별자를 사용한다. 첫 번째 식별자는
          <a>검증가능한 크리덴셜</a>을 위한 것이며 HTTP 기반 URL을 사용한다. 두
          번째 식별자는 <a>검증가능한 크리덴셜</a>의 <a>주체</a>(<a>클레임</a>이
          관련된 사물)를 위한 것이며 <a>DID</a>라고도 하는
          <a>탈중앙 식별자</a>를 사용한다.
        </p>

        <p class="note">
          이 출판물 기준으로, <a>DID</a>는 <a>검증가능한 크리덴셜</a>이 유용하기
          위해 필요하지 않은 새로운 유형의 식별자이다. 구체적으로,
          <a>검증가능한 크리덴셜</a>은 <a>DID</a>에 의존하지 않으며 <a>DID</a>는
          <a>검증가능한 크리덴셜</a>에 의존하지 않는다. 그러나 많은
          <a>검증가능한 크리덴셜</a>이 <a>DID</a>를 사용할 것으로 예상되며, 이
          규격을 구현하는 소프트웨어 라이브러리는 <a>DID</a>를 해석할 필요가
          있을 것이다. <a>DID</a> 기반 URL은 <a>주체</a>, <a>발급자</a>,
          <a>보유자</a>, 크리덴셜 상태 목록, 암호화 키 및
          <a>검증가능한 크리덴셜</a>과 관련된 기타 기계 판독 가능한 정보와
          관련된 식별자를 표현하는 데 사용된다.
        </p>
      </section>

      <section>
        <h3 id="types">타입</h3>

        <p>
          이 문서에 지정된 종류의 객체를 처리하는 소프트웨어 시스템은 제공된
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>이
          적합한지 여부를 결정하기 위해 타입 정보를 사용한다. 이 규격은 타입
          정보 표현을 위한 <code>type</code> <a>속성</a>을 정의한다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>은 반드시
          <code>type</code> <a>속성</a>을 가져야 한다. 즉, <code>type</code>
          <a>속성</a>이 없는 <a>크리덴셜</a> 또는 <a>프레젠테이션</a>은
          <em><a>검증 가능</a>하지 않으므로</em> <a>검증가능한 크리덴셜</a>도
          <a>검증가능한 프레젠테이션</a>도 아니다.
        </p>
        형
        <dl>
          <dt><dfn data-lt="type|types|유형">type</dfn></dt>
          <dd>
            <code>type</code> <a>속성</a>의 값은 반드시 하나 이상의
            <a>URI</a>이거나 (<code>@context</code> 속성의 해석을 통해) 하나
            이상의 <a>URI</a>에 매핑되어야 한다. 둘 이상의 <a>URI</a>가 제공되는
            경우, <a>URI</a>는 순서가 없는 집합으로 해석되어야 한다. 개발자
            사용을 용이하게 하기 위해 구문적 편의성이 사용되어야 한다(SHOULD).
            이러한 편의성에는 JSON-LD 용어가 포함될 수 있다. <code>type</code>의
            각 <a>URI</a>는 역참조될 경우 <code>type</code>에 대한 기계 판독
            가능한 정보가 포함된 문서를 반환하는 것이 좋다(RECOMMENDED).
          </dd>
        </dl>

        <pre class="example nohighlight" title="Usage of the type property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "UniversityDegreeCredential"]</span>,
  "issuer": "https://example.edu/issuers/565049",
  "issuanceDate": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          이 규격과 관련하여, 다음 표는 <a>유형</a>을 지정해야 하는 객체를
          나열한다.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>객체</th>
              <th>유형</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                <a>검증가능한 크리덴셜</a>&nbsp;객체 <br />(<a
                  href="#credentials"
                  >크리덴셜</a
                >&nbsp;객체의 하위 클래스)
              </td>
              <td>
                <code>VerifiableCredential</code>과 선택적으로 더 구체적인
                <a>검증가능한 크리덴셜</a> <a>유형</a>. 예를 들어,<br />
                <code
                  >"type": ["VerifiableCredential",
                  "UniversityDegreeCredential"]</code
                >
              </td>
            </tr>

            <tr>
              <td><a href="#credentials">크리덴셜</a>&nbsp;객체</td>
              <td>
                <code>VerifiableCredential</code>과 선택적으로 더 구체적인
                <a>검증가능한 크리덴셜</a> <a>유형</a>. 예를 들어,<br />
                <code
                  >"type": ["VerifiableCredential",
                  "UniversityDegreeCredential"]</code
                >
              </td>
            </tr>

            <tr>
              <td>
                <a>검증가능한 프레젠테이션</a>&nbsp;객체 <br />(<a
                  href="#presentations"
                  >프레젠테이션</a
                >&nbsp;객체의 하위 클래스)
              </td>
              <td>
                <code>VerifiablePresentation</code>과 선택적으로 더 구체적인
                <a>검증가능한 프레젠테이션</a> <a>유형</a>. 예를 들어,<br />
                <code
                  >"type": ["VerifiablePresentation",
                  "CredentialManagerPresentation"]</code
                >
              </td>
            </tr>

            <tr>
              <td><a href="#presentations">프레젠테이션</a>&nbsp;객체</td>
              <td>
                <code>VerifiablePresentation</code>과 선택적으로 더 구체적인
                <a>검증가능한 프레젠테이션</a> <a>유형</a>. 예를 들어,<br />
                <code
                  >"type": ["VerifiablePresentation",
                  "CredentialManagerPresentation"]</code
                >
              </td>
            </tr>

            <tr>
              <td><a href="#proofs-signatures">증명</a>&nbsp;객체</td>
              <td>
                유효한 증명 <a>유형</a>. 예를 들어,<br />
                <code>"type": "RsaSignature2018"</code>
              </td>
            </tr>

            <tr>
              <td><a href="#status">credentialStatus</a>&nbsp;객체</td>
              <td>
                유효한 <a>크리덴셜</a> 상태 <a>유형</a>. 예를 들어,<br />
                <code>"type": "CredentialStatusList2017"</code>
              </td>
            </tr>

            <tr>
              <td><a href="#terms-of-use">termsOfUse</a>&nbsp;객체</td>
              <td>
                유효한 이용 약관 <a>유형</a>. 예를 들어,<br />
                <code>"type": "OdrlPolicy2017"</code>)
              </td>
            </tr>

            <tr>
              <td><a href="#evidence">evidence</a>&nbsp;객체</td>
              <td>
                유효한 증거 <a>유형</a>. 예를 들어,<br />
                <code>"type": "DocumentVerification2018"</code>
              </td>
            </tr>
          </tbody>
        </table>

        <p class="note">
          검증가능한 크리덴셜 데이터 모델의 <a>유형</a> 시스템은 [[JSON-LD]]와
          동일하며
          <a href="https://www.w3.org/TR/json-ld/#specifying-the-type"
            >5.4절: 유형 지정</a
          >과
          <a href="https://www.w3.org/TR/json-ld/#json-ld-grammar"
            >8절: JSON-LD 문법</a
          >에 상세히 설명되어 있다. JSON-LD 컨텍스트(섹션
          <a href="#extensibility"></a> 참조)를 사용할 때, 이 규격은 JSON-LD
          문서를 더 쉽게 이해할 수 있도록 <code>@type</code> 키워드를
          <code>type</code>으로 별칭한다. 애플리케이션 개발자와 문서 작성자는
          JSON-LD 유형 시스템의 세부 사항을 이해할 필요는 없지만, 상호운용
          가능한 확장성을 지원하려는 이 규격의 구현자는 이해해야 한다.
        </p>

        <p>
          모든 <a>크리덴셜</a>, <a>프레젠테이션</a>, 캡슐화된 객체는 소프트웨어
          시스템이 이 추가 정보를 처리할 수 있도록 반드시 더 좁은
          <a>유형</a>(<code>UniversityDegreeCredential</code> 등)과 연결되거나
          지정해야 한다(MUST).
        </p>

        <p>
          이 규격에 정의된 캡슐화된 객체(<code>credentialSubject</code> 객체와
          연관되거나 그 안에 깊이 중첩된 객체)를 처리할 때, 소프트웨어 시스템은
          계층의 상위에 있는 캡슐화 객체에 지정된 <a>유형</a> 정보를 사용해야
          한다(SHOULD). 구체적으로, <a>크리덴셜</a>과 같은 캡슐화 객체는
          <a>검증자</a>가 캡슐화 객체 <a>유형</a>을 기반으로 연관된 객체의
          내용을 신속하게 파악할 수 있도록 연관된 객체 <a>유형</a>을 전달해야
          한다(SHOULD).
        </p>

        <p>
          예를 들어, <code>UniversityDegreeCredential</code>의
          <code>type</code>을 가진 <a>크리덴셜</a> 객체는
          <code>credentialSubject</code> 속성과 연관된 객체가 다음을 위한
          식별자를 포함하고 있음을 <a>검증자</a>에게 알린다:
        </p>

        <ul>
          <li><code>id</code> 속성의 <a>주체</a>.</li>
          <li><code>type</code> 속성의 학위 유형.</li>
          <li><code>name</code> 속성의 학위 제목.</li>
        </ul>

        <p>
          이를 통해 구현자는 <a>검증</a> 목적으로 <code>type</code> 속성과
          관련된 값에 의존할 수 있다. <a>유형</a>과 그와 관련된 속성에 대한
          기대는 최소한 사람이 읽을 수 있는 규격에 문서화되어야 하며, 가급적이면
          추가적인 기계 판독 가능한 표현으로 문서화되는 것이 좋다.
        </p>

        <p class="note">
          이 규격에 설명된 데이터 모델에 사용되는 유형 시스템은 데이터와 유형을
          연결하는 여러 가지 방법을 허용한다. 구현자와 작성자는 검증가능한
          크리덴셜 구현 지침 [[?VC-IMP-GUIDE]]의 유형 지정 섹션을 읽어보는 것이
          좋다.
        </p>
      </section>

      <section>
        <h3>크리덴셜 주체</h3>

        <p>
          <a>검증가능한 크리덴셜</a>은 하나 이상의 <a>주체</a>에 대한
          <a>클레임</a>을 포함한다. 이 규격은 하나 이상의 <a>주체</a>에 대한
          <a>클레임</a> 표현을 위해 <code>credentialSubject</code> <a>속성</a>을
          정의한다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>은 반드시 <code>credentialSubject</code>
          <a>속성</a>을 가져야 한다.
        </p>

        <dl>
          <dt>credentialSubject</dt>
          <dd>
            <code>credentialSubject</code> <a>속성</a>의 값은 각각
            <a>검증가능한 크리덴셜</a>의 <a>주체</a>와 관련된 하나 이상의 속성을
            포함하는 객체 집합으로 정의된다. 각 객체는
            <a href="#identifiers"></a> 섹션에 설명된 대로 <code>id</code>를
            포함할 수 있다.
          </dd>
        </dl>

        <pre
          class="example nohighlight"
          title="Usage of the credentialSubject property"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/565049",
  "issuanceDate": "2010-01-01T00:00:00Z",
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          <a>검증가능한 크리덴셜</a>에서 여러 <a>주체</a>와 관련된 정보를 표현할
          수 있다. 아래 예는 배우자인 두 <a>주체</a>를 지정한다.
          `credentialSubject` 속성과 여러 <a>주체</a>를 연결하기 위해 배열
          표기법을 사용하는 점에 유의하라.
        </p>

        <pre
          class="example nohighlight"
          title="Specifying multiple subjects in a verifiable credential"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.com/issuer/123",
  "issuanceDate": "2010-01-01T00:00:00Z",
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
    "name": "Morgan Doe",
    "spouse": "did:example:ebfeb1f712ebc6f1c276e12ec21"
  }]</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>
      </section>

      <section>
        <h3>발급자</h3>

        <p>
          이 규격은 <a>검증가능한 크리덴셜</a>의 <a>발급자</a>를 표현하기 위한
          속성을 정의한다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>은 반드시 <code>issuer</code> <a>속성</a>을
          가져야 한다.
        </p>

        <dl>
          <dt><var>issuer</var></dt>
          <dd>
            <code>issuer</code> <a>속성</a>의 값은 반드시 <a>URI</a> 또는
            <code>id</code> <a>속성</a>을 포함하는 객체여야 한다.
            <code>issuer</code> 또는 그 <code>id</code>의 <a>URI</a>는
            역참조되는 경우 <a>크리덴셜</a>에 표현된 정보를 <a>검증</a>하는 데
            사용할 수 있는 <a>발급자</a>에 대한 기계 판독 가능한 정보를 포함하는
            문서로 연결되는 것이 권장된다.
          </dd>
        </dl>

        <pre class="example nohighlight" title="Usage of issuer property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"issuer": "https://example.edu/issuers/14"</span>,
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          발급자에 대한 추가 정보를 발급자 속성과 객체를 연결하여 표현할 수도
          있다:
        </p>

        <pre
          class="example nohighlight"
          title="Usage of issuer expanded property"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p class="note">
          <code>issuer</code> <a>속성</a>의 값은 JWK(예:
          <code>"https://example.com/keys/foo.jwk"</code>) 또는 <a>DID</a>(예:
          <code>"did:example:abfe13f712120431c276e12ecab"</code>)일 수도 있다.
        </p>
      </section>
      <section>
        <h3>발행일</h3>
        <p>
          이 규격은 <a>크리덴셜</a>이 유효해지는 날짜와 시간을 표현하기 위해
          <code>issuanceDate</code> <a>속성</a>을 정의한다.
        </p>
        <dl>
          <dt><var>issuanceDate</var></dt>
          <dd>
            <a>크리덴셜</a>은 반드시 <code>issuanceDate</code> <a>속성</a>을
            가져야 한다. <code>issuanceDate</code> <a>속성</a>의 값은 반드시
            <a>크리덴셜</a>이 유효해지는 날짜와 시간을 나타내는 \[<a
              data-cite="XMLSCHEMA11-2#dateTime"
              >XMLSCHEMA11-2</a
            >\] 결합 <code>date-time</code> 문자열 값이어야 하며, 이는 미래의
            날짜와 시간일 수 있다. 이 값은 <code>credentialSubject</code>
            <a>속성</a>과 연결된 정보가 유효해지는 가장 이른 시점을 나타낸다는
            점에 유의하라.
          </dd>
        </dl>

        <pre class="example nohighlight" title="Usage of issuanceDate property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  <span class="highlight">"issuanceDate": "2010-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p class="note">
          이 규격의 다음 버전에서는 <code>validFrom</code> <a>속성</a>을
          추가하고 <code>issuanceDate</code> <a>속성</a> 대신 새로운
          <code>issued</code> <a>속성</a>을 사용할 예정이다. 두 속성의 값 범위는
          \[<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>\] 결합
          <code>date-time</code> 문자열로 유지될 것으로 예상된다. 구현자는
          <code>validFrom</code>과 <code>issued</code> <a>속성</a>이 예약되어
          있으며 다른 목적으로 사용하는 것은 권장되지 않는다는 점에 유의해야
          한다.
        </p>
      </section>
      <section>
        <h3>증명(서명)</h3>
        <p>
          <a>크리덴셜</a> 또는 <a>프레젠테이션</a>이
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>이
          되려면, 즉 <a>검증 가능</a>하려면 최소 하나의 증명 메커니즘과 해당
          증명을 평가하는 데 필요한 세부 정보가 반드시 표현되어야 한다.
        </p>
        <p>
          이 규격은 외부 증명과 내장 증명이라는 두 가지 클래스의 증명 메커니즘을
          식별한다. <dfn>외부 증명</dfn>은 섹션
          <a href="#json-web-token"></a>에서 자세히 설명하는 JSON 웹 토큰과 같이
          이 데이터 모델의 표현을 감싸는 것이다. <dfn>내장 증명</dfn>은 섹션
          <a href="#linked-data-proofs"></a>에서 자세히 설명하는 연결된 데이터
          서명과 같이 증명이 데이터에 포함되는 메커니즘이다.
        </p>
        <p>
          증명을 내장할 때는 반드시 <code>proof</code> <a>속성</a>을 사용해야
          한다.
        </p>

        <dl>
          <dt><var>proof</var></dt>
          <dd>
            변조를 탐지하고 <a>크리덴셜</a> 또는 <a>프레젠테이션</a>의 작성자를
            검증하는 데 사용할 수 있는 하나 이상의 암호학적 증명이다.
            <a>내장 증명</a>에 사용되는 특정 방법은 반드시 <code>type</code>
            <a>속성</a>을 사용하여 포함되어야 한다.
          </dd>
        </dl>
        <p>
          수학적 증명에 사용되는 방법은 표현 언어와 사용된 기술에 따라 다르기
          때문에 <code>proof</code> <a>속성</a>의 값으로 예상되는 이름-값 쌍의
          집합도 그에 따라 달라진다. 예를 들어, 증명 메커니즘에 디지털 서명이
          사용되는 경우 <code>proof</code> <a>속성</a>에는 서명, 서명 엔티티에
          대한 참조, 서명 날짜의 표현을 포함하는 이름-값 쌍이 있을 것으로
          예상된다. 아래 예는 RSA 디지털 서명을 사용한다.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the proof property on a verifiable credential"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "RsaSignature2018",
    "created": "2018-06-18T21:19:10Z",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "https://example.com/jdoe/keys/1",
    "jws": "eyJhbGciOiJQUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19
      ..DJBMvvFAIC00nSGB6Tn0XKbbF9XrsaJZREWvR2aONYTQQxnyXirtXnlewJMB
      Bn2h9hfcGZrvnC1b6PgWmukzFJ1IiH1dWgnDIS81BH-IxXnPkbuYDeySorc4
      QU9MJxdVkY5EL4HYbcIfwKj6X4LBQ2_ZHZIu1jdqLcRZqHcsDF5KKylKc1TH
      n5VRWy5WhYg_gBnyWny8E6Qkrze53MR7OuAmmNJ1m1nN8SxDrG6a08L78J0-
      Fbas5OjAQz3c17GY8mVuDPOBIOVjMEghBlgl3nOi1ysxbRGhHLEK4s0KKbeR
      ogZdgt1DkQxDFxxn41QWDw_mmMCjs9qxg0zcZzqEJw"
  }</span>
}
        </pre>

        <p class="note">
          섹션 <a href="#conformance"></a>에서 논의한 바와 같이 여러 가지 실행
          가능한 증명 메커니즘이 있으며, 이 규격은 <a>검증가능한 크리덴셜</a>과
          함께 사용할 단일 증명 메커니즘을 표준화하거나 권장하지 않는다.
          <code>proof</code> 메커니즘에 대한 자세한 내용은 다음 규격을 참조하라:
          연결된 데이터 증명 \[\[?LD-PROOFS\]\], 연결된 데이터 암호학적 스위트
          레지스트리 \[\[?LDP-REGISTRY\]\], JSON 웹 서명(JWS) 비인코딩 페이로드
          옵션 \[\[RFC7797\]\]. 증명 메커니즘 목록은 검증가능한 크리덴셜 확장
          레지스트리 \[\[VC-EXTENSION-REGISTRY\]\]에서 확인할 수 있다.
        </p>
      </section>
      <section>
        <h3>만료</h3>
        <p>
          이 규격은 <a>크리덴셜</a> 만료 정보를 표현하기 위해
          <code>expirationDate</code> <a>속성</a>을 정의한다.
        </p>
        <dl>
          <dt><var>expirationDate</var></dt>
          <dd>
            존재하는 경우, <code>expirationDate</code> <a>속성</a>의 값은 반드시
            <a>크리덴셜</a>이 유효하지 않게 되는 날짜와 시간을 나타내는 \[<a
              data-cite="XMLSCHEMA11-2#dateTime"
              >XMLSCHEMA11-2</a
            >\] <code>date-time</code>의 문자열 값이어야 한다.
          </dd>
        </dl>

        <pre
          class="example nohighlight"
          title="Usage of the expirationDate property"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  <span class="highlight">"expirationDate": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p class="note">
          이 규격의 다음 버전에서는 <code>expirationDate</code> <a>속성</a>과
          이전 버전과의 호환성을 유지하면서도 더 이상 사용되지 않도록 하는
          방식으로 <code>validUntil</code> <a>속성</a>을 추가할 것으로 예상된다.
          구현자는 <code>validUntil</code> <a>속성</a>이 예약되어 있으며 다른
          목적으로 사용하는 것은 권장되지 않는다는 점에 유의해야 한다.
        </p>
      </section>

      <section>
        <h3>상태</h3>

        <p>
          이 규격은 <a>검증가능한 크리덴셜</a>의 현재 상태(예: 일시 중지 또는
          취소 여부)에 대한 정보를 발견하기 위해 다음과 같은
          <code>credentialStatus</code> <a>속성</a>을 정의한다.
        </p>

        <dl>
          <dt><var>credentialStatus</var></dt>
          <dd>
            존재하는 경우, <code>credentialStatus</code> <a>속성</a>의 값은
            반드시 다음을 포함해야 한다:
            <ul>
              <li><a>URI</a>여야 하는 <code>id</code> <a>속성</a>.</li>
              <li>
                <a>크리덴셜</a> 상태 유형(<a>크리덴셜</a> 상태 메서드라고도
                함)을 표현하는 <code>type</code> <a>속성</a>. 이 값은
                <a>크리덴셜</a>의 현재 상태를 결정하기에 충분한 정보를 제공할
                것으로 예상된다. 예를 들어, 객체에는 <a>크리덴셜</a>이 일시
                중지되었는지 또는 취소되었는지 여부를 나타내는 외부 문서에 대한
                링크가 포함될 수 있다.
              </li>
            </ul>
          </dd>
        </dl>

        <p>
          <a>크리덴셜</a> 상태 정보의 정확한 내용은 특정
          <code>credentialStatus</code> <a>유형</a> 정의에 의해 결정되며, 구현이
          간단한지 또는 프라이버시를 향상시키는지 여부와 같은 요소에 따라
          달라진다.
        </p>

        <pre class="example nohighlight" title="Usage of the status property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://example.edu/status/24",
    "type": "CredentialStatusList2017"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          상태 체계에 대한 데이터 모델, 형식 및 프로토콜 정의는 이 규격의 범위를
          벗어난다. <a>검증가능한 크리덴셜</a> 상태 확인을 구현하고자 하는
          구현자를 위해 사용 가능한 상태 체계를 포함하는 검증가능한 크리덴셜
          확장 레지스트리 \[\[?VC-EXTENSION-REGISTRY\]\]가 존재한다.
        </p>
      </section>

      <section>
        <h3>프레젠테이션</h3>

        <p>
          <a>프레젠테이션</a>은 <a>크리덴셜</a>을 결합하고 제시하는 데 사용될 수
          있다. 데이터의 저작권이 <a>검증 가능</a>하도록 패키징될 수 있다.
          <a>프레젠테이션</a>의 데이터는 종종 동일한 <a>주체</a>에 관한
          것이지만, 데이터에 포함될 수 있는 <a>주체</a> 또는 <a>발급자</a>의
          수에는 제한이 없다. 여러 <a>검증가능한 크리덴셜</a>의 정보 집계는
          <a>검증가능한 프레젠테이션</a>의 전형적인 사용이다.
        </p>

        <p>
          <a>검증가능한 프레젠테이션</a>은 일반적으로 다음과 같은 속성으로
          구성된다:
        </p>

        <dl>
          <dt><var>id</var></dt>
          <dd>
            <code>id</code> <a>속성</a>은 선택 사항이며 <a>프레젠테이션</a>에
            대한 고유 식별자를 제공하는 데 사용될 수 있다. 이 속성 사용과 관련된
            자세한 내용은 섹션 <a href="#identifiers"></a>를 참조하라.
          </dd>
          <dt><var>type</var></dt>
          <dd>
            <code>type</code> <a>속성</a>은 필수이며
            <code>VerifiablePresentation</code>과 같은 <a>프레젠테이션</a>의
            유형을 표현한다. 이 속성 사용과 관련된 자세한 내용은 섹션
            <a href="#types"></a>를 참조하라.
          </dd>
          <dt><var>verifiableCredential</var></dt>
          <dd>
            존재하는 경우, <code>verifiableCredential</code> <a>속성</a>의 값은
            반드시 하나 이상의 <a>검증가능한 크리덴셜</a>이나 암호학적으로
            <a>검증 가능</a>한 형식의 <a>검증가능한 크리덴셜</a>에서 파생된
            데이터로 구성되어야 한다.
          </dd>
          <dt><var>holder</var></dt>
          <dd>
            존재하는 경우, <code>holder</code> <a>속성</a>의 값은
            <a>프레젠테이션</a>을 생성하는 엔티티에 대한 <a>URI</a>일 것으로
            예상된다.
          </dd>
          <dt><var>proof</var></dt>
          <dd>
            존재하는 경우, <code>proof</code> <a>속성</a>의 값은
            <a>프레젠테이션</a>이 <a>검증 가능</a>함을 보장한다. 이 속성 사용과
            관련된 자세한 내용은 섹션 <a href="#proofs-signatures"></a>를
            참조하라.
          </dd>
        </dl>

        <p>
          아래 예는 <a>검증가능한 크리덴셜</a>을 내장하는
          <a>검증가능한 프레젠테이션</a>을 보여준다.
        </p>

        <pre
          class="example nohighlight"
          title="Basic structure of a presentation"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "CredentialManagerPresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }],
  "proof": [{ <span class="comment">...</span> }]</span>
}
        </pre>

        <p>
          위에 표시된 <code>verifiableCredential</code> <a>속성</a>의 내용은 이
          규격에서 설명하는 대로 <a>검증가능한 크리덴셜</a>이다.
          <code>proof</code> <a>속성</a>의 내용은 연결된 데이터 증명
          \[\[?LD-PROOFS\]\] 규격에서 설명하는 증명이다. JWT 증명 메커니즘을
          사용하는 <a>검증가능한 프레젠테이션</a>의 예는 섹션
          <a href="#json-web-token"></a>에 제시되어 있다.
        </p>

        <h4>파생 크리덴셜을 사용하는 프레젠테이션</h4>

        <p>
          일부 영지식 암호 체계는 <a>보유자</a>가
          <a>검증가능한 크리덴셜</a> 자체를 공개하지 않고도
          <a>검증가능한 크리덴셜</a>에서 <a>클레임</a>을 보유하고 있음을
          간접적으로 증명할 수 있게 한다. 이러한 체계에서
          <a>검증가능한 크리덴셜</a>의 <a>클레임</a>은 <a>검증자</a>가
          <a>발급자</a>를 신뢰하는 경우 값을 신뢰할 수 있도록 암호학적으로
          주장되는 방식으로 제시된 값을 파생하는 데 사용될 수 있다.
        </p>

        <p>
          예를 들어, <a>클레임</a> <code>생년월일</code>을 포함하는
          <a>검증가능한 크리덴셜</a>은 암호학적으로 <a>검증 가능</a>한 방식으로
          제시된 값 <code>15세 이상</code>을 파생하는 데 사용될 수 있다. 즉,
          <a>검증자</a>는 <a>발급자</a>를 신뢰하는 경우 파생된 값을 여전히
          신뢰할 수 있다.
        </p>

        <p class="note">
          직접 내장된 <a>검증가능한 크리덴셜</a> 대신 파생된 데이터를 포함하는
          ZKP 스타일의 <a>검증가능한 프레젠테이션</a> 예는 섹션
          <a href="#zero-knowledge-proofs"></a>를 참조하라.
        </p>

        <p>
          영지식 증명을 사용하는 선택적 공개 체계는 이 모델에 표현된
          <a>클레임</a>을 사용하여 해당 <a>클레임</a>에 대한 추가 명제를 증명할
          수 있다. 예를 들어, <a>주체</a>의 생년월일을 지정하는 <a>클레임</a>은
          <a>주체</a>의 실제 생년월일을 공개하지 않고도 <a>주체</a>의 나이가
          주어진 범위 내에 있음을 증명하고, 따라서 <a>주체</a>가 연령 관련 할인
          자격이 있음을 증명하는 데 述語로 사용될 수 있다. <a>보유자</a>는
          원하는 <a>검증가능한 프레젠테이션</a>에 적용 가능한 모든 방식으로
          <a>클레임</a>을 사용할 수 있는 유연성을 가진다.
        </p>

        <figure>
          <img
            style="margin: auto; display: block; width: 50%"
            src="diagrams/claim-example-2.svg"
            alt="Pat has a property
            dateOfBirth whose value is 2010-01-01"
          />
          <figcaption style="text-align: center">
            A basic claim expressing that Pat's date of birth is January 1,
            2010. Date encoding would be determined by the schema.
          </figcaption>
        </figure>
      </section>
    </section>

    <section>
      <h2 id="advanced-concepts">고급 개념</h2>

      <p>
        섹션 <a href="#basic-concepts"></a>에서 소개된 개념을 기반으로 이
        섹션에서는 <a>검증가능한 크리덴셜</a>에 대한 보다 복잡한 주제를
        탐구한다.
      </p>

      <section class="informative">
        <h3>라이프사이클 세부 정보</h3>

        <p>
          섹션 <a href="#ecosystem-overview"></a>에서는
          <a>검증가능한 크리덴셜</a> 생태계에 대한 개요를 제공했다. 이
          섹션에서는 생태계가 어떻게 작동할 것으로 예상되는지에 대해 자세히
          설명한다.
        </p>

        <figure id="life-cycle-details">
          <img
            style="margin: auto; display: block; width: 85%"
            src="diagrams/ecosystemdetail.svg"
            alt="발급자에서 보유자로, 선택적으로 한 보유자에서 다른 보유자로 크리덴셜이 흐르는 방식과 보유자에서 검증자로 프레젠테이션이 흐르는 방식을 보여주는 다이어그램. 모든 당사자는 논리적 검증가능한 데이터 레지스트리의 정보를 사용할 수 있음"
          />
          <figcaption style="text-align: center">
            이 규격의 역할과 정보 흐름.
          </figcaption>
        </figure>

        <p>
          <a>검증가능한 크리덴셜</a> 생태계의 역할과 정보 흐름은 다음과 같다:
        </p>

        <ul>
          <li>
            <a>발급자</a>가 <a>보유자</a>에게 <a>검증가능한 크리덴셜</a>을
            <dfn data-lt="issue">발급</dfn>한다. 발급은 <a>크리덴셜</a>과 관련된
            다른 모든 작업 이전에 항상 발생한다.
          </li>
          <li>
            <a>보유자</a>는 자신의 <a>검증가능한 크리덴셜</a> 중 하나 이상을
            다른 <a>보유자</a>에게 <dfn data-lt="transfers">이전</dfn>할 수
            있다.
          </li>
          <li>
            <a>보유자</a>는 자신의 <a>검증가능한 크리덴셜</a> 중 하나 이상을
            선택적으로 <a>검증가능한 프레젠테이션</a> 내에 <a>검증자</a>에게
            <dfn data-lt="present">제시</dfn>한다.
          </li>
          <li>
            <a>검증자</a>는 제시된 <a>검증가능한 프레젠테이션</a>과
            <a>검증가능한 크리덴셜</a>의 진위를 <a>검증</a>한다. 여기에는
            <a>검증가능한 크리덴셜</a>의 폐기에 대한
            <a href="#status">크리덴셜 상태</a> 확인이 포함되어야 한다.
          </li>
          <li>
            <a>발급자</a>는 <a>검증가능한 크리덴셜</a>을
            <dfn data-lt="revoke">폐기</dfn>할 수 있다.
          </li>
          <li>
            <a>보유자</a>는 <a>검증가능한 크리덴셜</a>을
            <dfn data-lt="delete">삭제</dfn>할 수 있다.
          </li>
        </ul>

        <p class="note">
          위의 작업 순서는 고정되어 있지 않으며 일부 작업은 둘 이상 수행될 수
          있다. 이러한 작업 반복은 즉시 또는 나중에 언제든지 발생할 수 있다.
        </p>

        <p>가장 일반적인 작업 순서는 다음과 같이 예상된다:</p>

        <ol>
          <li>
            <a>발급자</a>가 <a>보유자</a>에게
            <a href="#lifecycle-details">발급</a>한다.
          </li>
          <li>
            <a>보유자</a>가 <a>검증자</a>에게
            <a href="#lifecycle-details">제시</a>한다.
          </li>
          <li><a>검증자</a>가 <a href="#lifecycle-details">검증</a>한다.</li>
        </ol>

        <p>
          이 규격은 <a>검증가능한 크리덴셜</a> 또는
          <a>검증가능한 프레젠테이션</a>을 전송하기 위한 어떠한 프로토콜도
          정의하지 않지만, 다른 규격에서 엔티티 간에 전송되는 방법을 지정한다고
          가정하면 이 검증가능한 크리덴셜 데이터 모델이 직접 적용된다.
        </p>

        <p>
          이 규격은 또한 권한 부여 프레임워크나 <a>검증자</a>가 <a>보유자</a>,
          <a>검증가능한 크리덴셜</a>의 <a>발급자</a>,
          <a>검증가능한 크리덴셜</a>의 내용 및 자체 정책을 고려하여
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>을
          <a>검증</a>한 후 내릴 수 있는 결정을 정의하지 않는다.
        </p>

        <p>
          특히, 섹션 <a href="#terms-of-use"></a>와
          <a href="#subject-holder-relationships"></a>는 <a>검증자</a>가 다음을
          결정할 수 있는 방법을 지정한다:
        </p>

        <ul>
          <li>
            <a>보유자</a>가 <a>검증가능한 크리덴셜</a>의 <a>주체</a>인지 여부.
          </li>
          <li><a>주체</a>와 <a>보유자</a> 사이의 관계.</li>
          <li>
            원래 <a>보유자</a>가 <a>검증가능한 크리덴셜</a>을 후속
            <a>보유자</a>에게 전달했는지 여부.
          </li>
          <li>
            <a>보유자</a> 또는 <a>검증자</a>에 의한
            <a>검증가능한 크리덴셜</a> 사용에 대한 제한 사항.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h2>신뢰 모델</h2>

        <p><a>검증가능한 크리덴셜</a>의 신뢰 모델은 다음과 같다:</p>

        <ul>
          <li>
            <a>검증자</a>는 <a>발급자</a>가 수신한 <a>크리덴셜</a>을 발급한 것을
            신뢰한다. 이 신뢰를 구축하기 위해 <a>크리덴셜</a>은 다음 중 하나여야
            한다:
            <ul>
              <li>
                <a>발급자</a>가 <a>크리덴셜</a>을 생성했음을 입증하는
                <a href="#proofs-signatures">증명</a>을 포함한다(즉,
                <a>검증가능한 크리덴셜</a>이다).
              </li>
              <li>
                <a>발급자</a>가 <a>검증가능한 크리덴셜</a>을 생성했으며
                <a>검증가능한 크리덴셜</a>이 전송 또는 저장 중에 변조되지
                않았음을 명확히 입증하는 방식으로 전송되었다. 이 신뢰는
                <a>검증자</a>의 위험 평가에 따라 약화될 수 있다.
              </li>
            </ul>
          </li>
          <li>
            모든 <a>엔티티</a>는 <a>검증가능한 데이터 레지스트리</a>가 변조
            증거가 있으며 어떤 데이터가 어떤 <a>엔티티</a>에 의해 제어되는지에
            대한 올바른 기록임을 신뢰한다.
          </li>
          <li>
            <a>보유자</a>와 <a>검증자</a>는 <a>발급자</a>가 <a>주체</a>에 대해
            진실된(즉, 거짓이 아닌) <a>크리덴셜</a>을 발급하고 적절할 때 신속히
            폐기할 것으로 신뢰한다.
          </li>
          <li>
            <a>보유자</a>는 <a>리포지토리</a>가 <a>크리덴셜</a>을 안전하게
            저장하고, <a>보유자</a> 이외의 다른 사람에게 공개하지 않으며,
            관리하는 동안 손상시키거나 잃어버리지 않을 것으로 신뢰한다.
          </li>
        </ul>

        <p>이 신뢰 모델은 다음을 보장함으로써 다른 신뢰 모델과 차별화된다:</p>

        <ul>
          <li>
            <a>발급자</a>와 <a>검증자</a>는 <a>리포지토리</a>를 신뢰할 필요가
            없다.
          </li>
          <li><a>발급자</a>는 <a>검증자</a>를 알거나 신뢰할 필요가 없다.</li>
        </ul>

        <p>
          <a>신원 제공자</a>와 <a>신뢰 당사자</a> 간의 신뢰를 분리함으로써 시장
          경쟁과 고객 선택이 증가하는 보다 유연하고 역동적인 신뢰 모델이
          만들어진다.
        </p>

        <p>
          이 신뢰 모델이 작업 그룹에서 연구한 다양한 위협 모델과 어떻게
          상호작용하는지에 대한 자세한 내용은 검증가능한 크리덴셜 사용 사례 문서
          \[\[VC-USE-CASES\]\]를 참조하라.
        </p>

        <p class="note">
          이 규격에 상세히 설명된 데이터 모델은 기존의 인증 기관 신뢰 모델에서
          제공하는 것과 같은 전이적 신뢰 모델을 의미하지 않는다. 검증가능한
          크리덴셜 데이터 모델에서 <a>검증자</a>는 <a>발급자</a>를 직접
          신뢰하거나 신뢰하지 않는다. 검증가능한 크리덴셜 데이터 모델을 사용하여
          전이적 신뢰 모델을 구축할 수 있지만, 구현자는 인증 기관 시스템에서
          채택한 방식으로
          <a href="https://www.cs.cornell.edu/people/egs/papers/dnssurvey.pdf"
            >신뢰를 광범위하게 위임</a
          >함으로써 발생하는
          <a
            href="https://datatracker.ietf.org/doc/draft-housley-web-pki-problems/"
            >보안 취약점에 대해 알아보는 것</a
          >이 좋다.
        </p>
      </section>

      <section>
        <h3 id="extensibility">확장성</h3>

        <p>
          검증가능한 크리덴셜 데이터 모델의 목표 중 하나는 허가 없는 혁신을
          가능하게 하는 것이다. 이를 달성하기 위해서는 데이터 모델이 여러 가지
          방식으로 확장 가능해야 한다. 데이터 모델은 다음을 수행해야 한다:
        </p>

        <ul>
          <li>
            <a>그래프</a> 기반 데이터 모델을 사용하여 복잡한 다중 엔티티 관계를
            모델링한다.
          </li>
          <li>
            \[\[?LINKED-DATA\]\]를 사용하여 중앙 집중식 시스템 없이 데이터
            모델에서 정보를 설명하는 데 사용되는 기계 판독 가능 어휘를 확장한다.
          </li>
          <li>
            연결된 데이터 증명 \[\[?LD-PROOFS\]\]과 연결된 데이터 암호화 스위트
            레지스트리 \[\[?LDP-REGISTRY\]\]에 나열된 다양한 서명 스위트를
            사용하여 여러 유형의 암호화 증명 형식을 지원한다.
          </li>
          <li>
            \[\[JSON-LD\]\]를 사용하여 소프트웨어 개발자와 웹 페이지 작성자에게
            널리 사용되는 데이터 형식으로 위에서 설명한 모든 확장성 메커니즘을
            제공한다.
          </li>
        </ul>

        <p>
          이러한 데이터 모델링 접근 방식을 종종 <em>개방형 세계 가정</em>이라고
          하며, 이는 모든 엔티티가 다른 모든 엔티티에 대해 어떤 것이라도 말할 수
          있음을 의미한다. 이러한 접근 방식이 단순하고 예측 가능한 소프트웨어
          시스템 구축과 상충되는 것처럼 보일 수 있지만, 확장성과 프로그램
          정확성의 균형을 맞추는 것은 폐쇄형 소프트웨어 시스템보다 개방형 세계
          가정에서 항상 더 어렵다.
        </p>

        <p>
          이 섹션의 나머지 부분에서는 일련의 예를 통해 확장성과 프로그램
          정확성을 모두 달성하는 방법을 설명한다.
        </p>

        <p>
          아래에 표시된 <a>검증가능한 크리덴셜</a>로 시작한다고 가정해 보자.
        </p>

        <pre class="example nohighlight" title="A simple credential">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "issuanceDate": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          이 <a>검증가능한 크리덴셜</a>은
          <code>did:example:abcdef1234567</code>과 연결된 <a>엔티티</a>가 값이
          <code>Jane Doe</code>인 <code>name</code>을 가지고 있음을 명시한다.
        </p>
        <p>
          이제 개발자가 내부 기업 참조 번호와 Jane이 좋아하는 음식이라는 두 가지
          추가 정보를 저장하기 위해 <a>검증가능한 크리덴셜</a>을 확장하려고
          한다고 가정해 보자.
        </p>
        <p>
          먼저 아래와 같이 두 개의 새로운 용어를 포함하는 JSON-LD 컨텍스트를
          생성해야 한다.
        </p>

        <pre class="example nohighlight" title="A JSON-LD context">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

        <p>
          이 JSON-LD 컨텍스트가 생성된 후, 개발자는 <a>검증가능한 크리덴셜</a>을
          처리할 <a>검증자</a>가 액세스할 수 있도록 어딘가에 게시한다. 위의
          JSON-LD 컨텍스트가
          <code>https://example.com/contexts/mycontext.jsonld</code>에
          게시되었다고 가정하면, 컨텍스트를 포함하고 새로운 <a>속성</a>과
          <a>크리덴셜</a> <a>유형</a>을 <a>검증가능한 크리덴셜</a>에 추가하여 이
          예제를 확장할 수 있다.
        </p>

        <pre
          class="example nohighlight"
          title="A verifiable credential with a custom extension"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "issuanceDate": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          이 예제는 허가 없이 분산된 방식으로 검증가능한 크리덴셜 데이터 모델을
          확장하는 것을 보여준다. 또한 표시된 메커니즘은 이러한 방식으로 생성된
          <a>검증가능한 크리덴셜</a>이 네임스페이스 충돌과 의미론적 모호성을
          방지하는 메커니즘을 제공하도록 보장한다.
        </p>
        <p>
          이와 같은 동적 확장성 모델은 구현 부담을 증가시킨다. 이러한 시스템을
          위해 작성된 소프트웨어는 애플리케이션의 위험 프로파일에 따라 확장된
          <a>검증가능한 크리덴셜</a>이 허용되는지 여부를 결정해야 한다. 일부
          애플리케이션은 특정 확장만 수용할 수 있는 반면, 높은 보안 환경에서는
          어떤 확장도 수용하지 않을 수 있다. 이러한 결정은 이러한 애플리케이션의
          개발자에게 달려 있으며 이 규격의 영역이 특별히 아니다.
        </p>
        <p>
          개발자는 확장 JSON-LD 컨텍스트를 높은 가용성으로 유지하도록 해야 한다.
          컨텍스트를 가져올 수 없는 구현은 오류를 발생시킨다. 확장 JSON-LD
          컨텍스트를 항상 사용할 수 있도록 하는 전략으로는 컨텍스트에 콘텐츠
          주소가 지정된 URL 사용, 컨텍스트 문서를 구현과 번들링, 또는 컨텍스트의
          적극적인 캐싱 활성화 등이 있다.
        </p>
        <p>
          구현자는 섹션 <a href="#proofs-signatures"></a>,
          <a href="#status"></a>, <a href="#data-schemas"></a>,
          <a href="#refreshing"></a>, <a href="#terms-of-use"></a>,
          <a href="#evidence"></a>와 같은 이 규격의 확장점에 세심한 주의를
          기울일 것을 권장한다. 이 규격은 이러한 확장점에 대한 구체적인 구현을
          정의하지 않지만, 검증가능한 크리덴셜 확장 레지스트리
          \[\[?VC-EXTENSION-REGISTRY\]\]는 개발자가 이러한 확장점에서 사용할 수
          있는 비공식적이고 선별된 확장 목록을 제공한다.
        </p>

        <section>
          <h4>의미론적 상호운용성</h4>

          <p>
            이 규격은 JSON 구현에서 JSON-LD 프로세서를 사용할 필요 없이 "일반"
            JSON과 JSON-LD 구문이 의미론적으로 호환되도록 보장한다. 이를
            달성하기 위해 이 규격은 두 구문 모두에 다음과 같은 추가 요구사항을
            부과한다:
          </p>

          <ul>
            <li>
              JSON 기반 프로세서는 반드시 <code>@context</code> 키를 처리하고,
              처리 중인 <a>크리덴셜</a> 유형에 대해 예상되는 값이 예상되는
              순서로 존재하는지 확인해야 한다. 순서가 중요한 이유는
              <code>@context</code>와 연결된 값을 사용하여 정의되는
              <a>크리덴셜</a>에 사용되는 키가 "먼저 정의된 것이 이김" 메커니즘을
              사용하여 정의되기 때문에 순서를 변경하면 다른 키 정의가 "이길" 수
              있기 때문이다.
            </li>
            <li>
              JSON-LD 기반 프로세서는 JSON-LD 컨텍스트가
              <a href="https://www.w3.org/TR/json-ld/#dfn-active-context"
                >활성 컨텍스트</a
              >의 모든 용어를 재정의할 때 오류를 생성해야 한다. 기존 용어의
              정의를 변경하는 유일한 방법은 해당 새 용어의 범위 내에서 활성
              컨텍스트를 지우는 새 용어를 도입하는 것이다. 이 기능에 관심이 있는
              작성자는 JSON-LD 1.1 규격의 <code>@protected</code> 기능에 대해
              읽어봐야 한다.
            </li>
          </ul>

          <p>
            상호운용성을 추구하는 모든 구현자는 <code>@context</code>
            <a>속성</a>에 대한 값의 예상 순서를 설명하는 사람이 읽을 수 있는
            문서를 게시할 것으로 예상된다. 상호운용성을 추구하는 JSON-LD
            구현자는 <code>@context</code> <a>속성</a>에 지정된 URL에 기계 판독
            가능한 설명(즉, 일반 JSON-LD 컨텍스트 문서)을 게시할 것으로
            예상된다.
          </p>

          <p>
            위의 요구사항은 <code>@context</code> 메커니즘으로 정의된 용어에
            대해 JSON과 JSON-LD 간의 의미론적 상호운용성을 보장한다. JSON-LD
            프로세서는 제공된 특정 메커니즘을 사용하고 모든 용어가 올바르게
            지정되었는지 확인할 수 있지만, JSON 기반 프로세서는 용어가 올바른지
            테스트하지 않고 동일한 용어 집합을 암시적으로 수용한다. 즉, 데이터
            교환이 발생하는 컨텍스트는 동일한 메커니즘을 사용하여 JSON과 JSON-LD
            모두에 대해 명시적으로 명시된다. JSON 기반 프로세서와 관련하여, 이는
            JSON-LD 처리 라이브러리를 사용할 필요 없이 가벼운 방식으로 달성된다.
          </p>
        </section>
      </section>

      <section>
        <h3 id="data-schemas">데이터 스키마</h3>

        <p>
          데이터 스키마는 주어진 데이터 집합에 특정 구조를 강제할 때 유용하다.
          이 규격에서 고려하는 데이터 스키마는 최소한 두 가지 유형이 있다:
        </p>

        <ul>
          <li>
            <a>크리덴셜</a> 또는 <a>검증가능한 크리덴셜</a>의 구조와 내용이
            게시된 스키마를 준수하는지 <a>검증</a>하는 데 사용되는 데이터 검증
            스키마.
          </li>
          <li>
            <a>검증가능한 크리덴셜</a>의 내용을 영지식 증명에 사용되는 이진
            형식과 같은 대체 표현 형식에 매핑하는 데 사용되는 데이터 인코딩
            스키마.
          </li>
        </ul>

        <p>
          데이터 스키마가 데이터 구조나 데이터 구문을 강제하지 않고 대체 표현
          형식에 대한 임의의 인코딩 정의를 가능하게 하지 않는
          <code>@context</code> 속성과는 다른 목적을 제공한다는 점을 이해하는
          것이 중요하다.
        </p>

        <p>
          이 규격은 데이터 스키마 표현을 위해 다음 <a>속성</a>을 정의하며, 이는
          <a>발급자</a>가 발급하는 <a>검증가능한 크리덴셜</a>에 포함될 수 있다:
        </p>

        <dl>
          <dt><var>credentialSchema</var></dt>
          <dd>
            <code>credentialSchema</code> <a>속성</a>의 값은 반드시 제공된
            데이터가 제공된 스키마를 준수하는지 여부를 결정하기에 충분한 정보를
            <a>검증자</a>에게 제공하는 하나 이상의 데이터 스키마여야 한다. 각
            <code>credentialSchema</code>는 반드시 그 <code>type</code>(예:
            <code>JsonSchemaValidator2018</code>)과 스키마 파일을 식별하는
            <a>URI</a>여야 하는 <code>id</code> <a>속성</a>을 지정해야 한다. 각
            데이터 스키마의 정확한 내용은 특정 유형 정의에 의해 결정된다.
          </dd>
        </dl>

        <p class="note">
          <code>credentialSchema</code> <a>속성</a>은 유형 정의에 주석을 달거나
          어휘의 특정 버전에 잠글 수 있는 기회를 제공한다.
          <a>검증가능한 크리덴셜</a>의 작성자는 일부 콘텐츠 무결성 보호
          메커니즘에 잠긴 <code>credentialSchema</code>를 사용하여 어휘의 정적
          버전을 포함할 수 있다. <code>credentialSchema</code> <a>속성</a>은
          또한 <a>크리덴셜</a>에 대해 구문 검사를 수행하고 JSON 스키마
          \[\[JSON-SCHEMA-2018\]\] 유효성 검사와 같은 <a>검증</a> 메커니즘을
          사용할 수 있게 한다.
        </p>
        <pre
          class="example nohighlight"
          title="Usage of the credentialSchema property to perform JSON schema validation"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchemaValidator2018"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 예에서 <a>발급자</a>는 <code>credentialSchema</code>를
          지정하는데, 이는 <a>검증자</a>가 <a>검증가능한 크리덴셜</a>의 형식이
          올바른지 여부를 결정하는 데 사용할 수 있는 \[\[?JSON-SCHEMA-2018\]\]
          파일을 가리킨다.
        </p>

        <p class="note">
          JSON 스키마 \[\[JSON-SCHEMA-2018\]\] 또는 기타 선택적
          <a>검증</a> 메커니즘에 대한 연결에 대한 정보는 검증가능한 크리덴셜
          구현 지침 \[\[VC-IMP-GUIDE\]\] 문서를 참조하라.
        </p>

        <p>
          데이터 스키마는 또한 영지식 증명을 수행하는 데 사용되는 것과 같은 다른
          이진 형식에 대한 매핑을 지정하는 데 사용될 수 있다. 영지식 증명과 함께
          <code>credentialSchema</code> <a>속성</a>을 사용하는 방법에 대한
          자세한 내용은 섹션 <a href="#zero-knowledge-proofs"></a>를 참조하라.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the credentialSchema property to perform zero-knowledge validation"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree.zkp",
    "type": "ZkpExampleSchema2018"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 예에서 <a>발급자</a>는 입력 데이터를 <a>검증자</a>가
          <a>검증가능한 크리덴셜</a>과 함께 제공된 증명이 유효한지 여부를
          결정하는 데 사용할 수 있는 형식으로 변환할 수 있는 영지식 압축 이진
          데이터 형식을 가리키는 <code>credentialSchema</code>를 지정한다.
        </p>
      </section>

      <section>
        <h3 id="refreshing">갱신</h3>

        <p>
          시스템에서 만료된 <a>검증가능한 크리덴셜</a>의 수동 또는 자동 갱신을
          가능하게 하는 것이 유용하다. 만료된 <a>검증가능한 크리덴셜</a>에 대한
          자세한 내용은 섹션 <a href="#expiration"></a>을 참조하라. 이 규격은
          <a>발급자</a>가 갱신 서비스에 대한 링크를 포함할 수 있도록 하는
          <code>refreshService</code> <a>속성</a>을 정의한다.
        </p>

        <p>
          <a>발급자</a>는 <a>검증자</a> 또는 <a>보유자</a>(또는 둘 다)를 위한
          것인 경우 <a>검증가능한 크리덴셜</a> 내부에, <a>보유자</a>만을 위한
          것인 경우 <a>검증가능한 프레젠테이션</a> 내부에 갱신 서비스를 요소로
          포함할 수 있다. 후자의 경우 이를 통해 <a>보유자</a>는 <a>검증자</a>와
          공유할 <a>검증가능한 프레젠테이션</a>을 생성하기 전에
          <a>검증가능한 크리덴셜</a>을 갱신할 수 있다. 전자의 경우
          <a>검증가능한 크리덴셜</a> 내부에 갱신 서비스를 포함하면
          <a>보유자</a> 또는 <a>검증자</a>가 향후 <a>크리덴셜</a>을 업데이트할
          수 있다.
        </p>

        <p>
          갱신 서비스는 <a>크리덴셜</a>이 만료되었거나 <a>발급자</a>가
          <a>크리덴셜</a> 상태 정보를 게시하지 않는 경우에만 사용될 것으로
          예상된다. <a>발급자</a>는 공개 정보를 포함하지 않거나 갱신 서비스가
          어떤 식으로든 보호되지 않는 <a>검증가능한 크리덴셜</a>에
          <code>refreshService</code> <a>속성</a>을 넣지 않는 것이 좋다.
        </p>

        <p class="note">
          <a>검증자</a>가 사용할 수 있도록 <a>검증가능한 크리덴셜</a>에
          <code>refreshService</code> <a>속성</a>을 배치하면 <a>보유자</a>의
          제어 및 동의를 제거하고 <a>검증가능한 크리덴셜</a>을 <a>보유자</a>를
          무시하고 <a>검증자</a>에게 직접 발급할 수 있게 한다.
        </p>

        <dl>
          <dt><var>refreshService</var></dt>
          <dd>
            <code>refreshService</code> <a>속성</a>의 값은 반드시 수신자의
            소프트웨어에 수신자가 <a>검증가능한 크리덴셜</a>을 갱신할 수 있을
            만큼 충분한 정보를 제공하는 하나 이상의 갱신 서비스여야 한다. 각
            <code>refreshService</code> 값은 반드시 해당 <code>type</code>(예:
            <code>ManualRefreshService2018</code>)과 서비스의 <a>URI</a>인
            <code>id</code>를 지정해야 한다. 각 갱신 서비스의 정확한 내용은 특정
            <code>refreshService</code> <a>유형</a> 정의에 의해 결정된다.
          </dd>
        </dl>
        <pre
          class="example nohighlight"
          title="Usage of the refreshService property by an issuer"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "id": "https://example.edu/refresh/3732"
    "type": "ManualRefreshService2018",
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 예에서 <a>발급자</a>는 <a>보유자</a> 또는 <a>검증자</a>를
          <code>https://example.edu/refresh/3732</code>로 안내하여 사용할 수
          있는 수동 <code>refreshService</code>를 지정한다.
        </p>
      </section>

      <section>
        <h3 id="terms-of-use">사용 약관</h3>

        <p>
          사용 약관은 <a>발급자</a> 또는 <a>보유자</a>가
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>이
          발급된 조건을 전달하는 데 사용될 수 있다. <a>발급자</a>는
          <a>검증가능한 크리덴셜</a> 내부에 자신의 사용 약관을 배치한다.
          <a>보유자</a>는 <a>검증가능한 프레젠테이션</a> 내부에 자신의 사용
          약관을 배치한다. 이 규격은 사용 약관 정보를 표현하기 위한
          <code>termsOfUse</code> <a>속성</a>을 정의한다.
        </p>

        <p>
          <code>termsOfUse</code> <a>속성</a>의 값은 <a>검증자</a>가
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>을
          수락하기 위해 수행해야 하는 작업(<em>의무</em>), 수행해서는 안 되는
          작업(<em>금지</em>) 또는 수행할 수 있는 작업(<em>허가</em>)을
          알려준다.
        </p>

        <p class="note">
          <a>보유자</a>가 아닌 <a>주체</a>가 자신의 <a>검증가능한 크리덴셜</a>에
          사용 약관을 배치하는 방법을 결정하려면 추가 연구가 필요하다. 한 가지
          방법은 <a>주체</a>가 <a>발급자</a>에게 발급된
          <a>검증가능한 크리덴셜</a> 내부에 사용 약관을 배치하도록 요청하는
          것이다. 다른 방법은 <a>주체</a>가 <a>검증가능한 크리덴셜</a>을
          <a>보유자</a>에게 위임하고 위임된 <a>검증가능한 크리덴셜</a>에 사용
          약관 제한을 배치하는 것이다.
        </p>

        <dl>
          <dt><var>termsOfUse</var></dt>
          <dd>
            <code>termsOfUse</code> <a>속성</a>의 값은 반드시 제작자가
            <a>크리덴셜</a> 또는 <a>프레젠테이션</a>을 발급한 하나 이상의 사용
            약관 정책을 지정해야 한다. 수신자(<a>보유자</a> 또는
            <a>검증자</a>)가 명시된 사용 약관을 준수할 의사가 없는 경우, 자신의
            책임하에 그렇게 해야 하며 명시된 사용 약관을 위반하면 법적 책임을 질
            수 있다. 각 <code>termsOfUse</code> 값은 반드시 그 <a>유형</a>, 예를
            들어 <code>IssuerPolicy</code>를 지정해야 하며 인스턴스
            <code>id</code>를 지정할 수 있다. 각 사용 약관의 정확한 내용은 특정
            <code>termsOfUse</code> <a>유형</a> 정의에 의해 결정된다.
          </dd>
        </dl>

        <pre
          class="example nohighlight"
          title="Usage of the termsOfUse property by an issuer"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"termsOfUse": [{
    "type": "IssuerPolicy",
    "id": "http://example.com/policies/credential/4",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "https://example.edu/issuers/14",
      "assignee": "AllVerifiers",
      "target": "http://example.edu/credentials/3732",
      "action": ["Archival"]
    }]
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          In the example above, the <a>issuer</a> (the <code>assigner</code>) is
          prohibiting <a>verifiers</a> (the <code>assignee</code>) from storing
          the data in an archive.
        </p>

        <pre
          class="example nohighlight"
          title="Usage of the termsOfUse property by a holder"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1",
    {
        "@protected": true,
        "VerifiablePresentationTermsOfUseExtension": {
          "@id": "https://www.w3.org/2018/credentials/examples#VerifiablePresentationExtension",
          "@context": {
            "@protected": true,
            "termsOfUse": {
              "@id": "https://www.w3.org/2018/credentials#termsOfUse",
              "@type": "@id"
            }
          }
        }
    }
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation", "VerifiablePresentationTermsOfUseExtension"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "id": "http://example.edu/credentials/3732",
    "type": ["VerifiableCredential", "UniversityDegreeCredential"],
    "issuer": "https://example.edu/issuers/14",
    "issuanceDate": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
    },
    "proof": { <span class="comment">...</span> }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://example.edu/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }]</span>,
  "proof": [ ... ]
}
        </pre>

        <p class="note">
          경고: <code>termsOfUse</code> 속성은
          <code>VerifiablePresentation</code> 범위 컨텍스트 내에서 잘못
          정의되었다. 이는 버전 1 컨텍스트의 버그이며 버전 2 컨텍스트에서 수정될
          예정이다. 그 동안 이 기능을 사용하고자 하는 구현자는
          <code>termsOfUse</code> 속성을 정의하는 추가 용어로
          <a>검증가능한 프레젠테이션</a>의 컨텍스트를 확장해야 한다. 그런 다음
          이 용어를 <a>검증가능한 프레젠테이션</a> 유형 속성과 함께 사용하여
          JSON-LD 프로세서에서 의미적으로 인식될 수 있다.
        </p>

        <p>
          위의 예시에서, <a>주체</a>이기도 한
          <a>보유자</a>(<code>assigner</code>)는
          <a>검증자</a>(<code>assignee</code>,
          <code>https://wineonline.example.org</code>)가 제공된 정보를 사용하여
          제3자 서비스를 통해 <a>보유자</a> 또는 <a>주체</a>를 연관시키는 것을
          금지하는 사용 약관을 표현했다. 만약 <a>검증자</a>가 제3자 서비스를
          사용하여 연관시킨다면, 그들은 <a>보유자</a>가 <a>프레젠테이션</a>을
          생성한 조건을 위반하게 될 것이다.
        </p>

        <p>
          이 기능은 또한 정부 발행 <a>검증가능한 크리덴셜</a>에서 민감한
          데이터의 예기치 않은 사용으로부터 시민을 보호하기 위해 디지털 지갑에
          유사한 정부 기관으로 사용을 제한하도록 지시하는 데 사용될 것으로
          예상된다. 유사하게, 민간 산업에서 발행한 일부
          <a>검증가능한 크리덴셜</a>은 조직 내 부서 또는 업무 시간 내로 사용을
          제한할 것으로 예상된다. 구현자는 검증가능한 크리덴셜 구현 지침
          [[?VC-IMP-GUIDE]] 문서의 해당 섹션에서 이 빠르게 진화하는 기능에 대해
          자세히 읽어볼 것을 권장한다.
        </p>
      </section>

      <section>
        <h3 id="evidence">증거</h3>

        <p>
          <a>발급자</a>는 <a>검증가능한 크리덴셜</a>에 추가 지원 정보를
          <a>검증자</a>에게 제공하기 위해 증거를 포함할 수 있다. 이는
          <a>검증자</a>가 <a>검증가능한 크리덴셜</a>의 클레임을 신뢰하는 확신을
          설정하는 데 사용될 수 있다.
        </p>

        <p>
          예를 들어, <a>발급자</a>는 <a>크리덴셜</a>을 발급하기 전에
          <a>주체</a>가 제공한 물리적 문서를 확인하거나 일련의 배경 조사를
          수행할 수 있다. 특정 시나리오에서 이 정보는 <a>검증자</a>가 특정
          <a>크리덴셜</a>에 의존하는 것과 관련된 위험을 결정할 때 유용하다.
        </p>

        <p>
          이 규격은 증거 정보를 표현하기 위한 <code>evidence</code>
          <a>속성</a>을 정의한다.
        </p>

        <dl>
          <dt><var>evidence</var></dt>
          <dd>
            <code>evidence</code> <a>속성</a>의 값은 반드시 <a>검증자</a>가
            <a>발급자</a>가 수집한 증거가 <a>크리덴셜</a>을 신뢰하기 위한 신뢰
            요구사항을 충족하는지 여부를 결정하기에 충분한 정보를 제공하는 하나
            이상의 증거 체계여야 한다. 각 증거 체계는 <a>유형</a>으로 식별된다.
            <code>id</code> <a>속성</a>은 선택 사항이지만, 존재하는 경우 이 증거
            인스턴스에 대한 더 많은 정보를 찾을 수 있는 곳을 가리키는 URL을
            포함해야 한다(SHOULD). 각 증거 체계의 정확한 내용은 특정
            <code>evidence</code> <a>유형</a> 정의에 의해 결정된다.
          </dd>
        </dl>

        <p class="note">
          <a>크리덴셜</a> 및 비크리덴셜 데이터에 대한 첨부 파일 및 참조가 규격에
          의해 어떻게 지원될 수 있는지에 대한 정보는 검증가능한 크리덴셜 구현
          지침 [[VC-IMP-GUIDE]] 문서를 참조하시오.
        </p>

        <pre class="example nohighlight" title="Usage of the evidence property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": [{
    "id": "https://example.edu/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://example.edu/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical",
    "licenseNumber": "123AB4567"
  }]</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p class="note">
          이 <code>evidence</code> 예시에서, <a>발급자</a>는 명시된 면허 번호를
          가진 운전면허증의 실물 사본과 <a>크리덴셜</a>의 <a>주체</a>를
          물리적으로 일치시켰다고 주장하고 있다. 이 운전면허증은 발급 과정에서
          "Example University"가 크리덴셜 발급 전에 주체를 어떻게
          검증했는지(물리적 검증) 확인하는 데 사용되었다.
        </p>

        <p class="note">
          <code>evidence</code> <a>속성</a>은 <code>proof</code> <a>속성</a>과는
          다르고 상호 보완적인 정보를 제공한다. <code>evidence</code>
          <a>속성</a>은 <a>검증가능한 크리덴셜</a>의 무결성과 관련된 증거 자료와
          같은 지원 정보를 표현하는 데 사용된다. 반면에 <code>proof</code>
          <a>속성</a>은 <a>발급자</a>의 진위성 및 <a>검증가능한 크리덴셜</a>의
          무결성과 관련된 기계 검증 가능한 수학적 증명을 표현하는 데 사용된다.
          <code>proof</code> <a>속성</a>에 대한 자세한 내용은
          <a href="#proofs-signatures"></a> 섹션을 참조하시오.
        </p>
      </section>

      <section>
        <h3 id="zero-knowledge-proofs">영지식 증명</h3>

        <p>
          영지식 증명은 실제 값을 공개하지 않고 한 엔티티가 다른 엔티티에게 특정
          값을 알고 있음을 증명할 수 있는 암호학적 방법이다. 실제 예로는
          신원이나 학위에 포함된 기타 개인 식별 정보를 공개하지 않고 공인된
          대학에서 학위를 취득했음을 증명하는 것이 있다.
        </p>

        <p>
          영지식 증명 메커니즘에 의해 도입된 주요 기능은 <a>보유자</a>가 다음을
          수행할 수 있다는 점이다:
        </p>

        <ul>
          <li>
            <a>검증가능한 크리덴셜</a> 또는 <a>주체</a> 식별자를
            <a>검증자</a>에게 공개하지 않고 여러 <a>발급자</a>의 여러
            <a>검증가능한 크리덴셜</a>을 단일 <a>검증가능한 프레젠테이션</a>으로
            결합한다. 이렇게 하면 <a>검증자</a>가 발급된
            <a>검증가능한 크리덴셜</a>과 관련하여 발급자 중 누구와도 공모하기가
            더 어려워진다.
          </li>
          <li>
            여러 개의 원자적 <a>검증가능한 크리덴셜</a>을 발급할 필요 없이
            <a>검증가능한 크리덴셜</a>의 <a>클레임</a>을 <a>검증자</a>에게
            선택적으로 공개한다. 이를 통해 <a>보유자</a>는 <a>검증자</a>에게
            필요한 정보만 정확히 제공할 수 있다.
          </li>
          <li>
            <a>검증가능한 크리덴셜</a> 발급 후 <a>발급자</a>를 개입시킬 필요
            없이 <a>발급자</a>의 데이터 스키마 대신 <a>검증자</a>의 데이터
            스키마에 따라 형식화된 파생 <a>검증가능한 크리덴셜</a>을 생성한다.
            이는 <a>보유자</a>가 발급된 <a>검증가능한 크리덴셜</a>을 사용하는 데
            많은 유연성을 제공한다.
          </li>
        </ul>

        <p>
          이 규격은 영지식 증명 메커니즘의 사용과 함께 선택적 공개를 지원하는
          데이터 모델을 설명한다. 아래 예시는 데이터 모델을 사용하여 영지식
          <a>검증가능한 크리덴셜</a>을 발급, 제시 및 검증하는 방법을 보여준다.
        </p>

        <p>
          <a>보유자</a>가 영지식 <a>검증가능한 프레젠테이션</a>을 사용하기
          위해서는 <a>발급자</a>가 <a>보유자</a>가 원래 발급된
          <a>검증가능한 크리덴셜</a>에서 증명을 유도할 수 있는 방식으로
          <a>검증가능한 크리덴셜</a>을 발급해야 한다. 이를 통해 <a>보유자</a>는
          프라이버시 보호 방식으로 정보를 <a>검증자</a>에게 제시할 수 있다. 이는
          <a>보유자</a>가 서명된 값을 공개하지 않거나 선택된 특정 값만
          공개하면서 <a>발급자</a> 서명의 유효성을 증명할 수 있음을 의미한다.
          표준 관행은 서명 자체를 공개하지 않고 서명에 대한 지식을 증명하는
          것이다. <a>검증가능한 크리덴셜</a>을 영지식 증명 시스템에서 사용할
          때는 두 가지 요구사항이 있다.
        </p>

        <ul>
          <li>
            <a>검증가능한 크리덴셜</a>은 반드시 <code>proof</code> <a>속성</a>을
            사용하여 증명을 포함해야 한다. 이를 통해 <a>보유자</a>는
            <a>보유자</a>가 공개하려는 정보만 공개하는
            <a>검증가능한 프레젠테이션</a>을 도출할 수 있다.
          </li>
          <li>
            <a>크리덴셜</a> 정의가 사용되는 경우, <a>크리덴셜</a> 정의는 반드시
            <code>credentialSchema</code> <a>속성</a>에 정의되어야 한다. 이를
            통해 모든 당사자가 영지식으로 다양한 암호화 연산을 수행하는 데
            사용할 수 있다.
          </li>
        </ul>

        <p>
          다음 예시는 <a>검증가능한 크리덴셜</a>을 영지식으로 사용하는 한 가지
          방법을 보여준다. 이는 Camenisch-Lysyanskaya 서명 [[?CL-SIGNATURES]]을
          사용하는데, 이를 통해 <a>검증가능한 크리덴셜</a> 값의 선택적 공개를
          통해 <a>보유자</a>와 <a>주체</a>의 프라이버시를 지원하는 방식으로
          <a>검증가능한 크리덴셜</a>을 제시할 수 있다. 속성을 선택적으로
          공개하기 위해 영지식 증명에 의존하는 다른 일부 암호화 시스템은
          [[?LDP-REGISTRY]]에서도 찾을 수 있다.
        </p>

        <pre
          class="example nohighlight"
          title="A verifiable credential that supports CL Signatures"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"credentialSchema": {
    "id": "did:example:cdf:35LB7w9ueWbagPL94T9bMLtyXDj9pX5o",
    "type": "did:example:schema:22KpkXgecryx9k7N6XN1QoN3gXwBkSU8SfyyYQG"
  }</span>,
  "issuer": "did:example:Wz4eUg7SetGfaUVCn8U9d62oDYrUJLuUtcy619",
  "credentialSubject": {
    "givenName": "Jane",
    "familyName": "Doe",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts",
      "college": "College of Engineering"
    }
  },
  <span class="highlight">"proof": {
    "type": "CLSignature2019",
    "issuerData": "5NQ4TgzNfSQxoLzf2d5AV3JNiCdMaTgm...BXiX5UggB381QU7ZCgqWivUmy4D",
    "attributes": "pPYmqDvwwWBDPNykXVrBtKdsJDeZUGFA...tTERiLqsZ5oxCoCSodPQaggkDJy",
    "signature": "8eGWSiTiWtEA8WnBwX4T259STpxpRKuk...kpFnikqqSP3GMW7mVxC4chxFhVs",
    "signatureCorrectnessProof": "SNQbW3u1QV5q89qhxA1xyVqFa6jCrKwv...dsRypyuGGK3RhhBUvH1tPEL8orH"
  }</span>
}
        </pre>
        <p>
          위의 예시는 <code>credentialSchema</code> <a>속성</a>과
          Camenisch-Lysyanskaya 영지식 증명 시스템에서 사용 가능한 특정 증명을
          사용하여 <a>검증가능한 크리덴셜</a> 정의를 제공한다.
        </p>

        <p>
          다음 예시는 위의 <a>검증가능한 크리덴셜</a>을 활용하여 프라이버시 보존
          증명이 포함된 새로운 파생 <a>검증가능한 크리덴셜</a>을 생성한다. 그런
          다음 파생 <a>검증가능한 크리덴셜</a>은
          <a>검증가능한 프레젠테이션</a>에 배치되어 <a>보유자</a>가 의도한
          <a>클레임</a>과 추가 크리덴셜 메타데이터만 공개한다. 이를 위해서는
          다음 요구사항이 모두 충족되어야 한다:
        </p>

        <ul>
          <li>
            <a>검증가능한 프레젠테이션</a> 내의 각 파생
            <a>검증가능한 크리덴셜</a>은 반드시 크리덴셜 내에 직접 포함하거나
            필요한 정보를 참조하여 <a>검증가능한 크리덴셜</a>을 검증하는 데
            필요한 모든 정보를 포함해야 한다.
          </li>
          <li>
            <a>검증가능한 프레젠테이션</a>은 반드시 <a>검증자</a>가 여러
            <a>검증가능한 프레젠테이션</a>에 걸쳐 <a>보유자</a>를 연관시킬 수
            있는 정보를 누출해서는 안 된다.
          </li>
          <li>
            <a>검증가능한 프레젠테이션</a>은 <a>보유자</a>가 공유하려고 의도하지
            않은 개인 식별 정보를 유출하지 않으면서
            <a>검증가능한 프레젠테이션</a>의 모든 파생
            <a>검증가능한 크리덴셜</a>이 동일한 <a>보유자</a>에게 발급되었는지
            확인할 수 있도록 <code>proof</code> <a>속성</a>을 포함하는 것이
            좋다(SHOULD).
          </li>
        </ul>

        <pre
          class="example nohighlight"
          title="A verifiable presentation that supports CL Signatures"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": "VerifiablePresentation",
  "verifiableCredential": [
    {
      "@context": [
        "https://www.w3.org/2018/credentials/v1",
        "https://www.w3.org/2018/credentials/examples/v1"
      ],
      "type": ["VerifiableCredential", "UniversityDegreeCredential"],
      <span class="highlight">"credentialSchema": {
        "id": "did:example:cdf:35LB7w9ueWbagPL94T9bMLtyXDj9pX5o",
        "type": "did:example:schema:22KpkXgecryx9k7N6XN1QoN3gXwBkSU8SfyyYQG"
      }</span>,
      "issuer": "did:example:Wz4eUg7SetGfaUVCn8U9d62oDYrUJLuUtcy619",
      "credentialSubject": {
        "degreeType": "BachelorDegree",
        "degreeSchool": "College of Engineering"
      },
      <span class="highlight">"proof": {
        "type": "AnonCredDerivedCredentialv1",
        "primaryProof": "cg7wLNSi48K5qNyAVMwdYqVHSMv1Ur8i...Fg2ZvWF6zGvcSAsym2sgSk737",
        "nonRevocationProof": "mu6fg24MfJPU1HvSXsf3ybzKARib4WxG...RSce53M6UwQCxYshCuS3d2h"
      }</span>
  }],
  <span class="highlight">"proof": {
    "type": "AnonCredPresentationProofv1",
    "proofValue": "DgYdYMUYHURJLD7xdnWRinqWCEY5u5fK...j915Lt3hMzLHoPiPQ9sSVfRrs1D"
  }</span>
}
        </pre>
        <figure>
          <img
            style="margin: auto; display: block; width: 75%"
            src="diagrams/zkp-cred-pres.svg"
            alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2."
          />
          <figcaption style="text-align: center">
            A visual example of the relationship between credentials and derived
            credentials in a ZKP <a>presentation</a>.
          </figcaption>
        </figure>

        <p class="note">
          <a>크리덴셜</a> 정의 및 증명의 형식과 관련된 중요한 세부 사항은 이
          문서의 범위를 벗어나므로 의도적으로 생략되었다. 이 섹션의 목적은
          <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>을 확장하여
          영지식 증명 시스템을 지원하려는 구현자를 안내하는 것이다.
        </p>
      </section>

      <section>
        <h3>분쟁</h3>

        <p>
          <a>발급자</a>가 발급한 <a>크리덴셜</a>에 이의를 제기하려는
          <a>엔티티</a>의 경우 고려해야 할 두 가지 사례가 있다:
        </p>

        <ul>
          <li>
            <a>주체</a>가 <a>발급자</a>가 주장한 클레임에 이의를 제기한다. 예를
            들어, <code>address</code> <a>속성</a>이 잘못되었거나 만료되었다.
          </li>
          <li>
            <a>엔티티</a>가 <a>발급자</a>가 다른 <a>주체</a>에 대해 주장한
            잠재적으로 거짓된 클레임에 이의를 제기한다. 예를 들어, 사칭자가
            <a>엔티티</a>의 사회보장번호를 주장한다.
          </li>
        </ul>

        <p>
          <code>DisputeCredential</code>을 발급하는 메커니즘은 일반
          <a>크리덴셜</a>과 동일하지만, <code>DisputeCredential</code>
          <a>속성</a>의 <code>credentialSubject</code> 식별자는 분쟁 중인
          <a>크리덴셜</a>의 식별자이다.
        </p>

        <p>
          예를 들어, 식별자가 <code>https://example.org/credentials/245</code>인
          <a>크리덴셜</a>에 이의가 제기되는 경우, <a>주체</a>는 아래와 같은
          <a>크리덴셜</a>을 발급하고 분쟁 중인 <a>크리덴셜</a>과 함께
          <a>검증자</a>에게 제시할 수 있다.
        </p>

        <pre
          class="example nohighlight"
          title="A subject disputes a credential"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.com/credentials/123",
  "type": ["VerifiableCredential", "DisputeCredential"],
  <span class="highlight">"credentialSubject": {
    "id": "http://example.com/credentials/245",
    "currentStatus": "Disputed",
    "statusReason": {
      "value": "Address is out of date.",
      "lang": "en"
    },
  }</span>,
  "issuer": "https://example.com/people#me",
  "issuanceDate": "2017-12-05T14:27:42Z",
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 <a>검증가능한 크리덴셜</a>에서 <a>발급자</a>는 분쟁 중인
          <a>검증가능한 크리덴셜</a>의 주소가 잘못되었다고 주장하고 있다.
        </p>

        <p class="note">
          <a>크리덴셜</a>에 식별자가 없는 경우, 콘텐츠 기반 식별자를 사용하여
          분쟁 중인 <a>크리덴셜</a>을 식별할 수 있다. 마찬가지로, 콘텐츠 기반
          식별자를 사용하여 개별 클레임을 고유하게 식별할 수 있다.
        </p>

        <p class="note">
          이 연구 분야는 빠르게 발전하고 있으며, 다른 <a>크리덴셜</a>의 진실성에
          이의를 제기하는 <a>크리덴셜</a>을 게시하는 데 관심이 있는 개발자는
          검증가능한 크리덴셜 구현 지침 \[\[VC-IMP-GUIDE\]\] 문서의 분쟁 관련
          섹션을 읽어보는 것이 좋다.
        </p>
      </section>

      <section class="informative">
        <h3>권한 부여</h3>

        <p>
          <a>검증가능한 크리덴셜</a>은 <a>주체</a>를 안정적으로 식별하기 위한
          수단으로 의도되었다. 역할 기반 접근 제어(RBAC)와 속성 기반 접근
          제어(ABAC)가 <a>주체</a>에게 리소스에 대한 접근 권한을 부여하는
          수단으로 이러한 식별에 의존한다는 점은 인정되지만, 이 규격은 RBAC 또는
          ABAC에 대한 완전한 솔루션을 제공하지 않는다. 권한 부여는 수반되는 권한
          부여 프레임워크 없이는 이 규격에 적합한 사용법이 아니다.
        </p>

        <p>
          작업 그룹은 이 규격 작성 과정에서 권한 부여 사용 사례를 고려했으며, 이
          규격 위에 구축된 아키텍처 계층으로 해당 작업을 추진하고 있다.
        </p>
      </section>
    </section>

    <section>
      <h2 id="syntaxes">구문</h2>

      <p>
        <a href="#core-data-model"></a>, <a href="#basic-concepts"></a>,
        <a href="#advanced-concepts"></a> 섹션에 설명된 데이터 모델은
        <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의 표준
        구조적 표현이다. 모든 직렬화는 특정 형식으로 해당 데이터 모델을 표현한
        것이다. 이 섹션에서는 데이터 모델이 JSON-LD와 일반 JSON에서 어떻게
        실현되는지 명시한다. 구문적 매핑은 이 두 가지 구문에 대해서만
        제공되지만, 애플리케이션과 서비스는 데이터 모델을 표현할 수 있는 다른
        데이터 표현 구문(예: XML, YAML 또는 CBOR)을 사용할 수 있다.
        <a>검증</a> 및 <a>유효성 검사</a> 요구사항이 데이터 모델 측면에서
        정의되므로, 모든 직렬화 구문은 처리, <a>유효성 검사</a> 또는 비교를 위해
        데이터 모델로 결정적으로 변환되어야 한다. 이 규격은 특정 직렬화 형식에
        대한 지원을 요구하지 않는다.
      </p>

      <p>
        이 규격에서 속성 값의 예상 아리티(arity)와 그러한 값을 포함하는 결과
        데이터 유형은 속성에 따라 달라질 수 있다. 존재하는 경우, 다음 속성은
        단일 값으로 표현된다:
      </p>

      <ul>
        <li><code>id</code> <a>속성</a></li>
        <li><code>issuer</code> <a>속성</a></li>
        <li><code>issuanceDate</code> <a>속성</a></li>
        <li><code>expirationDate</code> <a>속성</a>.</li>
      </ul>

      <p>존재하는 경우, 다른 모든 속성은 단일 값 또는 값의 배열로 표현된다.</p>

      <section>
        <h3>JSON</h3>

        <p>
          <a href="#core-data-model"></a> 섹션에 설명된 데이터 모델은 속성 값을
          다음과 같이 JSON 유형에 매핑하여 Javascript Object Notation (JSON)
          \[\[!RFC8259\]\]로 인코딩할 수 있다:
        </p>

        <ul>
          <li>
            IEEE754로 표현할 수 있는 숫자 값은 Number 유형으로 표현되어야
            한다(SHOULD).
          </li>
          <li>부울 값은 Boolean 유형으로 표현되어야 한다(SHOULD).</li>
          <li>시퀀스 값은 Array 유형으로 표현되어야 한다(SHOULD).</li>
          <li>순서가 없는 값 집합은 Array 유형으로 표현되어야 한다(SHOULD).</li>
          <li><a>속성</a> 집합은 Object 유형으로 표현되어야 한다(SHOULD).</li>
          <li>빈 값은 null 값으로 표현되어야 한다(SHOULD).</li>
          <li>기타 값은 반드시 String 유형으로 표현되어야 한다(MUST).</li>
        </ul>

        <p class="note">
          여기에 나열된 변환에는 잠재적으로 호환되지 않는 해석이 있으므로,
          결정적 변환을 제공하려면 JSON 형식에 대한 추가 프로파일링이 필요하다.
        </p>
      </section>

      <section>
        <h3>JSON-LD</h3>

        <p>
          [[!JSON-LD]]는
          <a href="http://www.w3.org/TR/ld-glossary/#linked-data"
            >링크드 데이터</a
          >를 직렬화하는 데 사용되는 JSON 기반 형식이다. 이 구문은 이미 JSON을
          사용하고 있는 배포된 시스템에 쉽게 통합되도록 설계되었으며, JSON에서
          [[!JSON-LD]]로 원활한 업그레이드 경로를 제공한다. 이는 주로 웹 기반
          프로그래밍 환경에서 링크드 데이터를 사용하고, 상호운용 가능한 웹
          서비스를 구축하며, JSON 기반 스토리지 엔진에 링크드 데이터를 저장하는
          방법으로 사용하기 위한 것이다.
        </p>

        <p>
          [[!JSON-LD]]는 이 규격에 설명된 데이터 모델을 확장할 때 유용하다.
          데이터 모델의 인스턴스는 <code>@context</code> <a>속성</a>이 추가된
          것을 제외하고는 JSON(섹션 <a href="#json"></a>)으로 인코딩되는 방식과
          동일한 방식으로 [[!JSON-LD]]로 인코딩된다.
          <a href="https://www.w3.org/TR/json-ld/#the-context"
            >JSON-LD 컨텍스트</a
          >는 [[!JSON-LD]] 규격에 자세히 설명되어 있으며, 그 사용법은
          <a href="#extensibility"></a> 섹션에서 자세히 설명된다.
        </p>

        <p>
          여러 컨텍스트를 사용하거나 결합하여 관용적인 JSON으로
          <a>검증가능한 크리덴셜</a>에 대한 임의의 정보를 표현할 수 있다.
          <code>https://www.w3.org/2018/credentials/v1</code>에서 사용할 수 있는
          <a href="https://www.w3.org/TR/json-ld/#the-context"
            >JSON-LD 컨텍스트</a
          >는 절대 업데이트되지 않는 정적 문서이므로 클라이언트 측에서
          다운로드하여 캐시할 수 있다. 검증가능한 크리덴셜 데이터 모델과 관련된
          어휘 문서는 <code>https://www.w3.org/2018/credentials</code>에서
          확인할 수 있다.
        </p>

        <section>
          <h3>구문적 편의성</h3>

          <p>
            일반적으로 이 문서에 설명된 데이터 모델과 구문은 개발자가 예제를
            복사하여 붙여넣기만 하면 <a>검증가능한 크리덴셜</a>을 소프트웨어
            시스템에 통합할 수 있도록 설계되었다. 이러한 접근 방식의 설계 목표는
            이기종 소프트웨어 시스템 간의 글로벌 상호운용성을 보장하면서도 진입
            장벽을 낮추는 것이다. 이 섹션에서는 대부분의 개발자가 눈치채지
            못하겠지만 구현자에게는 관심사가 될 이러한 접근 방식 중 일부에 대해
            설명한다. [[!JSON-LD]]에서 제공하는 가장 주목할 만한 구문적 편의성은
            다음과 같다:
          </p>

          <ul>
            <li>
              <code>@id</code>와 <code>@type</code> 키워드는 각각
              <code>id</code>와 <code>type</code>으로 별칭되어, 개발자가 이
              규격을 관용적인 JSON으로 사용할 수 있게 한다.
            </li>
            <li>
              정수, 날짜, 측정 단위, URL과 같은 데이터 유형은 자동으로
              유형화되어 이를 필요로 하는 사용 사례에 더 강력한 유형 보장을
              제공한다.
            </li>
            <li>
              <code>verifiableCredential</code>과 <code>proof</code>
              <a>속성</a>은 <em>그래프 컨테이너</em>로 취급된다. 즉, 서로 다른
              엔티티가 주장하는 데이터 집합을 분리하는 데 사용되는 메커니즘이다.
              예를 들어, 이는 각 <a>발급자</a>가 제공한 데이터 그래프와
              <a>검증가능한 크리덴셜</a>을 제시하는 <a>보유자</a>가 제공한
              데이터 그래프 간의 적절한 암호화 분리를 보장하여 각 그래프의 정보
              출처가 보존되도록 한다.
            </li>
            <li>
              [[!JSON-LD]] 1.1의 <code>@protected</code> 속성 기능은 이 규격에서
              정의한 용어를 재정의할 수 없도록 하는 데 사용된다. 이는
              <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의
              맨 위에 동일한 <code>@context</code> 선언이 이루어지는 한,
              [[!JSON-LD]] 프로세서를 사용하는지 여부에 관계없이 데이터 모델
              사용자가 이해하는 모든 용어에 대해 상호운용성이 보장됨을 의미한다.
            </li>
          </ul>
        </section>
      </section>

      <section>
        <h2>증명 형식</h2>

        <p>
          이 규격에 설명된 데이터 모델은 증명 형식에 구애받지 않도록 설계되었다.
          이 규격은 규범적으로 특정 디지털 증명이나 서명 형식을 요구하지 않는다.
          데이터 모델은 <a>검증가능한 크리덴셜</a> 또는
          <a>검증가능한 프레젠테이션</a>의 표준 표현이지만, 이에 대한 증명
          메커니즘은 종종 당사자 간 문서 전송에 사용되는 구문과 연결된다. 따라서
          각 증명 메커니즘은 증명의 유효성 검사가 전송된 문서의 상태, 변환된
          데이터 모델 또는 다른 형식에 대해 계산되는지 여부를 지정해야 한다.
          출판 당시, 구현자가 활발히 사용하고 있는 증명 형식이 최소 두 가지
          있었으며, 작업 그룹은 이러한 증명 형식이 무엇이고 어떻게 사용되고
          있는지를 문서화하는 것이 구현자에게 도움이 될 것이라고 생각했다.
          <a>검증가능한 크리덴셜</a> 발행에 활발히 활용되고 있는 현재의 증명
          형식에 대해 자세히 설명하는 섹션은 다음과 같다:
        </p>

        <ul>
          <li><a href="#json-web-token"></a> 섹션, 그리고</li>
          <li><a href="#linked-data-proofs"></a> 섹션.</li>
        </ul>

        <section>
          <h3>JSON Web Token</h3>

          <p>
            JSON Web Token (JWT) [[!RFC7519]]은 두 당사자 간에 전송할
            <a>클레임</a>을 표현하는 널리 사용되는 수단이다. JWT에 대한
            검증가능한 크리덴셜 데이터 모델의 표현을 제공함으로써 기존 시스템과
            라이브러리가 <a href="#ecosystem-overview"></a> 섹션에 설명된
            생태계에 참여할 수 있다. JWT는 JSON 객체로 <a>클레임</a> 집합을
            인코딩하며, 이는 JSON Web Signature (JWS) [[!RFC7515]] 또는 JWE
            [[?RFC7516]]에 포함된다. 이 규격에서 JWE의 사용은 범위에서 제외된다.
          </p>

          <section>
            <h4>검증가능한 크리덴셜 데이터 모델과의 관계</h4>

            <p>
              이 규격은 검증가능한 크리덴셜 데이터 모델을 JWT와 JWS로 인코딩하는
              규칙을 정의한다. 또한 JWT 기반 시스템이 이 규격을 준수할 수 있도록
              특정 JWT 등록 <a>클레임</a> 이름과 특정 JWS 등록 헤더 매개변수
              이름을 사용하는 시기와 방법에 대한 처리 규칙을 정의한다. 이러한
              특정 <a>클레임</a> 이름과 헤더 매개변수가 있는 경우, 중복을 피하기
              위해 표준 <a>검증가능한 크리덴셜</a>과
              <a>검증가능한 프레젠테이션</a>에서 각각의 대응 항목을 생략할 수
              있다(MAY).
            </p>
          </section>

          <section>
            <h4>JSON Web Token 확장</h4>

            <p>
              이 규격은 두 개의 새로운 등록된 <a>클레임</a> 이름을 도입하는데,
              이는 JWT에 대한 명시적인 인코딩 규칙이 존재하지 않는 표준
              <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>의
              일부를 포함한다. 이러한 객체는 다음과 같이 JWT 페이로드에
              포함된다:
            </p>

            <ul>
              <li>
                <code>vc</code>: JWT <a>검증가능한 크리덴셜</a>에 반드시 있어야
                하는 JSON 객체. 이 객체는 이 규격에 따른
                <a>검증가능한 크리덴셜</a>을 포함한다.
              </li>
              <li>
                <code>vp</code>: JWT <a>검증가능한 프레젠테이션</a>에 반드시
                있어야 하는 JSON 객체. 이 객체는 이 규격에 따른
                <a>검증가능한 프레젠테이션</a>을 포함한다.
              </li>
            </ul>
          </section>

          <section>
            <h4>JWT와 JWS 고려사항</h4>

            <section>
              <h5>JWT 인코딩</h5>

              <p>
                <a>검증가능한 크리덴셜</a>을 JWT로 인코딩하려면 이 규격에서
                도입한 특정 <a>속성</a>은 반드시 다음 중 하나여야 한다:
              </p>

              <ul>
                <li>표준 JOSE 헤더 매개변수로 인코딩되거나,</li>
                <li>등록된 JWT <a>클레임</a> 이름으로 인코딩되거나,</li>
                <li>JWS 서명 부분에 포함된다.</li>
              </ul>

              <p>
                명시적인 규칙이 지정되지 않은 경우, <a>속성</a>은 표준
                <a>검증가능한 크리덴셜</a>과 동일한 방식으로 인코딩되며
                <code>vc</code> JWT <a>클레임</a>에 추가된다. 모든 JWT와
                마찬가지로, JWT 구문으로 표현된 <a>검증가능한 크리덴셜</a>의 JWS
                기반 서명은 디코딩 또는 변환 규칙이 적용되기 전에 전선을 통해
                제시된 리터럴 JWT 문자열 값에 대해 계산된다. 다음 단락에서는
                이러한 인코딩 규칙에 대해 설명한다.
              </p>

              <p>
                JWS가 존재하는 경우, 디지털 서명은 <a>검증가능한 크리덴셜</a>의
                <a>발급자</a>를 참조하거나 <a>검증가능한 프레젠테이션</a>의 경우
                <a>검증가능한 크리덴셜</a>의 <a>보유자</a>를 참조한다. JWS는
                JWT의 <a>발급자</a>가 포함된 JWT 페이로드에 서명했음을
                증명하므로 <code>proof</code> <a>속성</a>은 생략될 수 있다.
              </p>

              <p>
                JWS가 존재하지 않는 경우, <code>proof</code> <a>속성</a>이
                반드시 제공되어야 한다. <code>proof</code> <a>속성</a>은
                생성자가 <a>발급자</a>와 다른 경우 또는 작업 증명과 같이 디지털
                서명에 기반하지 않는 증명이 필요한 경우와 같이 보다 복잡한
                증명을 나타내는 데 사용될 수 있다. <a>발급자</a>는 JWS와
                <code>proof</code> <a>속성</a>을 모두 포함할 수 있다. 이전
                버전과의 호환성을 위해 발급자는 디지털 서명에 기반한 증명을
                나타내기 위해 반드시 JWS를 사용해야 한다.
              </p>

              <p>이 규격의 맥락에서 JOSE 헤더에는 다음 규칙이 적용된다:</p>

              <ul>
                <li>
                  디지털 서명의 경우 <code>alg</code>를 반드시 설정해야 한다.
                  선택한 서명 방법에 <code>proof</code> <a>속성</a>만 필요한
                  경우(즉, 해당 방법 내에 알고리즘 선택이 없는 경우),
                  <code>alg</code> 헤더는 반드시 <code>none</code>으로
                  설정되어야 한다.
                </li>
                <li>
                  JWT의 <a>발급자</a>와 연관된 키가 여러 개인 경우
                  <code>kid</code>를 사용할 수 있다(MAY). 키 검색은 이 규격의
                  범위를 벗어난다. 예를 들어, <code>kid</code>는
                  <a>DID 문서</a>의 키를 참조하거나 JWKS 내부의 키 식별자일 수
                  있다.
                </li>
                <li>
                  <code>typ</code>이 있는 경우 반드시 <code>JWT</code>로
                  설정되어야 한다.
                </li>
              </ul>

              <p>
                JWT 프로세서와의 이전 버전 호환성을 위해 다음 등록된 JWT 클레임
                이름은 각각의 표준 <a>검증가능한 크리덴셜</a> 대응 항목 대신
                또는 그에 더하여 반드시 사용되어야 한다:
              </p>

              <ul>
                <li>
                  <code>exp</code>는 반드시 <code>expirationDate</code>
                  <a>속성</a>을 나타내야 하며, UNIX
                  타임스탬프(<code>NumericDate</code>)로 인코딩되어야 한다.
                </li>
                <li>
                  <code>iss</code>는 반드시 검증가능한 크리덴셜의
                  <code>issuer</code> <a>속성</a> 또는 검증가능한 프레젠테이션의
                  <code>holder</code> <a>속성</a>을 나타내야 한다.
                </li>
                <li>
                  <code>nbf</code>는 반드시 <code>issuanceDate</code>를 나타내야
                  하며, UNIX 타임스탬프(<code>NumericDate</code>)로 인코딩되어야
                  한다.
                </li>
                <li>
                  <code>jti</code>는 반드시 <a>검증가능한 크리덴셜</a> 또는
                  <a>검증가능한 프레젠테이션</a>의 <code>id</code> <a>속성</a>을
                  나타내야 한다.
                </li>
                <li>
                  <code>sub</code>는 반드시 <a>검증가능한 크리덴셜</a>
                  <a>주체</a>에 포함된 <code>id</code> <a>속성</a>을 나타내야
                  한다.
                </li>
                <li>
                  <code>aud</code>는 반드시 <a>검증가능한 프레젠테이션</a>의
                  의도된 청중(즉, <a>보유자</a>가
                  <a>검증가능한 프레젠테이션</a>을 수신하고 검증하기 위해 의도한
                  <a>검증자</a>)을 나타내야 한다(즉, 식별해야 한다).
                </li>
              </ul>

              <p>
                여기에 지정되지 않은 다른 JOSE 헤더 매개변수와 JWT 클레임 이름은
                그 사용이 명시적으로 권장되지 않는 한 사용할 수 있다. 추가
                <a>검증가능한 크리덴셜</a> <a>클레임</a>은 반드시 JWT의
                <code>credentialSubject</code> 속성에 추가되어야 한다.
              </p>

              <p class="note">
                여기에 지정되지 않은 JOSE 헤더 매개변수 및/또는 JWT 클레임 이름
                사용에 대한 자세한 내용은 검증가능한 크리덴셜 구현 지침
                [[?VC-IMP-GUIDE]] 문서를 참조하시오.
              </p>

              <p>
                이 버전의 규격은
                <a href="#advanced-concepts">고급 개념</a> 섹션에 설명된
                개념(<code>refreshService</code>, <code>termsOfUse</code>,
                <code>evidence</code> 등)에 대한 JWT 특정 인코딩 규칙을 정의하지
                않는다. 이러한 개념은 변환 없이 그대로 인코딩될 수 있으며
                <code>vc</code> JWT <a>클레임</a>에 추가될 수 있다.
              </p>

              <p class="note">
                구현자는 JWT가 여러 <a>주체</a>를 인코딩할 수 없으므로 둘 이상의
                <a>주체</a>가 있는 <a>검증가능한 크리덴셜</a>을 인코딩할 수
                없다는 점에 주의해야 한다. JWT는 향후 여러 주체를 지원할 수
                있으며, 구현자는 다중 주체 JWT 클레임 이름에 대해
                <a href="https://www.iana.org/assignments/jwt/"
                  >JSON Web Token Claim Registry</a
                >를 참조하거나
                <a
                  href="https://datatracker.ietf.org/doc/draft-yusef-oauth-nested-jwt/"
                  >Nested JSON Web Token</a
                >
                규격을 참조하는 것이 좋다.
              </p>
            </section>

            <section>
              <h5>JWT 디코딩</h5>

              <p>
                JWT를 표준 <a>검증가능한 크리덴셜</a>로 디코딩하려면 다음과 같은
                변환이 반드시 수행되어야 한다:
              </p>

              <ol>
                <li>JSON 객체를 생성한다.</li>
                <li>
                  <code>vc</code> <a>클레임</a>의 내용을 새 JSON 객체에
                  추가한다.
                </li>
                <li>
                  나머지 JWT 특정 헤더와 <a>클레임</a>을 변환하고, 그 결과를 새
                  JSON 객체에 추가한다.
                </li>
              </ol>

              <p>
                JWT 특정 헤더와 <a>클레임</a>을 변환하려면 다음을 반드시
                수행해야 한다:
              </p>

              <ul>
                <li>
                  <code>exp</code>가 있는 경우, UNIX 타임스탬프는 반드시 [<a
                    data-cite="XMLSCHEMA11-2#dateTime"
                    >XMLSCHEMA11-2</a
                  >] <code>date-time</code>으로 변환되어야 하며, 새 JSON 객체의
                  <code>credentialSubject</code>의 <code>expirationDate</code>
                  <a>속성</a> 값을 설정하는 데 반드시 사용되어야 한다.
                </li>
                <li>
                  <code>iss</code>가 있는 경우, 그 값은 반드시 새 검증가능한
                  크리덴셜 JSON 객체의 <code>issuer</code> <a>속성</a> 또는 새
                  검증가능한 프레젠테이션 JSON 객체의 <code>holder</code>
                  <a>속성</a>을 설정하는 데 사용되어야 한다.
                </li>
                <li>
                  <code>nbf</code>가 있는 경우, UNIX 타임스탬프는 반드시 [<a
                    data-cite="XMLSCHEMA11-2#dateTime"
                    >XMLSCHEMA11-2</a
                  >] <code>date-time</code>으로 변환되어야 하며, 새 JSON 객체의
                  <code>issuanceDate</code> <a>속성</a> 값을 설정하는 데 반드시
                  사용되어야 한다.
                </li>
                <li>
                  <code>sub</code>가 있는 경우, 그 값은 반드시 새 JSON 객체의
                  <code>credentialSubject</code>의 <code>id</code>
                  <a>속성</a> 값을 설정하는 데 사용되어야 한다.
                </li>
                <li>
                  <code>jti</code>가 있는 경우, 그 값은 반드시 새 JSON 객체의
                  <code>id</code> <a>속성</a> 값을 설정하는 데 사용되어야 한다.
                </li>
              </ul>

              <pre
                class="example nohighlight"
                title="JWT header of a JWT-based verifiable credential using JWS as a proof (non-normative)"
              >
{
    "alg": "RS256",
    "typ": "JWT",
    "kid": "did:example:abfe13f712120431c276e12ecab#keys-1"
}
            </pre
              >

              <p>
                위의 예시에서 <a>검증가능한 크리덴셜</a>은
                <code>JWS</code> 디지털 서명에 기반한 <code>proof</code>를
                사용하며, 해당 <a>검증</a> 키는 <code>kid</code> 헤더 매개변수를
                사용하여 얻을 수 있다.
              </p>

              <pre
                class="example nohighlight"
                title="JWT payload of a JWT-based verifiable credential using JWS as a proof (non-normative)"
              >
{
  "sub": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "jti": "http://example.edu/credentials/3732",
  "iss": "https://example.com/keys/foo.jwk",
  "nbf": 1541493724,
  "iat": 1541493724,
  "exp": 1573029723,
  "nonce": "660!6345FSer",
  "vc": {
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "type": ["VerifiableCredential", "UniversityDegreeCredential"],
    "credentialSubject": {
      "degree": {
        "type": "BachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }
}
            </pre
              >

              <p>
                위의 예시에서 <code>vc</code>는 JWT 인코딩이
                <code>jti</code> 속성을 고유 식별자로 사용하기 때문에
                <code>id</code> <a>속성</a>을 포함하지 않는다.
                <code>sub</code> 속성은 <code>credentialSubject</code>의
                <code>id</code> <a>속성</a>으로 표현되는 정보를 인코딩한다.
              </p>

              <pre
                class="example nohighlight"
                title="Verifiable credential using JWT compact serialization (non-normative)"
              >
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRpZDpleGFtcGxlOmFiZmUxM2Y3MTIxMjA0
MzFjMjc2ZTEyZWNhYiNrZXlzLTEifQ.<span class="highlight">eyJzdWIiOiJkaWQ6ZXhhbXBsZTplYmZlYjFmNzEyZWJjNmYxY
zI3NmUxMmVjMjEiLCJqdGkiOiJodHRwOi8vZXhhbXBsZS5lZHUvY3JlZGVudGlhbHMvMzczMiIsImlzc
yI6Imh0dHBzOi8vZXhhbXBsZS5jb20va2V5cy9mb28uandrIiwibmJmIjoxNTQxNDkzNzI0LCJpYXQiO
jE1NDE0OTM3MjQsImV4cCI6MTU3MzAyOTcyMywibm9uY2UiOiI2NjAhNjM0NUZTZXIiLCJ2YyI6eyJAY
29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSIsImh0dHBzOi8vd
3d3LnczLm9yZy8yMDE4L2NyZWRlbnRpYWxzL2V4YW1wbGVzL3YxIl0sInR5cGUiOlsiVmVyaWZpYWJsZ
UNyZWRlbnRpYWwiLCJVbml2ZXJzaXR5RGVncmVlQ3JlZGVudGlhbCJdLCJjcmVkZW50aWFsU3ViamVjd
CI6eyJkZWdyZWUiOnsidHlwZSI6IkJhY2hlbG9yRGVncmVlIiwibmFtZSI6IjxzcGFuIGxhbmc9J2ZyL
UNBJz5CYWNjYWxhdXLDqWF0IGVuIG11c2lxdWVzIG51bcOpcmlxdWVzPC9zcGFuPiJ9fX19</span>.KLJo5GAy
BND3LDTn9H7FQokEsUEi8jKwXhGvoN3JtRa51xrNDgXDb0cq1UTYB-rK4Ft9YVmR1NI_ZOF8oGc_7wAp
8PHbF2HaWodQIoOBxxT-4WNqAxft7ET6lkH-4S6Ux3rSGAmczMohEEf8eCeN-jC8WekdPl6zKZQj0YPB
1rx6X0-xlFBs7cl6Wt8rfBP_tZ9YgVWrQmUWypSioc0MUyiphmyEbLZagTyPlUyflGlEdqrZAv6eSe6R
txJy6M1-lD7a5HTzanYTWBPAUHDZGyGKXdJw-W_x0IWChBzI8t3kpG253fg6V3tPgHeKXE94fz_QpYfg
--7kLsyBAfQGbg
            </pre>

              <pre
                class="example nohighlight"
                title="JWT header of a JWT based verifiable presentation (non-normative)"
              >
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1"
}
            </pre
              >

              <p>
                위의 예시에서 <a>검증가능한 프레젠테이션</a>은
                <code>JWS</code> 디지털 서명에 기반한 <code>proof</code>를
                사용하며, 해당 <a>검증</a> 키는 <code>kid</code> 헤더 매개변수를
                사용하여 얻을 수 있다.
              </p>

              <pre
                class="example nohighlight"
                title="JWT payload of a JWT based verifiable presentation (non-normative)"
              >
{
  "iss": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "jti": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "aud": "did:example:4a57546973436f6f6c4a4a57573",
  "nbf": 1541493724,
  "iat": 1541493724,
  "exp": 1573029723,
  "nonce": "343s$FSFDa-",
  "vp": {
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "type": ["VerifiablePresentation"],
    <span class="comment">// base64url-encoded JWT as string</span>
    "verifiableCredential": ["<span class="comment">...</span>"]
  }
}
            </pre>

              <p>
                위의 예시에서 <code>vp</code>는 JWT 인코딩이
                <code>jti</code> 속성을 고유 식별자로 사용하기 때문에
                <code>id</code> <a>속성</a>을 포함하지 않는다.
                <code>verifiableCredential</code>은 JWT 컴팩트 직렬화를 사용하는
                <a>검증가능한 크리덴셜</a>의 문자열 배열을 포함한다.
              </p>

              <pre
                class="example nohighlight"
                title="Verifiable presentation using JWT compact serialization (non-normative)"
              >

eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRpZDpleGFtcGxlOjB4YWJjI2tleTEifQ.<span class="highlight">e
yJpc3MiOiJkaWQ6ZXhhbXBsZTplYmZlYjFmNzEyZWJjNmYxYzI3NmUxMmVjMjEiLCJqdGkiOiJ1cm46d
XVpZDozOTc4MzQ0Zi04NTk2LTRjM2EtYTk3OC04ZmNhYmEzOTAzYzUiLCJhdWQiOiJkaWQ6ZXhhbXBsZ
To0YTU3NTQ2OTczNDM2ZjZmNmM0YTRhNTc1NzMiLCJuYmYiOjE1NDE0OTM3MjQsImlhdCI6MTU0MTQ5M
zcyNCwiZXhwIjoxNTczMDI5NzIzLCJub25jZSI6IjM0M3MkRlNGRGEtIiwidnAiOnsiQGNvbnRleHQiO
lsiaHR0cHM6Ly93d3cudzMub3JnLzIwMTgvY3JlZGVudGlhbHMvdjEiLCJodHRwczovL3d3dy53My5vc
mcvMjAxOC9jcmVkZW50aWFscy9leGFtcGxlcy92MSJdLCJ0eXBlIjpbIlZlcmlmaWFibGVQcmVzZW50Y
XRpb24iLCJDcmVkZW50aWFsTWFuYWdlclByZXNlbnRhdGlvbiJdLCJ2ZXJpZmlhYmxlQ3JlZGVudGlhb
CI6WyJleUpoYkdjaU9pSlNVekkxTmlJc0luUjVjQ0k2SWtwWFZDSXNJbXRwWkNJNkltUnBaRHBsZUdGd
GNHeGxPbUZpWm1VeE0yWTNNVEl4TWpBME16RmpNamMyWlRFeVpXTmhZaU5yWlhsekxURWlmUS5leUp6Z
FdJaU9pSmthV1E2WlhoaGJYQnNaVHBsWW1abFlqRm1OekV5WldKak5tWXhZekkzTm1VeE1tVmpNakVpT
ENKcWRHa2lPaUpvZEhSd09pOHZaWGhoYlhCc1pTNWxaSFV2WTNKbFpHVnVkR2xoYkhNdk16Y3pNaUlzS
W1semN5STZJbWgwZEhCek9pOHZaWGhoYlhCc1pTNWpiMjB2YTJWNWN5OW1iMjh1YW5kcklpd2libUptS
WpveE5UUXhORGt6TnpJMExDSnBZWFFpT2pFMU5ERTBPVE0zTWpRc0ltVjRjQ0k2TVRVM016QXlPVGN5T
Xl3aWJtOXVZMlVpT2lJMk5qQWhOak0wTlVaVFpYSWlMQ0oyWXlJNmV5SkFZMjl1ZEdWNGRDSTZXeUpvZ
EhSd2N6b3ZMM2QzZHk1M015NXZjbWN2TWpBeE9DOWpjbVZrWlc1MGFXRnNjeTkyTVNJc0ltaDBkSEJ6T
2k4dmQzZDNMbmN6TG05eVp5OHlNREU0TDJOeVpXUmxiblJwWVd4ekwyVjRZVzF3YkdWekwzWXhJbDBzS
W5SNWNHVWlPbHNpVm1WeWFXWnBZV0pzWlVOeVpXUmxiblJwWVd3aUxDSlZibWwyWlhKemFYUjVSR1ZuY
21WbFEzSmxaR1Z1ZEdsaGJDSmRMQ0pqY21Wa1pXNTBhV0ZzVTNWaWFtVmpkQ0k2ZXlKa1pXZHlaV1VpT
25zaWRIbHdaU0k2SWtKaFkyaGxiRzl5UkdWbmNtVmxJaXdpYm1GdFpTSTZJanh6Y0dGdUlHeGhibWM5S
jJaeUxVTkJKejVDWVdOallXeGhkWExEcVdGMElHVnVJRzExYzJseGRXVnpJRzUxYmNPcGNtbHhkV1Z6U
EM5emNHRnVQaUo5ZlgxOS5LTEpvNUdBeUJORDNMRFRuOUg3RlFva0VzVUVpOGpLd1hoR3ZvTjNKdFJhN
TF4ck5EZ1hEYjBjcTFVVFlCLXJLNEZ0OVlWbVIxTklfWk9GOG9HY183d0FwOFBIYkYySGFXb2RRSW9PQ
nh4VC00V05xQXhmdDdFVDZsa0gtNFM2VXgzclNHQW1jek1vaEVFZjhlQ2VOLWpDOFdla2RQbDZ6S1pRa
jBZUEIxcng2WDAteGxGQnM3Y2w2V3Q4cmZCUF90WjlZZ1ZXclFtVVd5cFNpb2MwTVV5aXBobXlFYkxaY
WdUeVBsVXlmbEdsRWRxclpBdjZlU2U2UnR4Snk2TTEtbEQ3YTVIVHphbllUV0JQQVVIRFpHeUdLWGRKd
y1XX3gwSVdDaEJ6STh0M2twRzI1M2ZnNlYzdFBnSGVLWEU5NGZ6X1FwWWZnLS03a0xzeUJBZlFHYmciX
X19</span>.ft_Eq4IniBrr7gtzRfrYj8Vy1aPXuFZU-6_ai0wvaKcsrzI4JkQEKTvbJwdvIeuGuTqy7ipO-EYi
7V4TvonPuTRdpB7ZHOlYlbZ4wA9WJ6mSVSqDACvYRiFvrOFmie8rgm6GacWatgO4m4NqiFKFko3r58Lu
eFfGw47NK9RcfOkVQeHCq4btaDqksDKeoTrNysF4YS89INa-prWomrLRAhnwLOo1Etp3E4ESAxg73CR2
kA5AoMbf5KtFueWnMcSbQkMRdWcGC1VssC0tB0JffVjq7ZV6OTyV4kl1-UVgiPLXUTpupFfLRhf9QpqM
BjYgP62KvhIvW8BbkGUelYMetA
            </pre>
            </section>
          </section>
        </section>

        <section>
          <h3 id="linked-data-proofs">연결된 데이터 증명</h3>
          <p>
            이 규격은 연결된 데이터를 활용하여 URL 및 JSON-LD와 같은 표준을
            사용하여 <a>주체</a> 및 관련 속성을 식별하여 웹에 정보를 게시한다.
            이러한 방식으로 정보를 제시할 때, 다른 관련 정보를 쉽게 발견할 수
            있고 새로운 정보를 기존 지식 그래프에 쉽게 병합할 수 있다. 연결된
            데이터는 분산된 방식으로 확장 가능하므로 대규모 통합에 대한 장벽을
            크게 줄일 수 있다. 이 규격의 데이터 모델은 이 규격에 의해 설명된
            데이터 모델을 보호하도록 설계된
            <a href="https://w3c-ccg.github.io/ld-proofs/">연결된 데이터 증명</a
            >과 관련
            <a href="https://w3c-ccg.github.io/ld-cryptosuite-registry/"
              >연결된 데이터 암호화 제품군</a
            >과 잘 작동한다.
          </p>
          <p>
            JSON Web Token 사용과 달리 추가적인 사전 또는 사후 처리가 필요하지
            않다. 연결된 데이터 증명 형식은 <a>검증가능한 크리덴셜</a>과
            <a>검증가능한 프레젠테이션</a>을 간단하고 쉽게 보호하도록
            설계되었다. <a>검증가능한 크리덴셜</a> 또는
            <a>검증가능한 프레젠테이션</a>을 보호하는 것은 이 규격의 유효한
            예시를 연결된 데이터 서명 구현에 전달하고 디지털 서명을 생성하는
            것만큼 간단하다.
          </p>
          <p class="note">
            다양한 구문 형식(예: JSON+JWT, JSON-LD+JWT 또는 JSON-LD+LD-Proofs)의
            서로 다른 품질에 대한 자세한 내용은 검증가능한 크리덴셜 구현 지침
            \[\[VC-IMP-GUIDE\]\] 문서를 참조하시오.
          </p>
        </section>
      </section>
    </section>

    <section class="informative">
      <h2 id="privacy-considerations">개인정보 보호 고려사항</h2>

      <p>
        이 섹션에서는 검증가능한 크리덴셜 데이터 모델을 프로덕션 환경에 배포할
        때의 일반적인 프라이버시 고려사항과 구체적인 프라이버시 영향에 대해
        자세히 설명한다.
      </p>

      <section class="informative">
        <h3>프라이버시 스펙트럼</h3>

        <p>
          가명에서 강력하게 식별된 상태에 이르기까지 프라이버시 스펙트럼이
          있다는 점을 인식하는 것이 중요하다. 사용 사례에 따라, 사람들은 자신이
          기꺼이 제공하고자 하는 정보와 제공된 정보에서 파생될 수 있는 정보에
          대해 서로 다른 편안함을 느낀다.
        </p>

        <figure>
          <img
            style="margin: auto; display: block; width: 80%"
            src="diagrams/privacy-spectrum.svg"
            alt="왼쪽에 빨간색, 중간에 주황색, 오른쪽에 녹색이 있는 수평 막대. 빨간색에는 '높은 상관관계(글로벌 ID), 예: 정부 ID, 배송 주소, 신용카드 번호'라는 텍스트가 있다. 주황색에는 '공모를 통한 상관관계(개인 식별 정보), 예: 이름, 생일, 우편번호'라는 텍스트가 있다. 녹색에는 '상관관계 없음(가명), 예: 21세 이상'이라는 텍스트가 있다."
          />
          <figcaption style="text-align: center">
            가명에서 완전히 식별된 상태에 이르는 프라이버시 스펙트럼.
          </figcaption>
        </figure>

        <p>
          예를 들어, 대부분의 사람들은 알코올을 구매할 때 익명으로 남기를 원할
          것이다. 왜냐하면 요구되는 규제 검사는 오로지 특정 연령 이상인지 여부에
          기반하기 때문이다. 반대로, 의사가 환자에게 쓴 의료 처방전의 경우,
          처방전을 이행하는 약국은 의료 전문가와 환자를 보다 강력하게 식별해야
          한다. 따라서 모든 사용 사례에 적용되는 프라이버시에 대한 단일 접근
          방식은 없다. 프라이버시 솔루션은 사용 사례에 따라 다르다.
        </p>

        <p class="note">
          알코올 구매 시 익명으로 남고 싶어하는 사람들의 경우에도, 상인에게
          적절한 보증을 제공하기 위해 사진이 부착된 신분증이 여전히 필요할 수
          있다. 상인은 (특정 연령 이상이라는 것 외에) 이름이나 기타 세부 정보를
          알 필요가 없을 수 있지만, 많은 경우 단순한 연령 증명만으로는 규정을
          충족하기에 여전히 불충분할 수 있다.
        </p>

        <p>
          검증가능한 크리덴셜 데이터 모델은 전체 프라이버시 스펙트럼을 지원하기
          위해 노력하며, 특정 거래에 대한 올바른 익명성 수준에 대한 철학적
          입장을 취하지 않는다. 다음 섹션에서는 프라이버시에 적대적인 특정
          시나리오를 피하려는 구현자를 위한 지침을 제공한다.
        </p>
      </section>

      <section class="informative">
        <h3>개인 식별 정보</h3>

        <p>
          <code>credential.credentialSubject</code> 필드에 저장된
          <a>검증가능한 크리덴셜</a>과 관련된 데이터는 <a>검증자</a>와 공유될 때
          프라이버시 침해에 취약하다. 정부 발행 식별자, 배송 주소, 성명과 같은
          개인 식별 데이터는 <a>엔티티</a>를 쉽게 식별, 추적 및 연관시키는 데
          사용될 수 있다. 생년월일과 우편번호의 조합과 같이 개인 식별이 불가능해
          보이는 정보조차도 매우 강력한 상관관계와 익명성 제거 능력을 가지고
          있다.
        </p>

        <p>
          구현자는 이러한 특성을 가진 데이터를 공유할 때 <a>보유자</a>에게
          경고하는 것이 강력히 권고된다. <a>발급자</a>는 가능한 경우
          프라이버시를 보호하는 <a>검증가능한 크리덴셜</a>을 제공하는 것이
          강력히 권고된다. 예를 들어, <a>검증자</a>가 <a>엔티티</a>의 나이가
          18세 이상인지 여부를 확인하고자 할 때 생년월일
          <a>검증가능한 크리덴셜</a> 대신 <code>ageOver</code>
          <a>검증가능한 크리덴셜</a>을 발급하는 것이다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>에는 종종 개인 식별 정보(PII)가 포함되어
          있으므로, 구현자는 <a>검증가능한 크리덴셜</a>을 저장하고 전송하는 동안
          액세스해서는 안 되는 사람들로부터 데이터를 보호하는 메커니즘을
          사용하는 것이 강력히 권고된다. 고려될 수 있는 메커니즘에는 전송 계층
          보안(TLS) 또는 전송 중 데이터를 암호화하는 다른 수단, 그리고
          <a>검증가능한 크리덴셜</a>의 데이터를 보호하기 위한 암호화 또는 데이터
          액세스 제어 메커니즘 등이 있다.
        </p>
      </section>

      <section class="informative">
        <h3 id="identifier-based-correlation">식별자 기반 연관</h3>

        <p>
          <a>검증가능한 크리덴셜</a>의 <a>주체</a>는
          <code>credential.credentialSubject.id</code> 필드를 사용하여 식별된다.
          <a>주체</a>를 식별하는 데 사용되는 식별자는 식별자가 장기간 사용되거나
          둘 이상의 웹 도메인에서 사용될 때 더 큰 연관 위험을 초래한다.
        </p>

        <p>
          마찬가지로, <a>크리덴셜</a> 식별자(<code>credential.id</code>)를
          공개하면 여러 <a>검증자</a> 또는 <a>발급자</a>와 <a>검증자</a>가
          공모하여 <a>보유자</a>를 연관시킬 수 있는 상황으로 이어진다.
          <a>보유자</a>가 연관성을 줄이고 싶다면,
          <a>검증가능한 프레젠테이션</a> 중에 식별자를 숨길 수 있는
          <a>검증가능한 크리덴셜</a> 체계를 사용해야 한다. 이러한 체계는
          <a>보유자</a>가 식별자를 생성하고 심지어 식별자를
          <a>검증가능한 크리덴셜</a>에 포함되고 서명된 상태로 유지하면서도
          <a>발급자</a>로부터 식별자를 숨길 수 있도록 한다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a> 시스템에서 강력한 반연관 속성이 요구사항인
          경우, 식별자가 다음 중 하나여야 한다:
        </p>

        <ul>
          <li>단일 출처에 바인딩됨</li>
          <li>일회용</li>
          <li>
            전혀 사용되지 않고 대신 단기적이고 일회용인 bearer 토큰으로 대체됨.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>서명 기반 연관</h3>

        <p>
          <a>검증가능한 크리덴셜</a>의 내용은
          <code>credential.proof</code> 필드를 사용하여 보호된다. 이 필드의
          <a>속성</a>은 동일한 값이 둘 이상의 세션 또는 도메인에서 사용되고 값이
          변경되지 않을 때 더 큰 연관 위험을 초래한다. 예로는
          <code>verificationMethod</code>, <code>created</code>,
          <code>proofPurpose</code>, <code>jws</code> 필드가 있다.
        </p>

        <p>
          강력한 반연관 속성이 요구되는 경우, 서명 값과 메타데이터를 제3자 쌍별
          서명, 영지식 증명 또는 그룹 서명과 같은 기술을 사용하여 매번
          재생성하는 것이 좋다.
        </p>

        <p class="note">
          반연관 서명을 사용하더라도 사용된 암호화의 반연관 속성을 무력화하는
          정보가 여전히 <a>검증가능한 크리덴셜</a>에 포함될 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>장기 식별자 기반 연관</h3>

        <p>
          <a>검증가능한 크리덴셜</a>에는 개인을 연관시키는 데 사용될 수 있는
          장기 식별자가 포함될 수 있다. 이러한 유형의 식별자에는
          <a>주체</a> 식별자, 이메일 주소, 정부 발행 식별자, 조직 발행 식별자,
          주소, 의료 필수 정보, <a>검증가능한 크리덴셜</a> 전용 JSON-LD 컨텍스트
          및 기타 많은 종류의 장기 식별자가 포함된다.
        </p>

        <p>
          <a>보유자</a>에게 소프트웨어를 제공하는 조직은 개인을 연관시키는 데
          사용될 수 있는 정보가 포함된 <a>검증가능한 크리덴셜</a>의 필드를
          식별하고, 이 정보가 공유될 때 <a>보유자</a>에게 경고하기 위해 노력해야
          한다.
        </p>
      </section>

      <section class="informative">
        <h3>기기 핑거프린팅</h3>

        <p>
          인터넷과 웹에서 개인을 추적하고 연관시키는 데 사용되는
          <a>검증가능한 크리덴셜</a> 외부의 메커니즘이 있다. 이러한 메커니즘에는
          인터넷 프로토콜(IP) 주소 추적, 웹 브라우저 핑거프린팅, 에버쿠키, 광고
          네트워크 추적기, 모바일 네트워크 위치 정보, 애플리케이션 내 GPS(Global
          Positioning System) API 등이 있다. <a>검증가능한 크리덴셜</a>을
          사용한다고 해서 이러한 다른 추적 기술의 사용을 막을 수는 없다. 또한
          이러한 기술이 <a>검증가능한 크리덴셜</a>과 함께 사용될 때 새로운 연관
          가능한 정보가 발견될 수 있다. 예를 들어, 생일과 GPS 위치를 결합하면
          여러 웹사이트에서 개인을 강력하게 연관시키는 데 사용될 수 있다.
        </p>

        <p>
          프라이버시를 존중하는 시스템은 <a>검증가능한 크리덴셜</a>이 사용될 때
          이러한 다른 추적 기술의 사용을 방지하는 것이 좋다. 경우에 따라
          <a>보유자</a>를 대신하여 <a>검증가능한 크리덴셜</a>을 전송하는
          장치에서 추적 기술을 비활성화해야 할 수도 있다.
        </p>
      </section>

      <section class="informative">
        <h3>추상적인 클레임 선호</h3>

        <p>
          <a>검증가능한 크리덴셜</a>의 수신자가 거래에 필요한 것보다 더 많은
          PII를 공개하지 않고 다양한 상황에서 사용할 수 있도록 하기 위해,
          <a>발급자</a>는 <a>크리덴셜</a>에 게시된 정보를 예상되는 목적에 필요한
          최소한의 집합으로 제한하는 것을 고려해야 한다. <a>크리덴셜</a>에 PII를
          넣지 않는 한 가지 방법은 <a>주체</a>에 대한 구체적인 정보를 제공하지
          않고 <a>검증자</a>의 요구사항을 충족하는 추상적인 <a>속성</a>을
          사용하는 것이다.
        </p>
        <p>
          예를 들어, 이 문서는 훨씬 더 강력한 PII인 특정 생년월일 대신
          <code>ageOver</code> <a>속성</a>을 사용한다. 특정 시장의 소매업체가
          일반적으로 구매자의 연령이 특정 연령 이상일 것을 요구하는 경우, 해당
          시장에서 신뢰받는 <a>발급자</a>는 특정 생년월일에 대한 <a>클레임</a>이
          포함된 <a>검증가능한 크리덴셜</a>을 제공하는 대신 <a>주체</a>가 해당
          요구사항을 충족했다고 주장하는 <a>검증가능한 크리덴셜</a>을 제공하는
          것을 선택할 수 있다. 이를 통해 개별 고객은 특정 PII를 공개하지 않고
          구매할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>데이터 최소화 원칙</h3>

        <p>
          한 맥락에서 공개된 정보가 다른 맥락으로 유출될 때 프라이버시 침해가
          발생한다. 이러한 위반을 방지하기 위한 인정된 모범 사례는 요청하고
          수신하는 정보를 절대적으로 필요한 최소한으로 제한하는 것이다. 이
          데이터 최소화 접근 방식은 미국의 건강 보험 이동성 및 책임법(HIPAA)과
          유럽 연합의 일반 데이터 보호 규정(GDPR)을 포함한 여러 관할 구역의
          규정에서 요구된다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>에서 <a>발급자</a>에 대한 데이터 최소화는
          <a>검증가능한 크리덴셜</a>의 내용을 예상되는 사용을 위해 잠재적
          <a>검증자</a>에게 필요한 최소한으로 제한하는 것을 의미한다.
          <a>검증자</a>의 경우 데이터 최소화는 서비스 액세스에 요청되거나 필요한
          정보의 범위를 제한하는 것을 의미한다.
        </p>

        <p>
          예를 들어, 운전자 ID 번호, 키, 체중, 생일, 집 주소를 포함하는
          운전면허증은 해당 사람이 특정 연령 이상임을 확인하는 데 필요한 것보다
          더 많은 정보를 포함하는 <a>크리덴셜</a>이다.
        </p>

        <p>
          <a>발급자</a>가 정보를 원자화하거나 <a>선택적 공개</a>를 허용하는 서명
          체계를 사용하는 것이 모범 사례로 간주된다. 예를 들어, 운전면허증의
          <a>발급자</a>는 운전면허증에 나타나는 모든 속성을 포함하는
          <a>검증가능한 크리덴셜</a>과 함께 각 <a>검증가능한 크리덴셜</a>이
          생일과 같은 단일 속성만 포함하는 <a>검증가능한 크리덴셜</a> 집합을
          발급할 수 있다. 또한 <code>ageOver</code> 속성만 포함하는
          <a>검증가능한 크리덴셜</a>과 같이 보다 추상적인
          <a>검증가능한 크리덴셜</a>을 발급할 수도 있다. 한 가지 가능한 적응
          방식은 <a>발급자</a>가 <a>검증가능한 크리덴셜</a>의 가명 사용을
          촉진하는 일회용 <a>bearer 크리덴셜</a>을 검색하기 위한 보안 HTTP
          엔드포인트를 제공하는 것이다. 이를 비실용적이거나 안전하지 않다고
          생각하는 구현자는 증명 시점에서 <a>발급자</a>에 대한 의존성을 제거하고
          <a>발급자</a>로부터의 시간적 상관관계 위험을 줄이는
          <a>선택적 공개</a> 체계를 사용하는 것을 고려해야 한다.
        </p>

        <p>
          <a>검증자</a>는 특정 트랜잭션 발생에 절대적으로 필요한 정보만 요청하는
          것이 좋다. 이것은 최소한 두 가지 이유로 중요하다:
        </p>

        <ul>
          <li>
            <a>검증자</a>가 다룰 필요가 없는 매우 민감한 정보를 처리해야 하는
            책임을 줄인다.
          </li>
          <li>
            특정 트랜잭션에 필요한 정보만 요청함으로써 개인의 프라이버시를
            강화한다.
          </li>
        </ul>

        <p class="note">
          최소 공개 원칙을 실천하는 것이 가능하지만, 단일 세션 또는 여러 세션에
          걸쳐 특정 사용 사례에 대해 개인을 강력하게 식별하는 것을 피하는 것은
          불가능할 수 있다. 이 문서의 저자들은 실제 시나리오에서 이 원칙을
          충족하는 것이 얼마나 어려운지 강조할 수 없다.
        </p>
      </section>

      <section class="informative">
        <h3>Bearer 크리덴셜</h3>

        <p>
          <dfn data-lt="bearer credentials">bearer 크리덴셜</dfn>은 콘서트
          티켓과 같이 bearer 크리덴셜의 <a>보유자</a>에게 <a>보유자</a>에 대한
          민감한 정보를 공개하지 않고 특정 리소스에 대한 자격을 부여하는
          프라이버시 강화 정보이다. bearer 크리덴셜은 종종 bearer 크리덴셜의
          공유가 우려되지 않거나 큰 경제적 또는 명성 손실로 이어지지 않는 저위험
          사용 사례에 사용된다.
        </p>

        <p>
          <a>bearer 크리덴셜</a>인 <a>검증가능한 크리덴셜</a>은
          <code>credentialSubject</code> <a>속성</a>에 중첩된 <code>id</code>
          <a>속성</a>을 사용하여 표현되는 <a>주체</a> 식별자를 지정하지
          않음으로써 가능해진다. 예를 들어, 다음 <a>검증가능한 크리덴셜</a>은
          <a>bearer 크리덴셜</a>이다:
        </p>

        <pre class="example nohighlight" title="Usage of issuer properties">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// note that the 'id' property is not specified for bearer credentials</span>
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
      </pre>

        <p>
          <a>bearer 크리덴셜</a>은 프라이버시를 강화할 수 있지만,
          <a>bearer 크리덴셜</a>의 <a>보유자</a>가 예상하는 것보다 더 많은
          정보를 실수로 누설하지 않도록 신중하게 작성되어야 한다. 예를 들어,
          동일한 <a>bearer 크리덴셜</a>을 여러 사이트에서 반복적으로 사용하면
          이러한 사이트가 잠재적으로 공모하여 <a>보유자</a>를 부당하게
          추적하거나 연관시킬 수 있다. 마찬가지로 생년월일 및 우편번호와 같은
          정보는 식별되지 않는 것처럼 보일 수 있지만, 동일한
          <a>bearer 크리덴셜</a> 또는 세션에서 함께 사용될 때 통계적으로 개인을
          식별하는 데 사용될 수 있다.
        </p>

        <p>
          <a>bearer 크리덴셜</a>의 <a>발급자</a>는 <a>bearer 크리덴셜</a>이
          다음과 같은 프라이버시 강화 이점을 제공하도록 해야 한다:
        </p>

        <ul>
          <li>가능한 경우 일회용이다.</li>
          <li>개인 식별 정보를 포함하지 않는다.</li>
          <li>부당하게 연관될 수 없다.</li>
        </ul>

        <p>
          민감한 정보가 포함된 <a>bearer 크리덴셜</a>이 발급되거나 요청되는 경우
          또는 하나 이상의 세션에서 둘 이상의 <a>bearer 크리덴셜</a>을 결합할 때
          상관관계 위험이 있는 경우 <a>보유자</a>에게 소프트웨어에 의해
          경고되어야 한다. 모든 상관관계 위험을 탐지하는 것은 불가능할 수
          있지만, 일부는 분명히 탐지 가능할 수 있다.
        </p>

        <p>
          <a>검증자</a>는 <a>보유자</a>를 부당하게 연관시키는 데 사용될 수 있는
          <a>bearer 크리덴셜</a>을 요청해서는 안 된다.
        </p>
      </section>

      <section class="informative">
        <h3 id="validation">유효성 검사</h3>

        <p>
          <a>검증가능한 크리덴셜</a>을 처리할 때 <a>검증자</a>는 부록
          <a href="#validation"></a>에 나열된 많은 검사와 다양한 특정 비즈니스
          프로세스 검사를 수행할 것으로 예상된다. 유효성 검사에는 다음 사항을
          확인하는 것이 포함될 수 있다:
        </p>

        <ul>
          <li><a>보유자</a>의 전문 면허 상태.</li>
          <li>면허 갱신 또는 취소 날짜.</li>
          <li>개인의 세부 자격.</li>
          <li>
            <a>보유자</a>와 <a>보유자</a>가 상호 작용하려는 <a>엔티티</a> 사이에
            관계가 존재하는지 여부.
          </li>
          <li><a>보유자</a>와 연결된 지리적 위치 정보.</li>
        </ul>

        <p>
          이러한 검사를 수행하는 과정에서 <a>보유자</a>의 프라이버시 침해로
          이어지는 정보 유출이 발생할 수 있다. 예를 들어, 폐기 목록을 확인하는
          것과 같은 간단한 작업으로 인해 특정 비즈니스가 <a>보유자</a>와 상호
          작용할 가능성이 있음을 <a>발급자</a>에게 알릴 수 있다. 이를 통해
          <a>발급자</a>가 공모하여 개인의 알지 못한 채로 연관시킬 수 있다.
        </p>

        <p>
          <a>발급자</a>는 <a>검증</a> 프로세스 동안 프라이버시 위반으로 이어질
          수 있는 <a>크리덴셜</a>당 고유한 <a>크리덴셜</a> 폐기 목록과 같은
          메커니즘을 사용하지 않도록 해야 한다. <a>보유자</a>에게 소프트웨어를
          제공하는 조직은 검증 프로세스 중에 프라이버시 침해로 이어질 수 있는
          정보가 <a>크리덴셜</a>에 포함된 경우 경고해야 한다. <a>검증자</a>는
          프라이버시 침해를 유발하거나 잘못된 프라이버시 관행을 가능하게 하는
          <a>크리덴셜</a>을 거부하는 것을 고려해야 한다.
        </p>
      </section>

      <section class="informative">
        <h3>저장소 제공자 및 데이터 마이닝</h3>

        <p>
          <a>보유자</a>가 <a>발급자</a>로부터 <a>검증가능한 크리덴셜</a>을
          받으면 <a>검증가능한 크리덴셜</a>은 어딘가에 저장되어야 한다(예:
          <a>크리덴셜</a> 리포지토리). <a>보유자</a>는
          <a>검증가능한 크리덴셜</a>의 정보가 본질적으로 민감하고 매우
          개별화되어 데이터 마이닝의 높은 가치 목표가 된다는 점에 주의해야 한다.
          <a>검증가능한 크리덴셜</a>의 무료 저장소를 광고하는 서비스는 실제로
          개인 데이터를 마이닝하고 개인 및 조직에 대한 개별 프로파일을
          구축하려는 조직에 판매할 수 있다.
        </p>

        <p>
          <a>보유자</a>는 <a>크리덴셜</a> 리포지토리의 서비스 약관, 특히
          <a>검증가능한 크리덴셜</a>을 서비스 제공자와 함께 저장하는 사람들을
          위해 마련된 상관관계 및 데이터 마이닝 보호를 인식해야 한다.
        </p>

        <p>
          데이터 마이닝 및 프로파일링에 대한 몇 가지 효과적인 완화 방법은 다음을
          사용하는 것이다:
        </p>

        <ul>
          <li>정보를 제3자에게 판매하지 않는 서비스 제공자.</li>
          <li>
            서비스 제공자가 <a>크리덴셜</a>의 내용을 볼 수 없도록
            <a>검증가능한 크리덴셜</a>을 암호화하는 소프트웨어.
          </li>
          <li>
            사용자가 제어하는 장치에 <a>검증가능한 크리덴셜</a>을 로컬로
            저장하고 기대 이상으로 정보를 업로드하거나 분석하지 않는 소프트웨어.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>크리덴셜 집계</h3>

        <p>
          동일한 <a>주체</a>에 대한 두 가지 정보를 보유하는 것은 정보가 서로
          다른 채널을 통해 전달되더라도 거의 항상 단순히 두 가지 정보의 합보다
          <a>주체</a>에 대해 더 많은 것을 드러낸다. <a>검증가능한 크리덴셜</a>의
          집계는 프라이버시 위험이며 생태계의 모든 참여자는 데이터 집계의 위험을
          인식해야 한다.
        </p>

        <p>
          예를 들어, 한 세션에서 이메일 주소에 대한 <a>bearer 크리덴셜</a>을, 그
          다음 세션에서 <a>보유자</a>가 21세 이상이라는 <a>bearer 크리덴셜</a>을
          제공하는 경우, 정보의 <a>검증자</a>는 이제 해당 개인에 대한 고유
          식별자와 연령 관련 정보를 모두 가지게 된다. 이제 시간이 지남에 따라 더
          많은 정보가 유출되도록 <a>보유자</a>에 대한 프로파일을 쉽게 만들고
          구축할 수 있다. <a>크리덴셜</a>의 집계는 서로 공모하는 여러 사이트에서
          수행될 수도 있으며, 이는 프라이버시 침해로 이어진다.
        </p>

        <p>
          기술적 관점에서 정보의 집계를 방지하는 것은 해결하기 매우 어려운
          프라이버시 문제이다. 영지식 증명과 같은 새로운 암호화 기술이 집계 및
          상관관계 문제에 대한 해결책으로 제안되고 있지만, 장기 식별자와
          브라우저 추적 기술의 존재는 가장 현대적인 암호화 기술조차도
          무력화시킨다.
        </p>

        <p>
          상관관계 또는 집계의 프라이버시 영향에 대한 해결책은 기술적인 것이
          아니라 정책 중심인 경향이 있다. 따라서 <a>보유자</a>가 자신에 대한
          정보가 집계되는 것을 원하지 않는 경우, 이를 전송하는
          <a>검증가능한 프레젠테이션</a>에 명시해야 한다.
        </p>
      </section>

      <section class="informative">
        <h3 id="usage-patterns">사용 패턴</h3>

        <p>
          프라이버시를 보장하기 위한 최선의 노력에도 불구하고,
          <a>검증가능한 크리덴셜</a>을 실제로 사용하면 잠재적으로 익명성 해제와
          프라이버시 손실로 이어질 수 있다. 이러한 상관관계는 다음과 같은 경우에
          발생할 수 있다:
        </p>

        <ul>
          <li>
            동일한 <a>검증가능한 크리덴셜</a>이 동일한 <a>검증자</a>에게 두 번
            이상 제시된다. <a>검증자</a>는 <a>보유자</a>가 동일한 개인임을
            추론할 수 있다.
          </li>
          <li>
            동일한 <a>검증가능한 크리덴셜</a>이 서로 다른 <a>검증자</a>에게
            제시되고, 해당 <a>검증자</a>가 공모하거나 제3자가 두 <a>검증자</a>의
            트랜잭션 기록에 액세스할 수 있다. 주의 깊은 당사자는
            <a>검증가능한 크리덴셜</a>을 제시하는 개인이 두 서비스에서 동일한
            사람이라고 추론할 수 있다. 즉, 계정이 동일한 사람에 의해 제어된다.
          </li>
          <li>
            <a>크리덴셜</a>의 <a>주체</a> 식별자가 여러 <a>프레젠테이션</a> 또는
            <a>검증자</a>에 걸쳐 동일한 <a>주체</a>를 참조한다. 서로 다른
            <a>크리덴셜</a>이 제시되더라도 <a>주체</a> 식별자가 동일하면
            <a>검증자</a>(및 <a>검증자</a> 로그에 액세스할 수 있는 사람)는
            <a>크리덴셜</a>의 <a>보유자</a>가 동일한 사람이라고 추론할 수 있다.
          </li>
          <li>
            <a>크리덴셜</a>의 기본 정보를 사용하여 서비스 전반에서 개인을 식별할
            수 있다. 이 경우 <a>검증자</a>는 다른 출처(직접 <a>보유자</a>가
            제공한 정보 포함)의 정보를 사용하여 <a>크리덴셜</a> 내부의 정보를
            기존 프로필과 상관관계를 지을 수 있다. 예를 들어, <a>보유자</a>가
            우편번호, 연령, 성별이 포함된 <a>크리덴셜</a>을 제시하는 경우
            <a>검증자</a>는 해당 <a>크리덴셜</a>의 <a>주체</a>를 기존 프로필과
            잠재적으로 연관시킬 수 있다. 자세한 내용은 [[DEMOGRAPHICS]]를
            참조하라.
          </li>
          <li>
            <a>크리덴셜</a>의 식별자를 중앙 집중식 폐기 서버에 전달한다. 중앙
            집중식 서버는 상호 작용에서 <a>크리덴셜</a> 사용을 연관시킬 수 있다.
            예를 들어, 이러한 방식으로 <a>크리덴셜</a>이 연령 증명에 사용되는
            경우 중앙 집중식 서비스는 해당 <a>크리덴셜</a>이 제시된 모든 곳(모든
            주류 판매점, 바, 성인용품점, 복권 구매 등)을 알 수 있다.
          </li>
        </ul>

        <p>
          부분적으로 다음과 같은 방법으로 이러한 익명성 해제와 프라이버시 손실을
          완화할 수 있다:
        </p>

        <ul>
          <li>
            특정 <a>크리덴셜</a>에 대해 전역적으로 고유한 식별자를 <a>주체</a>로
            사용하고 해당 <a>크리덴셜</a>을 절대 재사용하지 않는다.
          </li>
          <li>
            <a>크리덴셜</a>이 폐기를 지원하는 경우 폐기를 위해 전역적으로 분산된
            서비스를 사용한다.
          </li>
          <li>
            <a>크리덴셜</a>의 ID 제출에 의존하지 않는 폐기 API를 설계한다. 예를
            들어, 쿼리 대신 폐기 목록을 사용한다.
          </li>
          <li>
            개인 식별 정보를 특정 장기 <a>주체</a> 식별자와 연결하는 것을
            피한다.
          </li>
        </ul>

        <p>
          이러한 완화 기술이 항상 실용적이거나 심지어 필요한 사용과 호환되는
          것은 아니라는 점을 이해한다. 때로는 상관관계가 요구사항이다.
        </p>

        <p>
          예를 들어, 일부 처방약 모니터링 프로그램에서는 사용 모니터링이
          요구사항이다. 집행 기관은 개인이 통제 물질에 대한 여러 처방전을 얻기
          위해 시스템을 속이지 않는다는 것을 확인할 수 있어야 한다. 이러한 법적
          또는 규제적 사용 상관관계 필요성은 개인 프라이버시 우려보다 우선한다.
        </p>

        <p>
          <a>검증가능한 크리덴셜</a>은 또한 여러 서비스에 로그인하기 위해 공통
          페르소나를 사용할 때와 같이 서비스 전반에서 개인을 의도적으로
          연관시키는 데 사용될 것이다. 따라서 이러한 각 서비스의 모든 활동이
          의도적으로 동일한 개인에게 연결된다. 이러한 각 서비스가 예상되는
          방식으로 상관관계를 사용하는 한 이것은 프라이버시 문제가 아니다.
        </p>

        <p>
          <a>크리덴셜</a> 사용의 프라이버시 위험은 <a>크리덴셜</a> 제시로 인해
          의도하지 않거나 예상치 못한 상관관계가 발생할 때 발생한다.
        </p>
      </section>

      <section class="informative">
        <h3>잘못된 당사자와 정보 공유</h3>

        <p>
          <a>보유자</a>가 <a>검증자</a>와 정보를 공유하기로 선택한 경우,
          <a>검증자</a>가 악의를 가지고 행동하고 <a>보유자</a>에게 해를 끼치는
          데 사용될 수 있는 정보를 요청하는 경우일 수 있다. 예를 들어,
          <a>검증자</a>는 은행 계좌 번호를 요청할 수 있으며, 이는 다른 정보와
          함께 사용하여 <a>보유자</a> 또는 은행을 속일 수 있다.
        </p>

        <p>
          <a>발급자</a>는 <a>보유자</a>가 실수로 <a>크리덴셜</a>을 잘못된
          <a>검증자</a>에게 전송하더라도 상황이 치명적이지 않도록 가능한 한 많은
          정보를 토큰화하도록 노력해야 한다.
        </p>

        <p>
          예를 들어, 개인의 은행 잔고를 확인하기 위해 은행 계좌 번호를 포함하는
          대신 <a>검증자</a>가 잔고가 특정 금액 이상인지 확인할 수 있는 토큰을
          제공한다. 이 경우 은행은 잔고 확인 토큰이 포함된
          <a>검증가능한 크리덴셜</a>을 <a>보유자</a>에게 발급할 수 있다. 그러면
          <a>보유자</a>는 <a>검증가능한 프레젠테이션</a>에
          <a>검증가능한 크리덴셜</a>을 포함하고 디지털 서명을 사용하여 토큰을
          신용 조회 기관에 바인딩한다. 그러면 <a>검증자</a>는
          <a>검증가능한 프레젠테이션</a>을 자신의 디지털 서명으로 래핑하고 다시
          발급자에게 전달하여 계좌 잔고를 동적으로 확인할 수 있다.
        </p>

        <p>
          이 접근 방식을 사용하면 <a>보유자</a>가 계좌 잔고 토큰을 잘못된
          당사자와 공유하더라도 공격자는 은행 계좌 번호나 계좌의 정확한 값을
          알아낼 수 없다. 그리고 역서명의 유효 기간을 감안할 때 몇 분 이상
          토큰에 대한 액세스 권한을 얻지 못한다.
        </p>
      </section>

      <section class="informative">
        <h3>클레임 발급 빈도</h3>

        <p>
          섹션 <a href="#usage-patterns"></a>에 자세히 설명된 대로 사용 패턴은
          특정 유형의 행동과 상관관계가 있을 수 있다. 이러한 상관관계의 일부는
          <a>보유자</a>가 <a>발급자</a>의 지식 없이 <a>검증가능한 크리덴셜</a>을
          사용할 때 완화된다. 그러나 <a>발급자</a>는
          <a>검증가능한 크리덴셜</a>의 수명을 짧게 하고 갱신을 자동으로 함으로써
          이러한 보호를 무력화할 수 있다.
        </p>

        <p>
          예를 들어, <code>ageOver</code> <a>검증가능한 크리덴셜</a>은 바에
          접근하는 데 유용하다. <a>발급자</a>가 매우 짧은 만료 기간과 자동 갱신
          메커니즘으로 이러한 <a>검증가능한 크리덴셜</a>을 발급하는 경우,
          <a>발급자</a>는 <a>보유자</a>에게 부정적인 영향을 미치는 방식으로
          <a>보유자</a>의 행동을 연관시킬 수 있다.
        </p>

        <p>
          <a>보유자</a>에게 소프트웨어를 제공하는 조직은 행동 상관관계를 초래할
          수 있는 수명이 짧은 <a>크리덴셜</a>을 반복적으로 사용하는 경우
          경고해야 한다. <a>발급자</a>는 사용 패턴을 연관시킬 수 있는 방식으로
          <a>크리덴셜</a>을 발급하는 것을 피해야 한다.
        </p>
      </section>

      <section class="informative">
        <h3>일회용 크리덴셜 선호</h3>

        <p>
          이상적인 프라이버시 존중 시스템은 <a>검증자</a>와의 상호 작용에 필요한
          정보만 <a>보유자</a>가 공개하도록 요구할 것이다. 그런 다음
          <a>검증자</a>는 공개 요구사항이 충족되었음을 기록하고 공개된 민감한
          정보를 잊어버릴 것이다. 많은 경우 규제 부담과 같은 경쟁 우선순위로
          인해 이 이상적인 시스템이 채택되지 못하고 있다. 다른 경우에는 장기
          식별자가 일회성 사용을 방해한다. 그러나
          <a>검증가능한 크리덴셜</a> 생태계의 설계는 가능한 한 일회용
          <a>검증가능한 크리덴셜</a>을 선호함으로써 가능한 한 프라이버시를
          존중하도록 노력해야 한다.
        </p>

        <p>
          일회용 <a>검증가능한 크리덴셜</a>을 사용하면 여러 가지 이점이 있다. 첫
          번째 이점은 <a>검증자</a>가 <a>검증가능한 크리덴셜</a>의 데이터가
          새로운 것임을 확신할 수 있다는 것이다. 두 번째 이점은
          <a>검증가능한 크리덴셜</a>에 장기 식별자가 없는 경우
          <a>검증가능한 크리덴셜</a> 자체를 사용하여 <a>보유자</a>를 온라인에서
          추적하거나 연관시킬 수 없다는 것을 아는 <a>보유자</a>에게 있다.
          마지막으로 공격자가 훔칠 것이 없어 전체 생태계를 더 안전하게 운영할 수
          있다.
        </p>
      </section>

      <section class="informative">
        <h3>프라이빗 브라우징</h3>

        <p>
          이상적인 프라이빗 브라우징 시나리오에서는 PII가 공개되지 않는다. 많은
          <a>크리덴셜</a>에 PII가 포함되어 있기 때문에 <a>보유자</a>에게
          소프트웨어를 제공하는 조직은 프라이빗 브라우징 모드에서
          <a>크리덴셜</a>과 <a>프레젠테이션</a>을 사용하려는 경우 이 정보가
          공개될 가능성에 대해 경고해야 한다. 각 브라우저 공급업체가 프라이빗
          브라우징을 다르게 처리하고 일부 브라우저에는 이 기능이 전혀 없을 수
          있으므로 구현자는 이러한 차이점을 인식하고 그에 따라 솔루션을 구현하는
          것이 중요하다.
        </p>
      </section>
    </section>
    <section class="informative">
      <h2>보안 고려사항</h2>

      <p>
        <a>발급자</a>, <a>보유자</a>, <a>검증자</a>가 이 규격에서 설명하는
        데이터를 처리할 때 알고 있어야 할 몇 가지 보안 고려사항이 있다. 이
        섹션의 의미를 무시하거나 이해하지 않으면 보안 취약점이 발생할 수 있다.
      </p>

      <p>
        이 섹션에서는 광범위한 보안 고려사항을 강조하려고 하지만, 완전한 목록은
        아니다. 구현자는 이 규격에 설명된 기술을 사용하여 미션 크리티컬 시스템을
        구현할 때 보안 및 암호학 전문가의 조언을 구할 것을 권장한다.
      </p>

      <section class="informative">
        <h3>암호 스위트 및 라이브러리</h3>

        <p>
          이 규격에 설명된 데이터 모델의 일부 측면은 암호학을 사용하여 보호할 수
          있다. 구현자가 <a>크리덴셜</a>과 <a>프레젠테이션</a>을 생성하고
          처리하는 데 사용되는 암호 스위트와 라이브러리를 이해하는 것이
          중요하다. 일반적으로 암호 시스템을 구현하고 감사하려면 상당한 경험이
          필요하다. 효과적인
          <a href="https://en.wikipedia.org/wiki/Red_team">레드 팀</a>은 또한
          보안 검토에서 편견을 제거하는 데 도움이 될 수 있다.
        </p>

        <p>
          암호 스위트와 라이브러리에는 수명이 있으며 결국 새로운 공격과 기술
          발전에 의해 무너진다. 프로덕션 품질 시스템은 이를 고려해야 하며,
          만료되거나 손상된 암호 스위트와 라이브러리를 쉽고 선제적으로
          업그레이드하고 기존 <a>크리덴셜</a>을 무효화하고 교체할 수 있는
          메커니즘이 존재해야 한다. 정기적인 모니터링은 <a>크리덴셜</a>을
          처리하는 시스템의 장기적인 생존력을 보장하는 데 중요하다.
        </p>
      </section>

      <section class="informative">
        <h3>콘텐츠 무결성 보호</h3>

        <p>
          <a>검증가능한 크리덴셜</a>은 종종 <a>검증가능한 크리덴셜</a> 자체
          외부에 있는 데이터에 대한 URL을 포함한다. 이미지, JSON-LD 컨텍스트 및
          기타 기계 판독 가능한 데이터와 같이 <a>검증가능한 크리덴셜</a> 외부에
          존재하는 연결된 콘텐츠는 데이터가 <a>검증가능한 크리덴셜</a>의
          <a href="#proofs-signatures">증명</a> 보호 외부에 있기 때문에
          변조로부터 보호되지 않는 경우가 많다. 예를 들어, 다음 강조 표시된
          링크는 콘텐츠 무결성이 보호되지 않지만 아마도 보호되어야 한다:
        </p>

        <pre
          class="example nohighlight"
          title="Non-content-integrity protected links"
        >
{
  "@context": [
    <span class="highlight">"https://www.w3.org/2018/credentials/v1"</span>,
    <span class="highlight">"https://www.w3.org/2018/credentials/examples/v1"</span>
  ],
  "id": "http://example.edu/credentials/58473",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.edu/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  "proof": { <span class="comment">...</span> }
}
      </pre>

        <p>
          이 규격은 특정한 콘텐츠 무결성 보호를 권장하지는 않지만, 콘텐츠에 대한
          링크의 무결성을 보호하고 싶은 문서 작성자는 콘텐츠 무결성을 강제하는
          URL 체계를 사용하는 것이 좋다. 이러한 두 가지 체계로는 [[HASHLINK]]
          규격과 [[IPFS]]가 있다. 아래 예시는 이전 예시를 변형하고 [[HASHLINK]]
          규격을 사용하여 JSON-LD 컨텍스트에 콘텐츠 무결성 보호를 추가하고,
          [[IPFS]] 링크를 사용하여 이미지에 콘텐츠 무결성 보호를 추가한다.
        </p>

        <pre
          class="example nohighlight"
          title="Content-integrity protection for links to external data"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/2018/credentials/examples/v1<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://example.edu/credentials/58473",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"ipfs:/ipfs/QmXfrS3pHerg44zzK6QKQj6JDk8H6cMtQS7pdXbohwNQfK/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  "proof": { <span class="comment">...</span> }
}
      </pre>

        <p class="note">
          프로덕션 구현에서는 중요한 JSON-LD 컨텍스트의 정적 사본과 함께 제공될
          것으로 예상되므로 위의 JSON-LD 컨텍스트에 보호가 필요한지 여부는
          논란의 여지가 있다.
        </p>

        <p>
          위의 예는 콘텐츠 무결성 보호를 달성하는 한 가지 방법이지만, 특정
          애플리케이션에 더 적합할 수 있는 다른 솔루션이 있다. 구현자는 콘텐츠
          무결성이 보호되지 않은 외부 기계 판독 가능 콘텐츠에 대한 링크가 어떻게
          자신의 애플리케이션에 대한 성공적인 공격으로 이어질 수 있는지 이해해야
          한다.
        </p>
      </section>

      <section class="informative">
        <h3>서명되지 않은 클레임</h3>

        <p>
          이 규격은 어떤 종류의 서명이나 증명도 포함하지 않는 <a>크리덴셜</a>을
          생성할 수 있게 한다. 이러한 유형의 <a>크리덴셜</a>은 종종 중간
          저장소나 웹 페이지에서 양식을 작성하는 것과 유사한 자가 주장 정보에
          유용하다. 구현자는 이러한 유형의 <a>크리덴셜</a>은 작성자가 알려지지
          않았거나 신뢰할 수 없기 때문에 <a>검증 가능</a>하지 않다는 점을 알아야
          한다.
        </p>
      </section>

      <section class="informative">
        <h3>토큰 바인딩</h3>

        <p>
          <a>검증자</a>는 자신이 <a>검증가능한 프레젠테이션</a>의 의도된
          수신자이며
          <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack"
            >중간자 공격</a
          >의 대상이 아님을 확인해야 할 수 있다.
          <a>검증가능한 프레젠테이션</a>에 대한 요청을 응답에 연결하는 토큰
          바인딩 [[RFC8471]]과 같은 접근 방식은 프로토콜을 보호할 수 있다.
          보안되지 않은 모든 프로토콜은 중간자 공격에 취약하다.
        </p>
      </section>

      <section class="informative">
        <h3>종속 클레임 번들링</h3>

        <p>
          <a>발급자</a>가 <a>크리덴셜</a>의 정보를 원자화하거나 선택적 공개를
          허용하는 서명 체계를 사용하는 것이 모범 사례로 간주된다. 원자화의 경우
          <a>발급자</a>에 의해 안전하게 수행되지 않으면 <a>보유자</a>가
          <a>발급자</a>가 의도하지 않은 방식으로 서로 다른 <a>크리덴셜</a>을
          함께 번들링할 수 있다.
        </p>

        <p>
          예를 들어, 대학은 한 사람에게 각각 두 개의 <a>속성</a>을 포함하는 두
          개의 <a>검증가능한 크리덴셜</a>을 발급할 수 있는데, 이는 "컴퓨팅
          학과"의 "직원" 또는 "경제학과"의 "대학원생"과 같이 주어진 "학과"에서
          그 사람의 "역할"을 지정하기 위해 함께 취해져야 한다. 이러한
          <a>검증가능한 크리덴셜</a>이 이러한 <a>속성</a> 중 하나만 각
          <a>크리덴셜</a>에 넣도록 원자화되면, 대학은 그 사람에게 "직원",
          "대학원생", "컴퓨팅 학과", "경제학과" 중 하나의 지정을 포함하는 네
          개의 <a>크리덴셜</a>을 발급할 것이다. 그러면 <a>보유자</a>는 "직원"과
          "경제학과"의 <a>검증가능한 크리덴셜</a>을 <a>검증자</a>에게 전송할 수
          있으며, 이는 함께 거짓 <a>클레임</a>을 구성할 것이다.
        </p>
      </section>

      <section class="informative">
        <h3>고도로 동적인 정보</h3>

        <p>
          고도로 동적인 정보에 대해 <a>검증가능한 크리덴셜</a>이 발급되는 경우,
          구현자는 만료 시간을 적절하게 설정해야 한다.
          <a>검증가능한 크리덴셜</a>이 유효한 시간 프레임보다 더 긴 만료 기간은
          악용 가능한 보안 취약점을 만들 수 있다. <a>검증가능한 크리덴셜</a>로
          표현된 정보가 유효한 시간 프레임보다 더 짧은 만료 기간은
          <a>보유자</a>와 <a>검증자</a>에게 부담을 준다. 따라서 사용 사례와
          <a>검증가능한 크리덴셜</a>에 포함된 정보의 예상 수명에 적합한
          <a>검증가능한 크리덴셜</a>의 유효 기간을 설정하는 것이 중요하다.
        </p>
      </section>

      <section class="informative">
        <h3>장치 도난 및 사칭</h3>

        <p>
          <a>검증가능한 크리덴셜</a>이 장치에 저장되어 있고 해당 장치를
          분실하거나 도난당한 경우, 공격자가 피해자의
          <a>검증가능한 크리덴셜</a>을 사용하여 시스템에 액세스할 수 있다.
          이러한 유형의 공격을 완화하는 방법은 다음과 같다:
        </p>

        <ul>
          <li>
            장치에서 비밀번호, PIN, 패턴 또는 생체 인식 화면 잠금 해제 보호
            사용.
          </li>
          <li>
            <a>크리덴셜</a> <a>리포지토리</a>에 대해 비밀번호, 생체 인식 또는
            다중 요소 인증 사용.
          </li>
          <li>
            암호화 키에 액세스할 때 비밀번호, 생체 인식 또는 다중 요소 인증
            사용.
          </li>
          <li>별도의 하드웨어 기반 서명 장치 사용.</li>
          <li>위의 모든 것 또는 조합.</li>
        </ul>
      </section>
    </section>

    <section class="informative">
      <h2>접근성 고려사항</h2>

      <p>
        구현자가 이 규격에 설명된 데이터를 처리할 때 알고 있어야 할 몇 가지
        접근성 고려사항이 있다. 모든 웹 표준이나 프로토콜의 구현과 마찬가지로,
        접근성 문제를 무시하면 인구의 상당 부분이 이 정보를 사용할 수 없게 된다.
        모든 사람이 능력에 관계없이 이 데이터를 사용할 수 있도록 하려면
        [[WCAG21]]과 같은 접근성 지침과 표준을 따르는 것이 중요하다. 이는 특히
        역사적으로 보조 기술에 문제를 야기해 온 암호화를 활용하는 시스템을
        구축할 때 특히 중요하다.
      </p>

      <p>
        이 섹션에서는 이 데이터 모델을 활용할 때 고려해야 할 일반적인 접근성
        고려사항에 대해 자세히 설명한다.
      </p>

      <section class="informative">
        <h3>데이터 우선 접근법</h3>

        <p>
          정부 신분증과 같이 오늘날 사용되는 많은 물리적 <a>크리덴셜</a>은 작은
          인쇄, 작고 고해상도 이미지에 대한 의존, 시각 장애인을 위한 편의 시설
          부족 등을 포함한 열악한 접근성 특성을 가지고 있다.
        </p>

        <p>
          이 데이터 모델을 활용하여 <a>검증가능한 크리덴셜</a>을 만들 때, 데이터
          모델 설계자는 <em>데이터 우선</em> 접근 방식을 사용하는 것이 좋다.
          예를 들어, <a>크리덴셜</a>을 표현하기 위해 데이터나 그래픽 이미지를
          사용하는 선택권이 주어진 경우, 설계자는 기관명이나 전문
          <a>크리덴셜</a>과 같은 이미지의 모든 요소를 뷰어의 이미지 해석에
          의존하는 대신 기계 판독 가능한 방식으로 표현해야 한다. 데이터 우선
          접근 방식을 사용하는 것이 선호되는 이유는 다양한 능력을 가진 사람들을
          위한 다양한 인터페이스를 구축하는 기본 요소를 제공하기 때문이다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>국제화 고려사항</h2>

      <p>
        구현자는 이 규격에 설명된 데이터를 게시할 때 고려해야 할 여러 국제화
        사항에 유의해야 한다. 모든 웹 표준 또는 프로토콜 구현과 마찬가지로,
        국제화를 무시하면 서로 다른 언어와 사회에서 데이터를 생성하고 사용하기
        어려워지므로 규격의 적용 가능성이 제한되고 표준으로서의 가치가 크게
        감소한다.
      </p>

      <p>
        구현자는 W3C 국제화 활동에서 발행한
        <em>웹에서의 문자열: 언어 및 방향 메타데이터</em> 문서 [[STRING-META]]를
        읽어볼 것을 강력히 권장한다. 이 문서는 국제화를 지원하기 위해 텍스트에
        대한 신뢰할 수 있는 메타데이터를 제공해야 할 필요성에 대해 자세히
        설명한다. 구현자는 최신 국제화 고려사항에 대한 정보를 얻기 위해
        검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를 읽어볼 것을
        권장한다.
      </p>

      <p>
        이 섹션에서는 이 데이터 모델을 활용할 때 고려해야 할 일반적인 국제화
        고려사항을 간략히 설명하며, 구현자가 관심 있어 할
        <em>웹에서의 문자열: 언어 및 방향 메타데이터</em> 문서 [[STRING-META]]의
        특정 부분을 강조하기 위한 것이다.
      </p>

      <section class="informative">
        <h3>언어와 기본 방향</h3>

        <p>
          데이터 게시자는 [[JSON-LD]], [[JSON]], CBOR [[?RFC7049]]와 같은 여러
          표현 구문에서 언어 및 기본 방향 정보의 표현이 가능하도록 하기 위해
          <em>웹에서의 문자열: 언어 및 방향 메타데이터</em> 문서
          [[STRING-META]]의 교차 구문 표현 섹션을 읽는 것이 좋다.
        </p>

        <p>
          일반적인 설계 패턴은 언어 및 선택적으로 특정 기본 방향으로 태그된
          텍스트 문자열을 표현할 때 다음 마크업 템플릿을 사용하는 것이다.
        </p>

        <pre
          class="example nohighlight"
          title="Design pattern for natural language strings"
        >
"<a>property</a>": {
  "value": "<span class="highlight">The string value</span>",
  "lang": "<code>LANGUAGE</code>"
  "dir": "<code>DIRECTION</code>"
}
      </pre>

        <p>
          위의 설계 패턴을 사용하여 다음 예제는 텍스트 방향을 지정하지 않고
          영어로 된 책의 제목을 표현한다.
        </p>

        <pre
          class="example nohighlight"
          title="Expressing natural language text as English"
        >
"title": {
  "value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
  "lang": "<code>en</code>"
}
      </pre>

        <p>
          다음 예제는 오른쪽에서 왼쪽으로의 기본 방향으로 아랍어로 표현된 유사한
          제목을 사용한다.
        </p>

        <pre
          class="example nohighlight"
          title="Arabic text with a base direction of right-to-left"
        >
"title": {
  "value": "<span class="highlight">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "lang": "<code>ar</code>"
  "dir": "<code>rtl</code>"
}
      </pre>

        <p class="note">
          많은 시스템이 텍스트 문자열의 첫 번째 문자를 사용하여 텍스트 방향을
          결정하기 때문에, 위의 텍스트는 언어와 방향을 명시적으로 표현하지
          않으면 왼쪽에서 오른쪽으로 잘못 렌더링될 가능성이 높다.
        </p>

        <p>
          JSON-LD를 활용하는 구현자는 국제화된 <a>속성</a>을 정의하는 JSON-LD
          컨텍스트를 <a href="#extensibility">확장</a>하고 JSON-LD의 범위 지정
          컨텍스트 기능을 사용하여 <code>@value</code>, <code>@language</code>,
          <code>@direction</code> 키워드를 각각 <code>value</code>,
          <code>lang</code>, <code>dir</code>로 별칭하는 것이 좋다. 이를
          수행하는 JSON-LD 컨텍스트 스니펫의 예는 아래에 나와 있다.
        </p>

        <pre
          class="example nohighlight"
          title="Specifying scoped aliasing for language information"
        >
"title": {
  <span class="highlight">"@context": {"value": "@value", "lang": "@language", "dir": "@direction"}</span>,
  "@id": "https://www.w3.org/2018/credentials/examples#title"
}
      </pre>
      </section>

      <section class="informative">
        <h3>복잡한 언어 마크업</h3>
        <p>
          단일 자연어 문자열에 여러 언어, 기본 방향 및 주석이 사용되는 경우
          일반적으로 더 복잡한 메커니즘이 필요하다. HTML과 같은 마크업 언어를
          사용하여 여러 언어와 기본 방향으로 텍스트를 인코딩할 수 있다. 또한
          <code>rdf:HTML</code> 데이터 유형을 사용하여 JSON-LD에서 이러한 값을
          정확하게 인코딩할 수 있다.
        </p>
        <p>
          HTML로 정보를 인코딩할 수 있음에도 불구하고 구현자는 다음과 같은
          이유로 이렇게 하지 않는 것이 좋다:
        </p>
        <ul>
          <li>
            일종의 HTML 프로세서가 필요하므로 언어 및 기본 방향 정보 처리 부담이
            증가한다.
          </li>
          <li>
            무분별하게 HTML을 처리하면 데이터 생성 과정의 어느 시점에서 공격자가
            주입한 <code>script</code> 태그를 실행하여 이 데이터 모델을 사용할
            때 보안 공격 표면이 증가한다.
          </li>
        </ul>
        <p>
          구현자가 특정 사용 사례를 해결하기 위해 실행 가능한 스크립트를 포함할
          수 있는 HTML이나 기타 마크업 언어를 사용해야 한다고 생각하는 경우,
          공격자가 마크업을 사용하여 마크업 소비자에 대한 주입 공격을 수행하는
          방법을 분석한 다음 식별된 공격에 대한 완화책을 배포하는 것이 좋다.
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2>유효성 검사</h2>

      <p>
        이 규격은 <a>검증가능한 크리덴셜</a> 또는
        <a>검증가능한 프레젠테이션</a>의 <a>유효성 검사</a> 프로세스에 대한
        적합성 기준을 제공하지 않지만, 독자는 <a>검증자</a>가
        <a>유효성 검사</a> 프로세스 중에 이 데이터 모델의 정보를 어떻게 활용할
        것으로 예상되는지 궁금할 수 있다. 이 섹션에서는 <a>검증자</a>가 이
        규격의 데이터 필드를 사용할 것으로 예상되는 방식과 관련하여 작업 그룹이
        나눈 대화 중 일부를 다룬다.
      </p>

      <section class="informative">
        <h3>크리덴셜 주체</h3>

        <p>
          <a>보유자</a>가 제시한 <a>검증가능한 크리덴셜</a>에서 각
          <code>credentialSubject</code>의 <code>id</code> <a>속성</a>과 연결된
          값은 <a>검증자</a>에게 <a>주체</a>를 식별할 것으로 예상된다.
          <a>보유자</a>가 <a>주체</a>이기도 한 경우, <a>검증자</a>가
          <a>보유자</a>와 관련된 공개 키 메타데이터를 가지고 있다면
          <a>보유자</a>를 인증할 수 있다. 그런 다음 <a>검증자</a>는
          <a>검증가능한 프레젠테이션</a>에 포함된 <a>보유자</a>가 생성한 서명을
          사용하여 <a>보유자</a>를 인증할 수 있다. <code>id</code> <a>속성</a>은
          선택 사항이다. <a>검증자</a>는 <a>검증가능한 크리덴셜</a>의 다른
          <a>속성</a>을 사용하여 <a>주체</a>를 고유하게 식별할 수 있다.
        </p>

        <p class="note">
          <a>검증가능한 크리덴셜</a>에서 인증 및 WebAuthn이 어떻게 작동하는지에
          대한 정보는 검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를
          참조하라.
        </p>
      </section>

      <section class="informative">
        <h3>발급자</h3>

        <p>
          <code>issuer</code> <a>속성</a>과 연결된 값은 <a>검증자</a>에게
          알려지고 신뢰할 수 있는 <a>발급자</a>를 식별할 것으로 예상된다.
        </p>

        <p>
          <code>issuer</code> <a>속성</a>과 관련된 메타데이터는
          <a>검증자</a>에게 제공될 것으로 예상된다. 예를 들어, <a>발급자</a>는
          자신이 발급한 <a>검증가능한 크리덴셜</a>에 디지털 서명하는 데 사용하는
          공개 키를 포함하는 정보를 게시할 수 있다. 이 메타데이터는
          <a>검증가능한 크리덴셜</a>의 증명을 확인할 때 관련이 있다.
        </p>
      </section>

      <section class="informative">
        <h3>발행일</h3>
        <p>
          <code>issuanceDate</code>는 <a>검증자</a>에게 예상되는 범위 내에 있을
          것으로 예상된다. 예를 들어, <a>검증자</a>는
          <a>검증가능한 크리덴셜</a>의 발행일이 미래가 아닌지 확인할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3 id="proofs-signatures">증명(서명)</h3>

        <p>
          <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의
          정보가 변조되지 않았음을 증명하는 데 사용되는 암호학적 메커니즘을
          <em>증명</em>이라고 한다. 디지털 서명, 영지식 증명, 작업 증명, 지분
          증명 등 여러 유형의 암호학적 증명이 있다. 일반적으로 증명을 검증할 때
          구현은 다음을 보장해야 한다:
        </p>

        <ul>
          <li>증명이 알려진 증명 스위트의 형태로 제공된다.</li>
          <li>필요한 모든 증명 스위트 <a>속성</a>이 존재한다.</li>
          <li>
            증명 스위트 <a>검증</a> 알고리즘을 데이터에 적용하면 허용 가능한
            증명이 생성된다.
          </li>
        </ul>

        <p>
          일부 증명은 디지털 서명이다. 일반적으로 디지털 서명을 검증할 때 구현은
          다음을 보장해야 한다:
        </p>

        <ul>
          <li>
            서명과 관련된 공개 키에 대한 허용 가능한 최신 메타데이터를 사용할 수
            있다. 예를 들어, 메타데이터에는 만료, 키 소유자 또는 키 목적과
            관련된 <a>속성</a>이 포함될 수 있다.
          </li>
          <li>키가 일시 중지, 해지 또는 만료되지 않았다.</li>
          <li>암호화 서명이 검증될 것으로 예상된다.</li>
          <li>
            암호 스위트에 <code>proofPurpose</code> <a>속성</a>이 필요한 경우
            해당 속성이 존재하고 <code>assertionMethod</code>와 같은 유효한
            값이어야 한다.
          </li>
        </ul>

        <p class="note">
          디지털 서명은 변조 저항성 이외에도 즉시 명확하지 않은 여러 보호 기능을
          제공한다. 예를 들어, 연결된 데이터 서명 <code>created</code>
          <a>속성</a>은 <a>크리덴셜</a>이 <a>검증</a>된 것으로 간주되어서는 안
          되는 날짜와 시간을 설정한다. <code>verificationMethod</code>
          <a>속성</a>은 예를 들어 디지털 서명을 검증하는 데 사용할 수 있는 공개
          키를 지정한다. 공개 키 URL을 역참조하면 키 컨트롤러에 대한 정보가
          드러나며, 이는 <a>크리덴셜</a>의 발급자와 대조하여 확인할 수 있다.
          <code>proofPurpose</code> <a>속성</a>은 증명의 목적을 명확하게
          표현하고 이 정보가 서명에 의해 보호되도록 한다. 증명은 일반적으로 인증
          목적으로 <a>검증가능한 프레젠테이션</a>에 첨부되고 주장 방법으로
          <a>검증가능한 크리덴셜</a>에 첨부된다.
        </p>
      </section>

      <section class="informative">
        <h3 id="expiration">만료</h3>
        <p>
          <code>expirationDate</code>는 <a>검증자</a>에게 예상되는 범위 내에
          있을 것으로 예상된다. 예를 들어, <a>검증자</a>는
          <a>검증가능한 크리덴셜</a>의 만료 날짜가 과거가 아닌지 확인할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3 id="status">상태</h3>

        <p>
          <code>credentialStatus</code> 속성을 사용할 수 있는 경우,
          <a>검증가능한 크리덴셜</a>의 상태는 <a>검증가능한 크리덴셜</a>에 대한
          <code>credentialStatus</code> <a>유형</a> 정의와 <a>검증자</a> 자체의
          상태 평가 기준에 따라 <a>검증자</a>에 의해 평가될 것으로 예상된다.
          예를 들어, <a>검증자</a>는 <a>검증가능한 크리덴셜</a>의 상태가
          "<a>발급자</a>에 의해 취소되지 않았음"을 확인할 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3>용도 적합성</h3>

        <p>
          용도 적합성은 <a>검증가능한 크리덴셜</a>의 사용자 정의 <a>속성</a>이
          <a>검증자</a>의 목적에 적합한지 여부에 관한 것이다. 예를 들어,
          <a>검증자</a>가 <a>주체</a>의 나이가 21세 이상인지 확인해야 하는 경우
          특정 <code>birthdate</code> <a>속성</a>이나 <code>ageOver</code>와
          같은 더 추상적인 <a>속성</a>에 의존할 수 있다.
        </p>

        <p>
          <a>검증자</a>는 <a>발급자</a>가 해당 <a>클레임</a>을 만드는 것을
          신뢰한다. 예를 들어, 프랜차이즈 패스트푸드 레스토랑 체인점은
          프랜차이즈 본사가 만든 할인 쿠폰 <a>클레임</a>을 신뢰한다.
          <a>보유자</a>와 <a>검증자</a>는 정책을 무시함으로써 발생하는 책임을
          수용하지 않는 한 <a>검증가능한 크리덴셜</a>에서 <a>발급자</a>가 표현한
          정책 정보를 존중해야 한다.
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2>Contexts, Types, and Credential Schemas</h2>

      <section class="appendix informative">
        <h3 id="base-context">기반 컨텍스트</h3>
        <p>
          <code>https://www.w3.org/2018/credentials/v1</code>에 위치하고 SHA-256
          다이제스트가
          <strong
            ><code
              >ab4ddd9a531758807a79a5b450510d61ae8d147eab966cc9a200c07095b0cdcc</code
            ></strong
          >인 기반 컨텍스트는 로컬 캐시된 사본을 구현하는 데 사용될 수 있다.
          편의를 위해 이 섹션에서도 기반 컨텍스트를 제공한다.
        </p>

        <pre class="informative">
{
  "@context": {
    "@version": 1.1,
    "@protected": true,

    "id": "@id",
    "type": "@type",

    "VerifiableCredential": {
      "@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "cred": "https://www.w3.org/2018/credentials#",
        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "credentialSchema": {
          "@id": "cred:credentialSchema",
          "@type": "@id",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "cred": "https://www.w3.org/2018/credentials#",

            "JsonSchemaValidator2018": "cred:JsonSchemaValidator2018"
          }
        },
        "credentialStatus": {"@id": "cred:credentialStatus", "@type": "@id"},
        "credentialSubject": {"@id": "cred:credentialSubject", "@type": "@id"},
        "evidence": {"@id": "cred:evidence", "@type": "@id"},
        "expirationDate": {"@id": "cred:expirationDate", "@type": "xsd:dateTime"},
        "holder": {"@id": "cred:holder", "@type": "@id"},
        "issued": {"@id": "cred:issued", "@type": "xsd:dateTime"},
        "issuer": {"@id": "cred:issuer", "@type": "@id"},
        "issuanceDate": {"@id": "cred:issuanceDate", "@type": "xsd:dateTime"},
        "proof": {"@id": "sec:proof", "@type": "@id", "@container": "@graph"},
        "refreshService": {
          "@id": "cred:refreshService",
          "@type": "@id",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "cred": "https://www.w3.org/2018/credentials#",

            "ManualRefreshService2018": "cred:ManualRefreshService2018"
          }
        },
        "termsOfUse": {"@id": "cred:termsOfUse", "@type": "@id"},
        "validFrom": {"@id": "cred:validFrom", "@type": "xsd:dateTime"},
        "validUntil": {"@id": "cred:validUntil", "@type": "xsd:dateTime"}
      }
    },

    "VerifiablePresentation": {
      "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "cred": "https://www.w3.org/2018/credentials#",
        "sec": "https://w3id.org/security#",

        "holder": {"@id": "cred:holder", "@type": "@id"},
        "proof": {"@id": "sec:proof", "@type": "@id", "@container": "@graph"},
        "verifiableCredential": {"@id": "cred:verifiableCredential", "@type": "@id", "@container": "@graph"}
      }
    },

    "EcdsaSecp256k1Signature2019": {
      "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "EcdsaSecp256r1Signature2019": {
      "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "Ed25519Signature2018": {
      "@id": "https://w3id.org/security#Ed25519Signature2018",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "RsaSignature2018": {
      "@id": "https://w3id.org/security#RsaSignature2018",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "proof": {"@id": "https://w3id.org/security#proof", "@type": "@id", "@container": "@graph"}
  }
}
</pre
        >
      </section>
    </section>

    <section class="informative appendix">
      <h3 id="subject-holder-relationships">주체-보유자 관계</h3>
      <p>
        이 섹션에서는 <a>주체</a>와 <a>보유자</a> 사이의 가능한 관계와
        검증가능한 크리덴셜 데이터 모델이 이러한 관계를 어떻게 표현하는지
        설명한다. 다음 다이어그램은 이러한 관계를 보여주며, 이어지는 섹션에서는
        데이터 모델에서 이러한 각 관계가 어떻게 처리되는지 설명한다.
      </p>

      <figure>
        <img
          style="margin: auto; display: block; width: 75%"
          src="diagrams/subject-ne-holder.svg"
          alt="Long decision tree
          from top to bottom.  For the first question, 'Subject
          Present?', No means Bearer Credential and Yes points to the
          rest of the tree.  From this point on until the very end,
          each Yes points to an answer and each No points to another
          question.  The first question here is 'Subject = Holder?',
          with Yes meaning Most Common Use Case.  If No, 'Credential
          Uniquely Identifies Subject?' with Yes meaning Irrelevant who
          Holder is.  If No, 'Subject Passes VC to Holder?' with Yes
          meaning, e.g., Power of Attorney, Employee.  If No, 'Issuer
          Independently Authorizes Holder?' with Yes meaning, e.g., Law
          Enforcement.  If No, 'Holder Acts for Subject?' with Yes
          meaning, e.g., Parent, Pet Owner, Travel Agent.  If No,
          'Holder Acts for Verifier?' with Yes meaning, e.g., Recruiter
          passing on VC of job applicant to employer and No meaning
          'Random Holder with no relationship to Subject, Issuer or Verifier"
        />
        <figcaption style="text-align: center">
          Subject-Holder Relationships in Verifiable Credentials.
        </figcaption>
      </figure>

      <section class="informative">
        <h4>주체가 보유자인 경우</h4>
        <p>
          가장 일반적인 관계는 <a>주체</a>가 <a>보유자</a>인 경우이다. 이 경우,
          <a>검증가능한 프레젠테이션</a>이 <a>보유자</a>에 의해 디지털 서명되고
          포함된 모든 <a>검증가능한 크리덴셜</a>이 <a>보유자</a>와 동일한 것으로
          식별될 수 있는 <a>주체</a>에 관한 것이라면, <a>검증자</a>는
          <a>주체</a>가 <a>보유자</a>임을 쉽게 추론할 수 있다.
        </p>

        <p>
          <code>credentialSubject</code>만 <a>검증가능한 프레젠테이션</a>에
          <a>검증가능한 크리덴셜</a>을 삽입할 수 있는 경우, <a>발급자</a>는 아래
          설명된 대로 <code>nonTransferable</code> <a>속성</a>을
          <a>검증가능한 크리덴셜</a>에 삽입할 수 있다.
        </p>

        <section class="informative">
          <h5>nonTransferable 속성</h5>
          <p>
            <code>nonTransferable</code> <a>속성</a>은
            <a>검증가능한 크리덴셜</a>이 반드시 <code>credentialSubject</code>에
            의해 발급된 증명이 있는 <a>검증가능한 프레젠테이션</a>에만
            캡슐화되어야 함을 나타낸다. <code>nonTransferable</code>
            <a>속성</a>을 포함하는 <a>검증가능한 크리덴셜</a>이 포함된
            <a>검증가능한 프레젠테이션</a>의 증명 생성자가
            <code>credentialSubject</code>가 아닌 경우, 해당 프레젠테이션은
            유효하지 않다.
          </p>

          <pre
            class="example nohighlight"
            title="Usage of the nonTransferable property"
          >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "ProofOfAgeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "ageOver": 21
    },
  "nonTransferable": true,
  "proof": { ..
  "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  ... }
}
          </pre>
        </section>
      </section>

      <section class="informative">
        <h4>크리덴셜이 주체를 고유하게 식별하는 경우</h4>
        <p>
          이 경우, <code>credentialSubject</code> <a>속성</a>에는 <a>주체</a>에
          대한 설명의 측면을 제공하는 여러 <a>속성</a>이 포함될 수 있으며,
          이들이 결합되어 <a>주체</a>를 명확하게 식별한다. 일부 사용 사례에서는
          의사(<a>주체</a>)가 이사회 인증을 받았는지 확인하는 것과 같이
          <a>보유자</a>를 전혀 식별할 필요가 없을 수 있다. 다른 사용 사례에서는
          <a>검증자</a>가 대역외 지식을 사용하여 <a>주체</a>와
          <a>보유자</a> 사이의 관계를 판단해야 할 수 있다.
        </p>

        <pre
          class="example nohighlight"
          title="A credential uniquely identifying a subject"
        >
{
  "@context": ["https://www.w3.org/2018/credentials/v1", "https://schema.org/"]
  "id": "http://example.edu/credentials/332",
  "type": ["VerifiableCredential", "IdentityCredential"],
  "issuer": "https://example.edu/issuers/4",
  "issuanceDate": "2017-02-24T19:73:24Z",
  "credentialSubject": {
    "name": "J. Doe",
    "address": {
      "streetAddress": "10 Rue de Chose",
      "postalCode": "98052",
      "addressLocality": "Paris",
      "addressCountry": "FR"
    },
    "birthDate": "1989-03-15"
    ...
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
          위의 예시는 개인의 이름, 주소, 생년월일을 사용하여 <a>주체</a>를
          고유하게 식별한다.
        </p>
      </section>

      <section class="informative">
        <h4>주체가 검증가능한 크리덴셜을 보유자에게 전달하는 경우</h4>

        <p>
          일반적으로 <a>검증가능한 크리덴셜</a>은 <a>주체</a>에 의해
          <a>검증자</a>에게 제시된다. 그러나 경우에 따라 <a>주체</a>가
          <a>검증가능한 크리덴셜</a>의 전부 또는 일부를 다른 <a>보유자</a>에게
          전달해야 할 수 있다. 예를 들어, 환자(<a>주체</a>)가 너무 아파서
          처방전(<a>검증가능한 크리덴셜</a>)을 약사(<a>검증자</a>)에게 가져갈 수
          없는 경우, 친구가 처방전을 가져가서 약을 받아올 수 있다.
        </p>

        <p>
          데이터 모델은 <a>주체</a>가 새로운 <a>검증가능한 크리덴셜</a>을
          발급하고 이를 새로운 <a>보유자</a>에게 주어 <a>보유자</a>가 두
          <a>검증가능한 크리덴셜</a>을 모두 <a>검증자</a>에게 제시할 수 있도록
          함으로써 이를 허용한다. 그러나 이 두 번째 <a>검증가능한 크리덴셜</a>의
          내용은 애플리케이션마다 다를 가능성이 높으므로 이 규격에서는 이 두
          번째 <a>검증가능한 크리덴셜</a>의 내용을 표준화할 수 없다. 그럼에도
          불구하고, 부록
          <a href="#subject-passes-a-verifiable-credential-to-someone-else"></a
          >에 비규범적인 예시가 제공된다.
        </p>
      </section>

      <section class="informative">
        <h4>보유자가 주체를 대신하여 행동하는 경우</h4>

        <p>
          검증가능한 크리덴셜 데이터 모델은 적어도 다음과 같은 방식으로
          <a>주체</a>를 대신하여 <a>보유자</a>가 행동하는 것을 지원한다:
        </p>

        <ul>
          <li>
            <a>발급자</a>는 <code>credentialSubject</code> <a>속성</a>에
            <a>보유자</a>와 <a>주체</a> 사이의 관계를 포함시킬 수 있다.
          </li>
          <li>
            <a>발급자</a>는 새로운 <a>검증가능한 크리덴셜</a>을 발급하여
            <a>보유자</a>와 <a>주체</a> 사이의 관계를 표현할 수 있으며,
            <a>보유자</a>는 이를 활용한다.
          </li>
          <li>
            <a>주체</a>는 새로운 <a>검증가능한 크리덴셜</a>을 발급하여
            <a>보유자</a>와의 관계를 표현할 수 있으며, <a>보유자</a>는 이를
            활용한다.
          </li>
        </ul>

        <p>
          위에 나열된 메커니즘은 <a>보유자</a>와 <a>주체</a> 사이의 관계를
          설명하고 <a>검증자</a>가 해당 관계가 주어진 사용 사례에 대해 충분히
          표현되었는지 결정하는 데 도움이 된다.
        </p>

        <p class="note">
          <a>발급자</a> 또는 <a>검증자</a>가 <a>주체</a>와 <a>보유자</a> 사이의
          관계를 검증하기 위해 사용하는 추가 메커니즘은 이 규격의 범위를
          벗어난다.
        </p>

        <pre
          class="example nohighlight"
          title="The relationship property in a child's credential"
        >{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "AgeCredential", "RelationshipCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "ageUnder": 16,
    "parent": {
      "id": "did:example:ebfeb1c276e12ec211f712ebc6f",
      "type": "Mother"
    }
  },
  "proof": { <span class="comment">...</span> }  <span class="comment">// the proof is generated by the DMV</span>
}
        </pre>

        <p>
          위의 예시에서 <a>발급자</a>는 자녀와 부모 사이의 관계를 표현하여
          <a>검증자</a>가 자녀나 부모가 제공하는 경우 <a>크리덴셜</a>을 수락할
          가능성이 높다.
        </p>

        <pre
          class="example nohighlight"
          title="A relationship credential issued to a parent"
        >{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1c276e12ec211f712ebc6f",
    "child": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "type": "Child"
    }
  },
  "proof": { <span class="comment">...</span> } <span class="comment">// the proof is generated by the DMV</span>
}
        </pre>

        <p>
          위의 예시에서 <a>발급자</a>는 별도의 <a>크리덴셜</a>에 자녀와 부모
          사이의 관계를 표현하여 <a>검증자</a>가 자녀가 제공하거나 위의
          <a>크리덴셜</a>이 자녀의 <a>크리덴셜</a>과 함께 제공되는 경우 자녀의
          <a>크리덴셜</a>을 수락할 가능성이 높다.
        </p>

        <pre
          class="example nohighlight"
          title="A relationship credential issued by a child"
        >{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.org/credentials/23894",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "http://example.org/credentials/23894",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "parent": {
      "id": "did:example:ebfeb1c276e12ec211f712ebc6f",
      "type": "Mother"
    }
  },
  "proof": { <span class="comment">...</span> } <span class="comment">// the proof is generated by the child</span>
}
        </pre>

        <p>
          위의 예시에서 자녀는 별도의 <a>크리덴셜</a>에 자녀와 부모 사이의
          관계를 표현하여 위의 <a>크리덴셜</a>이 제공되는 경우 <a>검증자</a>가
          자녀의 <a>크리덴셜</a>을 수락할 가능성이 높다.
        </p>
        <p>
          마찬가지로, 위 예시에서 설명한 전략은 위임장, 애완동물 소유권, 환자
          처방전 수령 등 다른 많은 유형의 사용 사례에 사용될 수 있다.
        </p>
      </section>

      <section class="informative">
        <h3 id="subject-passes-a-verifiable-credential-to-someone-else">
          주체가 검증가능한 크리덴셜을 다른 사람에게 전달하는 경우
        </h3>
        <p>
          <a>주체</a>가 <a>검증가능한 크리덴셜</a>을 다른 <a>보유자</a>에게
          전달할 때, <a>주체</a>는 다음과 같은 새로운
          <a>검증가능한 크리덴셜</a>을 <a>보유자</a>에게 발급할 수 있다:
        </p>
        <ul>
          <li><a>발급자</a>는 <a>주체</a>이다.</li>
          <li>
            <a>주체</a>는 <a>검증가능한 크리덴셜</a>이 전달되는
            <a>보유자</a>이다.
          </li>
          <li><a>클레임</a>은 전달되는 <a>속성</a>을 포함한다.</li>
        </ul>
        <p>
          이제 <a>보유자</a>는 이 두 <a>검증가능한 크리덴셜</a>을 포함하는
          <a>검증가능한 프레젠테이션</a>을 생성하여 <a>검증자</a>가
          <a>주체</a>가 원래의 <a>검증가능한 크리덴셜</a>을 <a>보유자</a>에게
          제공했음을 <a>검증</a>할 수 있도록 한다.
        </p>
        <pre
          class="example nohighlight"
          title="A holder presenting a
verifiable credential that was passed to it by the subject"
        >
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "https://example.com/VP/0987654321",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [
    {
     "@context": [
       "https://www.w3.org/2018/credentials/v1",
       "https://www.w3.org/2018/credentials/examples/v1"
      ],
      "id": "http://pharma.example.com/credentials/3732",
      "type": ["VerifiableCredential", "PrescriptionCredential"],
      "issuer": "https://pharma.example.com/issuer/4",
      "issuanceDate": "2010-01-01T19:23:24Z",
      "credentialSubject": {
        "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
        "prescription": {....}
      },
      "credentialStatus": {
        "id": "https://pharma.example.com/credentials/status/3#94567",
        "type": "RevocationList2020Status",
        "revocationListIndex": "94567",
        "revocationListCredential": "https://pharma.example.com/credentials/status/3"
      },
      "proof": {....}
    },
    {
      "@context": [
        "https://www.w3.org/2018/credentials/v1",
        "https://www.w3.org/2018/credentials/examples/v1"
      ],
      "id": "https://example.com/VC/123456789",
      "type": ["VerifiableCredential", "PrescriptionCredential"],
      "issuer": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "issuanceDate": "2010-01-03T19:53:24Z",
      "credentialSubject": {
        "id": "did:example:76e12ec21ebhyu1f712ebc6f1z2",
        "prescription": {....}
      },
      "proof": {
        "type": "RsaSignature2018",
        "created": "2018-06-17T10:03:48Z",
        "proofPurpose": "assertionMethod",
        "jws": "pYw8XNi1..Cky6Ed=",
        "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21/keys/234"
      }
    }
  ],
  "proof": [{
    "type": "RsaSignature2018",
    "created": "2018-06-18T21:19:10Z",
    "proofPurpose": "authentication",
    "verificationMethod": "did:example:76e12ec21ebhyu1f712ebc6f1z2/keys/2",
    "challenge": "c0ae1c8e-c7e7-469f-b252-86e6a0e7387e",
    "jws": "BavEll0/I1..W3JT24="
  }]
}
      </pre
        >

        <p>
          위의 예시에서, 환자(원래의 <a>주체</a>)는 처방전(원래의
          <a>검증가능한 크리덴셜</a>)을 친구에게 전달하고, 친구에게 새로운
          <a>검증가능한 크리덴셜</a>을 발급했는데, 이 크리덴셜에서 친구가
          <a>주체</a>이고, 원래 <a>검증가능한 크리덴셜</a>의 <a>주체</a>가
          <a>발급자</a>이며, <a>크리덴셜</a>은 원래 처방전의 사본이다.
        </p>
      </section>

      <section class="informative">
        <h4>발급자가 보유자에게 권한을 부여하는 경우</h4>

        <p>
          <a>발급자</a>가 <a>보유자</a>가 아닌 <a>주체</a>를 설명하는
          <a>크리덴셜</a>을 소유하도록 <a>보유자</a>에게 권한을 부여하고자 하고,
          <a>보유자</a>가 <a>주체</a>와 알려진 관계가 없는 경우, <a>발급자</a>는
          <a>주체</a>의 <a>크리덴셜</a>에 <a>발급자</a> 자신과 <a>보유자</a>의
          관계를 삽입할 수 있다.
        </p>

        <p class="note">
          검증가능한 크리덴셜은 권한 부여 프레임워크가 아니므로 위임은 이 규격의
          범위를 벗어난다. 그러나 검증가능한 크리덴셜이 권한 부여 및 위임
          시스템을 구축하는 데 사용될 가능성이 있다는 점은 이해하고 있다. 다음은
          일부 사용 사례에 적합할 수 있는 한 가지 접근 방식이다.
        </p>

        <pre
          class="example nohighlight"
          title="A credential issued to a
holder who is not the (only) subject of the credential, who has no relationship with
the subject of the credential, but who has a relationship with the issuer"
        >

{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "NameAndAddress"],
  "issuer": "https://example.edu/issuers/14",
  "holder": {
    "type": "LawEnforcement",
    "id": "did:example:ebfeb1276e12ec21f712ebc6f1c"
  },
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Mr John Doe",
    "address": "10 Some Street, Anytown, ThisLocal, Country X"
  },
  "proof": {
    "type": "RsaSignature2018",
    "created": "2018-06-17T10:03:48Z",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "https://example.edu/issuers/14/keys/234",
    "jws": "pY9...Cky6Ed = "
  }
}
        </pre>
      </section>

      <section class="informative">
        <h4>
          보유자가 검증자를 대신하여 행동하거나, 주체, 발급자 또는 검증자와
          관계가 없는 경우
        </h4>
        <p>
          검증가능한 크리덴셜 데이터 모델은 현재 이러한 시나리오를 지원하지
          않는다. 이들이 어떻게 지원될 수 있는지에 대해서는 추가 연구가
          필요하다.
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2>IANA Considerations</h2>
      <p>
        This section will be submitted to the Internet Engineering Steering
        Group (IESG) for review, approval, and registration with IANA in the
        "JSON Web Token Claims Registry".
      </p>

      <ul>
        <li>Claim Name: "vc"</li>
        <li>Claim Description: Verifiable Credential</li>
        <li>Change Controller: W3C</li>
        <li>
          Specification Document(s):
          <a href="https://www.w3.org/TR/vc-data-model/"
            >Section 6.3.1.2: JSON Web Token Extensions of Verifiable
            Credentials Data Model 1.0</a
          >
        </li>
      </ul>

      <ul>
        <li>Claim Name: "vp"</li>
        <li>Claim Description: Verifiable Presentation</li>
        <li>Change Controller: W3C</li>
        <li>
          Specification Document(s):
          <a href="https://www.w3.org/TR/vc-data-model/"
            >Section 6.3.1.2: JSON Web Token Extensions of Verifiable
            Credentials Data Model 1.0</a
          >
        </li>
      </ul>
    </section>

    <section>
      <h2>Revision History</h2>

      <p>
        This section contains the substantive changes that have been made since
        the publication of v1.0 of this specification as a W3C Recommendation.
      </p>

      <p>
        Changes since the
        <a href="https://www.w3.org/TR/2019/REC-vc-data-model-20191119/">
          Recommendation </a
        >:
      </p>

      <ul>
        <li>Add this revision history section.</li>

        <li>
          Update previous normative references that pointed to RFC3339 for
          datetime details to now normatively reference the datetime details
          described in XMLSCHEMA11-2 which more accurately reflects the usage in
          examples and libraries.
        </li>

        <li>
          Loosen the requirement to use URLs to use <a>URIs</a> in the
          <code>id</code> property of the <code>credentialStatus</code> and
          <code>refreshService</code>
          sections of the data model.
        </li>

        <li>
          Loosen normative statements in the zero-knowledge proofs section to
          enable compliance of new zero-knowledge proof schemes, such as BBS+,
          that have been created since the v1.0 specification was published as a
          Recommendation.
        </li>

        <li>
          Update all references to point to the latest version of the referenced
          specifications. Fix broken links to papers that have become
          unavailable to updated locations where the papers are available.
        </li>

        <li>Increase accessibility of SVG diagrams.</li>

        <li>
          Fix editorial bugs in a few examples related to `issuer`,
          `issuanceDate`, `credentialStatus`, dates, dead links, and minor
          syntax errors.
        </li>

        <li>
          Move acknowledgements from Status of the Document section into the
          Acknowledgements appendix.
        </li>
      </ul>
    </section>

    <section class="appendix informative">
      <h2>Acknowledgements</h2>

      <p>
        The Working Group thanks the following individuals not only for their
        contributions toward the content of this document, but also for yeoman's
        work in this standards community that drove changes, discussion, and
        consensus among a sea of varied opinions: Matt Stone, Gregg Kellogg, Ted
        Thibodeau Jr, Oliver Terbu, Joe Andrieu, David I. Lehn, Matthew Collier,
        and Adrian Gropper.
      </p>

      <p>
        Work on this specification has been supported by the Rebooting the Web
        of Trust community facilitated by Christopher Allen, Shannon Appelcline,
        Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young, Manu Sporny,
        Drummond Reed, Joe Andrieu, Heather Vescent, Kim Hamilton Duffy,
        Samantha Chase, and Andrew Hughes. The participants in the Internet
        Identity Workshop, facilitated by Phil Windley, Kaliya Young, Doc
        Searls, and Heidi Nobantu Saul, also supported the refinement of this
        work through numerous working sessions designed to educate about, debate
        on, and improve this specification.
      </p>

      <p>
        The Working Group also thanks our Chairs, Dan Burnett, Matt Stone, Brent
        Zundel, and Wayne Chang, as well as our W3C Staff Contacts, Kazuyuki
        Ashimura and Ivan Herman, for their expert management and steady
        guidance of the group through the W3C standardization process.
      </p>

      <p>
        Portions of the work on this specification have been funded by the
        United States Department of Homeland Security's Science and Technology
        Directorate under contract HSHQDC-17-C-00019. The content of this
        specification does not necessarily reflect the position or the policy of
        the U.S. Government and no official endorsement should be inferred.
      </p>

      <p>
        The Working Group would like to thank the following individuals for
        reviewing and providing feedback on the specification (in alphabetical
        order):
      </p>

      <p>
        Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
        Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
        Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
        Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
        Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
        Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
        Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
        David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
        Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
        David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
        Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
        Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
        O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric
        Prud'hommeaux, Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens,
        Justin Richer, Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley,
        Markus Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu
        Sporny, Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John
        Tibbetts, Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer
        Webber, Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent
        Zundel.
      </p>
    </section>
  </body>
</html>
